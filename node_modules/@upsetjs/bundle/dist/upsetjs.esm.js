/**
 * @upsetjs/bundle
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>
 */
var n,
    u,
    i,
    t,
    o,
    r,
    f,
    e = {},
    c = [],
    a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function s(n, l) {
  for (var u in l) {
    n[u] = l[u];
  }
  return n;
}
function v(n) {
  var l = n.parentNode;
  l && l.removeChild(n);
}
function h(n, l, u) {
  var i,
      t = arguments,
      o = {};
  for (i in l) {
    "key" !== i && "ref" !== i && (o[i] = l[i]);
  }
  if (arguments.length > 3) for (u = [u], i = 3; i < arguments.length; i++) {
    u.push(t[i]);
  }
  if (null != u && (o.children = u), "function" == typeof n && null != n.defaultProps) for (i in n.defaultProps) {
    void 0 === o[i] && (o[i] = n.defaultProps[i]);
  }
  return y(n, o, l && l.key, l && l.ref, null);
}
function y(l, u, i, t, o) {
  var r = {
    type: l,
    props: u,
    key: i,
    ref: t,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    constructor: void 0,
    __v: o
  };
  return null == o && (r.__v = r), n.vnode && n.vnode(r), r;
}
function p() {
  return {};
}
function d(n) {
  return n.children;
}
function m(n, l) {
  this.props = n, this.context = l;
}
function w(n, l) {
  if (null == l) return n.__ ? w(n.__, n.__.__k.indexOf(n) + 1) : null;
  for (var u; l < n.__k.length; l++) {
    if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
  }
  return "function" == typeof n.type ? w(n) : null;
}
function k(n) {
  var l, u;
  if (null != (n = n.__) && null != n.__c) {
    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
      if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
    }
    return k(n);
  }
}
function g(l) {
  (!l.__d && (l.__d = !0) && u.push(l) && !i++ || o !== n.debounceRendering) && ((o = n.debounceRendering) || t)(_);
}
function _() {
  for (var n; i = u.length;) {
    n = u.sort(function (n, l) {
      return n.__v.__b - l.__v.__b;
    }), u = [], n.some(function (n) {
      var l, u, i, t, o, r, f;
      n.__d && (r = (o = (l = n).__v).__e, (f = l.__P) && (u = [], (i = s({}, o)).__v = i, t = z(f, o, i, l.__n, void 0 !== f.ownerSVGElement, null, u, null == r ? w(o) : r), T(u, o), t != r && k(o)));
    });
  }
}
function b(n, l, u, i, t, o, r, f, a, s) {
  var h,
      p,
      m,
      k,
      g,
      _,
      b,
      x,
      A,
      P = i && i.__k || c,
      C = P.length;
  for (a == e && (a = null != r ? r[0] : C ? w(i, 0) : null), u.__k = [], h = 0; h < l.length; h++) {
    if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k ? y(null, k, null, null, k) : Array.isArray(k) ? y(d, {
      children: k
    }, null, null, null) : null != k.__e || null != k.__c ? y(k.type, k.props, k.key, null, k.__v) : k)) {
      if (k.__ = u, k.__b = u.__b + 1, null === (m = P[h]) || m && k.key == m.key && k.type === m.type) P[h] = void 0;else for (p = 0; p < C; p++) {
        if ((m = P[p]) && k.key == m.key && k.type === m.type) {
          P[p] = void 0;
          break;
        }
        m = null;
      }
      if (g = z(n, k, m = m || e, t, o, r, f, a, s), (p = k.ref) && m.ref != p && (x || (x = []), m.ref && x.push(m.ref, null, k), x.push(p, k.__c || g, k)), null != g) {
        if (null == b && (b = g), A = void 0, void 0 !== k.__d) A = k.__d, k.__d = void 0;else if (r == m || g != a || null == g.parentNode) {
          n: if (null == a || a.parentNode !== n) n.appendChild(g), A = null;else {
            for (_ = a, p = 0; (_ = _.nextSibling) && p < C; p += 2) {
              if (_ == g) break n;
            }
            n.insertBefore(g, a), A = a;
          }
          "option" == u.type && (n.value = "");
        }
        a = void 0 !== A ? A : g.nextSibling, "function" == typeof u.type && (u.__d = a);
      } else a && m.__e == a && a.parentNode != n && (a = w(m));
    }
  }
  if (u.__e = b, null != r && "function" != typeof u.type) for (h = r.length; h--;) {
    null != r[h] && v(r[h]);
  }
  for (h = C; h--;) {
    null != P[h] && D(P[h], P[h]);
  }
  if (x) for (h = 0; h < x.length; h++) {
    j(x[h], x[++h], x[++h]);
  }
}
function x(n) {
  return null == n || "boolean" == typeof n ? [] : Array.isArray(n) ? c.concat.apply([], n.map(x)) : [n];
}
function A(n, l, u, i, t) {
  var o;
  for (o in u) {
    "children" === o || "key" === o || o in l || C(n, o, null, u[o], i);
  }
  for (o in l) {
    t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || C(n, o, l[o], u[o], i);
  }
}
function P(n, l, u) {
  "-" === l[0] ? n.setProperty(l, u) : n[l] = "number" == typeof u && !1 === a.test(l) ? u + "px" : null == u ? "" : u;
}
function C(n, l, u, i, t) {
  var o, r, f, e, c;
  if (t ? "className" === l && (l = "class") : "class" === l && (l = "className"), "style" === l) {
    if (o = n.style, "string" == typeof u) o.cssText = u;else {
      if ("string" == typeof i && (o.cssText = "", i = null), i) for (e in i) {
        u && e in u || P(o, e, "");
      }
      if (u) for (c in u) {
        i && u[c] === i[c] || P(o, c, u[c]);
      }
    }
  } else "o" === l[0] && "n" === l[1] ? (r = l !== (l = l.replace(/Capture$/, "")), f = l.toLowerCase(), l = (f in n ? f : l).slice(2), u ? (i || n.addEventListener(l, N, r), (n.l || (n.l = {}))[l] = u) : n.removeEventListener(l, N, r)) : "list" !== l && "tagName" !== l && "form" !== l && "type" !== l && "size" !== l && !t && l in n ? n[l] = null == u ? "" : u : "function" != typeof u && "dangerouslySetInnerHTML" !== l && (l !== (l = l.replace(/^xlink:?/, "")) ? null == u || !1 === u ? n.removeAttributeNS("http://www.w3.org/1999/xlink", l.toLowerCase()) : n.setAttributeNS("http://www.w3.org/1999/xlink", l.toLowerCase(), u) : null == u || !1 === u && !/^ar/.test(l) ? n.removeAttribute(l) : n.setAttribute(l, u));
}
function N(l) {
  this.l[l.type](n.event ? n.event(l) : l);
}
function z(l, u, i, t, o, r, f, e, c) {
  var a,
      v,
      h,
      y,
      p,
      w,
      k,
      g,
      _,
      x,
      A,
      P = u.type;
  if (void 0 !== u.constructor) return null;
  (a = n.__b) && a(u);
  try {
    n: if ("function" == typeof P) {
      if (g = u.props, _ = (a = P.contextType) && t[a.__c], x = a ? _ ? _.props.value : a.__ : t, i.__c ? k = (v = u.__c = i.__c).__ = v.__E : ("prototype" in P && P.prototype.render ? u.__c = v = new P(g, x) : (u.__c = v = new m(g, x), v.constructor = P, v.render = E), _ && _.sub(v), v.props = g, v.state || (v.state = {}), v.context = x, v.__n = t, h = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != P.getDerivedStateFromProps && (v.__s == v.state && (v.__s = s({}, v.__s)), s(v.__s, P.getDerivedStateFromProps(g, v.__s))), y = v.props, p = v.state, h) null == P.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && v.__h.push(v.componentDidMount);else {
        if (null == P.getDerivedStateFromProps && g !== y && null != v.componentWillReceiveProps && v.componentWillReceiveProps(g, x), !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(g, v.__s, x) || u.__v === i.__v) {
          for (v.props = g, v.state = v.__s, u.__v !== i.__v && (v.__d = !1), v.__v = u, u.__e = i.__e, u.__k = i.__k, v.__h.length && f.push(v), a = 0; a < u.__k.length; a++) {
            u.__k[a] && (u.__k[a].__ = u);
          }
          break n;
        }
        null != v.componentWillUpdate && v.componentWillUpdate(g, v.__s, x), null != v.componentDidUpdate && v.__h.push(function () {
          v.componentDidUpdate(y, p, w);
        });
      }
      v.context = x, v.props = g, v.state = v.__s, (a = n.__r) && a(u), v.__d = !1, v.__v = u, v.__P = l, a = v.render(v.props, v.state, v.context), null != v.getChildContext && (t = s(s({}, t), v.getChildContext())), h || null == v.getSnapshotBeforeUpdate || (w = v.getSnapshotBeforeUpdate(y, p)), A = null != a && a.type == d && null == a.key ? a.props.children : a, b(l, Array.isArray(A) ? A : [A], u, i, t, o, r, f, e, c), v.base = u.__e, v.__h.length && f.push(v), k && (v.__E = v.__ = null), v.__e = !1;
    } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = $(i.__e, u, i, t, o, r, f, c);
    (a = n.diffed) && a(u);
  } catch (l) {
    u.__v = null, n.__e(l, u, i);
  }
  return u.__e;
}
function T(l, u) {
  n.__c && n.__c(u, l), l.some(function (u) {
    try {
      l = u.__h, u.__h = [], l.some(function (n) {
        n.call(u);
      });
    } catch (l) {
      n.__e(l, u.__v);
    }
  });
}
function $(n, l, u, i, t, o, r, f) {
  var a,
      s,
      v,
      h,
      y,
      p = u.props,
      d = l.props;
  if (t = "svg" === l.type || t, null != o) for (a = 0; a < o.length; a++) {
    if (null != (s = o[a]) && ((null === l.type ? 3 === s.nodeType : s.localName === l.type) || n == s)) {
      n = s, o[a] = null;
      break;
    }
  }
  if (null == n) {
    if (null === l.type) return document.createTextNode(d);
    n = t ? document.createElementNS("http://www.w3.org/2000/svg", l.type) : document.createElement(l.type, d.is && {
      is: d.is
    }), o = null, f = !1;
  }
  if (null === l.type) p !== d && n.data != d && (n.data = d);else {
    if (null != o && (o = c.slice.call(n.childNodes)), v = (p = u.props || e).dangerouslySetInnerHTML, h = d.dangerouslySetInnerHTML, !f) {
      if (null != o) for (p = {}, y = 0; y < n.attributes.length; y++) {
        p[n.attributes[y].name] = n.attributes[y].value;
      }
      (h || v) && (h && v && h.__html == v.__html || (n.innerHTML = h && h.__html || ""));
    }
    A(n, d, p, t, f), h ? l.__k = [] : (a = l.props.children, b(n, Array.isArray(a) ? a : [a], l, u, i, "foreignObject" !== l.type && t, o, r, e, f)), f || ("value" in d && void 0 !== (a = d.value) && a !== n.value && C(n, "value", a, p.value, !1), "checked" in d && void 0 !== (a = d.checked) && a !== n.checked && C(n, "checked", a, p.checked, !1));
  }
  return n;
}
function j(l, u, i) {
  try {
    "function" == typeof l ? l(u) : l.current = u;
  } catch (l) {
    n.__e(l, i);
  }
}
function D(l, u, i) {
  var t, o, r;
  if (n.unmount && n.unmount(l), (t = l.ref) && (t.current && t.current !== l.__e || j(t, null, u)), i || "function" == typeof l.type || (i = null != (o = l.__e)), l.__e = l.__d = void 0, null != (t = l.__c)) {
    if (t.componentWillUnmount) try {
      t.componentWillUnmount();
    } catch (l) {
      n.__e(l, u);
    }
    t.base = t.__P = null;
  }
  if (t = l.__k) for (r = 0; r < t.length; r++) {
    t[r] && D(t[r], u, i);
  }
  null != o && v(o);
}
function E(n, l, u) {
  return this.constructor(n, u);
}
function H(l, u, i) {
  var t, o, f;
  n.__ && n.__(l, u), o = (t = i === r) ? null : i && i.__k || u.__k, l = h(d, null, [l]), f = [], z(u, (t ? u : i || u).__k = l, o || e, e, void 0 !== u.ownerSVGElement, i && !t ? [i] : o ? null : u.childNodes.length ? c.slice.call(u.childNodes) : null, f, i || e, t), T(f, l);
}
function I(n, l) {
  H(n, l, r);
}
function L(n, l) {
  var u, i;
  for (i in l = s(s({}, n.props), l), arguments.length > 2 && (l.children = c.slice.call(arguments, 2)), u = {}, l) {
    "key" !== i && "ref" !== i && (u[i] = l[i]);
  }
  return y(n.type, u, l.key || n.key, l.ref || n.ref, null);
}
function M(n) {
  var l = {},
      u = {
    __c: "__cC" + f++,
    __: n,
    Consumer: function Consumer(n, l) {
      return n.children(l);
    },
    Provider: function Provider(n) {
      var i,
          t = this;
      return this.getChildContext || (i = [], this.getChildContext = function () {
        return l[u.__c] = t, l;
      }, this.shouldComponentUpdate = function (n) {
        t.props.value !== n.value && i.some(function (l) {
          l.context = n.value, g(l);
        });
      }, this.sub = function (n) {
        i.push(n);
        var l = n.componentWillUnmount;
        n.componentWillUnmount = function () {
          i.splice(i.indexOf(n), 1), l && l.call(n);
        };
      }), n.children;
    }
  };
  return u.Consumer.contextType = u, u.Provider.__ = u, u;
}
n = {
  __e: function __e(n, l) {
    for (var u, i; l = l.__;) {
      if ((u = l.__c) && !u.__) try {
        if (u.constructor && null != u.constructor.getDerivedStateFromError && (i = !0, u.setState(u.constructor.getDerivedStateFromError(n))), null != u.componentDidCatch && (i = !0, u.componentDidCatch(n)), i) return g(u.__E = u);
      } catch (l) {
        n = l;
      }
    }
    throw n;
  }
}, m.prototype.setState = function (n, l) {
  var u;
  u = this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n && (n = n(u, this.props)), n && s(u, n), null != n && this.__v && (l && this.__h.push(l), g(this));
}, m.prototype.forceUpdate = function (n) {
  this.__v && (this.__e = !0, n && this.__h.push(n), g(this));
}, m.prototype.render = d, u = [], i = 0, t = "function" == typeof Promise ? Promise.prototype.then.bind( Promise.resolve()) : setTimeout, r = e, f = 0;

var t$1,
    u$1,
    r$1,
    i$1 = 0,
    o$1 = [],
    c$1 = n.__r,
    f$1 = n.diffed,
    e$1 = n.__c,
    a$1 = n.unmount;
function v$1(t, r) {
  n.__h && n.__h(u$1, t, i$1 || r), i$1 = 0;
  var o = u$1.__H || (u$1.__H = {
    __: [],
    __h: []
  });
  return t >= o.__.length && o.__.push({}), o.__[t];
}
function m$1(n) {
  return i$1 = 1, p$1(E$1, n);
}
function p$1(n, r, i) {
  var o = v$1(t$1++, 2);
  return o.t = n, o.__c || (o.__c = u$1, o.__ = [i ? i(r) : E$1(void 0, r), function (n) {
    var t = o.t(o.__[0], n);
    o.__[0] !== t && (o.__[0] = t, o.__c.setState({}));
  }]), o.__;
}
function l(r, i) {
  var o = v$1(t$1++, 3);
  !n.__s && x$1(o.__H, i) && (o.__ = r, o.__H = i, u$1.__H.__h.push(o));
}
function y$1(r, i) {
  var o = v$1(t$1++, 4);
  !n.__s && x$1(o.__H, i) && (o.__ = r, o.__H = i, u$1.__h.push(o));
}
function d$1(n) {
  return i$1 = 5, h$1(function () {
    return {
      current: n
    };
  }, []);
}
function s$1(n, t, u) {
  i$1 = 6, y$1(function () {
    "function" == typeof n ? n(t()) : n && (n.current = t());
  }, null == u ? u : u.concat(n));
}
function h$1(n, u) {
  var r = v$1(t$1++, 7);
  return x$1(r.__H, u) ? (r.__H = u, r.__h = n, r.__ = n()) : r.__;
}
function T$1(n, t) {
  return i$1 = 8, h$1(function () {
    return n;
  }, t);
}
function w$1(n) {
  var r = u$1.context[n.__c],
      i = v$1(t$1++, 9);
  return i.__c = n, r ? (null == i.__ && (i.__ = !0, r.sub(u$1)), r.props.value) : n.__;
}
function A$1(t, u) {
  n.useDebugValue && n.useDebugValue(u ? u(t) : t);
}
function _$1() {
  o$1.some(function (t) {
    if (t.__P) try {
      t.__H.__h.forEach(g$1), t.__H.__h.forEach(q), t.__H.__h = [];
    } catch (u) {
      return t.__H.__h = [], n.__e(u, t.__v), !0;
    }
  }), o$1 = [];
}
function g$1(n) {
  "function" == typeof n.u && n.u();
}
function q(n) {
  n.u = n.__();
}
function x$1(n, t) {
  return !n || t.some(function (t, u) {
    return t !== n[u];
  });
}
function E$1(n, t) {
  return "function" == typeof t ? t(n) : t;
}
n.__r = function (n) {
  c$1 && c$1(n), t$1 = 0;
  var r = (u$1 = n.__c).__H;
  r && (r.__h.forEach(g$1), r.__h.forEach(q), r.__h = []);
}, n.diffed = function (t) {
  f$1 && f$1(t);
  var u = t.__c;
  u && u.__H && u.__H.__h.length && (1 !== o$1.push(u) && r$1 === n.requestAnimationFrame || ((r$1 = n.requestAnimationFrame) || function (n) {
    var t,
        u = function u() {
      clearTimeout(r), cancelAnimationFrame(t), setTimeout(n);
    },
        r = setTimeout(u, 100);
    "undefined" != typeof window && (t = requestAnimationFrame(u));
  })(_$1));
}, n.__c = function (t, u) {
  u.some(function (t) {
    try {
      t.__h.forEach(g$1), t.__h = t.__h.filter(function (n) {
        return !n.__ || q(n);
      });
    } catch (r) {
      u.some(function (n) {
        n.__h && (n.__h = []);
      }), u = [], n.__e(r, t.__v);
    }
  }), e$1 && e$1(t, u);
}, n.unmount = function (t) {
  a$1 && a$1(t);
  var u = t.__c;
  if (u && u.__H) try {
    u.__H.__.forEach(g$1);
  } catch (t) {
    n.__e(t, u.__v);
  }
};

function w$2(n, t) {
  for (var e in t) {
    n[e] = t[e];
  }
  return n;
}
function x$2(n, t) {
  for (var e in n) {
    if ("__source" !== e && !(e in t)) return !0;
  }
  for (var r in t) {
    if ("__source" !== r && n[r] !== t[r]) return !0;
  }
  return !1;
}
var E$2 = function (n) {
  var t, e;
  function r(t) {
    var e;
    return (e = n.call(this, t) || this).isPureReactComponent = !0, e;
  }
  return e = n, (t = r).prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e, r.prototype.shouldComponentUpdate = function (n, t) {
    return x$2(this.props, n) || x$2(this.state, t);
  }, r;
}(m);
function C$1(n, t) {
  function e(n) {
    var e = this.props.ref,
        r = e == n.ref;
    return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : x$2(this.props, n);
  }
  function r(t) {
    return this.shouldComponentUpdate = e, h(n, t);
  }
  return r.prototype.isReactComponent = !0, r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.t = !0, r;
}
var _$2 = n.__b;
n.__b = function (n) {
  n.type && n.type.t && n.ref && (n.props.ref = n.ref, n.ref = null), _$2 && _$2(n);
};
var A$2 = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.forward_ref") || 3911;
function k$1(n) {
  function t(t, e) {
    var r = w$2({}, t);
    return delete r.ref, n(r, t.ref || e);
  }
  return t.$$typeof = A$2, t.render = t, t.prototype.isReactComponent = t.t = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
}
var R = function R(n, t) {
  return n ? x(n).reduce(function (n, e, r) {
    return n.concat(t(e, r));
  }, []) : null;
},
    F = {
  map: R,
  forEach: R,
  count: function count(n) {
    return n ? x(n).length : 0;
  },
  only: function only(n) {
    if (1 !== (n = x(n)).length) throw new Error("Children.only() expects only one child.");
    return n[0];
  },
  toArray: x
},
    N$1 = n.__e;
function U(n) {
  return n && ((n = w$2({}, n)).__c = null, n.__k = n.__k && n.__k.map(U)), n;
}
function M$1() {
  this.__u = 0, this.o = null, this.__b = null;
}
function L$1(n) {
  var t = n.__.__c;
  return t && t.u && t.u(n);
}
function O(n) {
  var t, e, r;
  function o(o) {
    if (t || (t = n()).then(function (n) {
      e = n["default"] || n;
    }, function (n) {
      r = n;
    }), r) throw r;
    if (!e) throw t;
    return h(e, o);
  }
  return o.displayName = "Lazy", o.t = !0, o;
}
function P$1() {
  this.i = null, this.l = null;
}
n.__e = function (n, t, e) {
  if (n.then) for (var r, o = t; o = o.__;) {
    if ((r = o.__c) && r.__c) return r.__c(n, t.__c);
  }
  N$1(n, t, e);
}, (M$1.prototype = new m()).__c = function (n, t) {
  var e = this;
  null == e.o && (e.o = []), e.o.push(t);
  var r = L$1(e.__v),
      o = !1,
      u = function u() {
    o || (o = !0, r ? r(i) : i());
  };
  t.__c = t.componentWillUnmount, t.componentWillUnmount = function () {
    u(), t.__c && t.__c();
  };
  var i = function i() {
    var n;
    if (! --e.__u) for (e.__v.__k[0] = e.state.u, e.setState({
      u: e.__b = null
    }); n = e.o.pop();) {
      n.forceUpdate();
    }
  };
  e.__u++ || e.setState({
    u: e.__b = e.__v.__k[0]
  }), n.then(u, u);
}, M$1.prototype.render = function (n, t) {
  return this.__b && (this.__v.__k[0] = U(this.__b), this.__b = null), [h(m, null, t.u ? null : n.children), t.u && n.fallback];
};
var W = function W(n, t, e) {
  if (++e[1] === e[0] && n.l["delete"](t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.l.size)) for (e = n.i; e;) {
    for (; e.length > 3;) {
      e.pop()();
    }
    if (e[1] < e[0]) break;
    n.i = e = e[2];
  }
};
(P$1.prototype = new m()).u = function (n) {
  var t = this,
      e = L$1(t.__v),
      r = t.l.get(n);
  return r[0]++, function (o) {
    var u = function u() {
      t.props.revealOrder ? (r.push(o), W(t, n, r)) : o();
    };
    e ? e(u) : u();
  };
}, P$1.prototype.render = function (n) {
  this.i = null, this.l = new Map();
  var t = x(n.children);
  n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
  for (var e = t.length; e--;) {
    this.l.set(t[e], this.i = [1, 0, this.i]);
  }
  return n.children;
}, P$1.prototype.componentDidUpdate = P$1.prototype.componentDidMount = function () {
  var n = this;
  n.l.forEach(function (t, e) {
    W(n, e, t);
  });
};
var j$1 = function () {
  function n() {}
  var t = n.prototype;
  return t.getChildContext = function () {
    return this.props.context;
  }, t.render = function (n) {
    return n.children;
  }, n;
}();
function z$1(n) {
  var t = this,
      e = n.container,
      r = h(j$1, {
    context: t.context
  }, n.vnode);
  return t.s && t.s !== e && (t.v.parentNode && t.s.removeChild(t.v), D(t.h), t.p = !1), n.vnode ? t.p ? (e.__k = t.__k, H(r, e), t.__k = e.__k) : (t.v = document.createTextNode(""), I("", e), e.appendChild(t.v), t.p = !0, t.s = e, H(r, e, t.v), t.__k = t.v.__k) : t.p && (t.v.parentNode && t.s.removeChild(t.v), D(t.h)), t.h = r, t.componentWillUnmount = function () {
    t.v.parentNode && t.s.removeChild(t.v), D(t.h);
  }, null;
}
function D$1(n, t) {
  return h(z$1, {
    vnode: n,
    container: t
  });
}
var H$1 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
m.prototype.isReactComponent = {};
var T$2 = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103;
function V(n, t, e) {
  if (null == t.__k) for (; t.firstChild;) {
    t.removeChild(t.firstChild);
  }
  return H(n, t), "function" == typeof e && e(), n ? n.__c : null;
}
function Z(n, t, e) {
  return I(n, t), "function" == typeof e && e(), n ? n.__c : null;
}
var I$1 = n.event;
function $$1(n, t) {
  n["UNSAFE_" + t] && !n[t] && Object.defineProperty(n, t, {
    configurable: !1,
    get: function get() {
      return this["UNSAFE_" + t];
    },
    set: function set(n) {
      this["UNSAFE_" + t] = n;
    }
  });
}
n.event = function (n) {
  I$1 && (n = I$1(n)), n.persist = function () {};
  var t = !1,
      e = !1,
      r = n.stopPropagation;
  n.stopPropagation = function () {
    r.call(n), t = !0;
  };
  var o = n.preventDefault;
  return n.preventDefault = function () {
    o.call(n), e = !0;
  }, n.isPropagationStopped = function () {
    return t;
  }, n.isDefaultPrevented = function () {
    return e;
  }, n.nativeEvent = n;
};
var q$1 = {
  configurable: !0,
  get: function get() {
    return this["class"];
  }
},
    B = n.vnode;
n.vnode = function (n) {
  n.$$typeof = T$2;
  var t = n.type,
      e = n.props;
  if (t) {
    if (e["class"] != e.className && (q$1.enumerable = "className" in e, null != e.className && (e["class"] = e.className), Object.defineProperty(e, "className", q$1)), "function" != typeof t) {
      var r, o, u;
      for (u in e.defaultValue && void 0 !== e.value && (e.value || 0 === e.value || (e.value = e.defaultValue), delete e.defaultValue), Array.isArray(e.value) && e.multiple && "select" === t && (x(e.children).forEach(function (n) {
        -1 != e.value.indexOf(n.props.value) && (n.props.selected = !0);
      }), delete e.value), e) {
        if (r = H$1.test(u)) break;
      }
      if (r) for (u in o = n.props = {}, e) {
        o[H$1.test(u) ? u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u] = e[u];
      }
    }
    !function (t) {
      var e = n.type,
          r = n.props;
      if (r && "string" == typeof e) {
        var o = {};
        for (var u in r) {
          /^on(Ani|Tra|Tou)/.test(u) && (r[u.toLowerCase()] = r[u], delete r[u]), o[u.toLowerCase()] = u;
        }
        if (o.ondoubleclick && (r.ondblclick = r[o.ondoubleclick], delete r[o.ondoubleclick]), o.onbeforeinput && (r.onbeforeinput = r[o.onbeforeinput], delete r[o.onbeforeinput]), o.onchange && ("textarea" === e || "input" === e.toLowerCase() && !/^fil|che|ra/i.test(r.type))) {
          var i = o.oninput || "oninput";
          r[i] || (r[i] = r[o.onchange], delete r[o.onchange]);
        }
      }
    }(), "function" == typeof t && !t.m && t.prototype && ($$1(t.prototype, "componentWillMount"), $$1(t.prototype, "componentWillReceiveProps"), $$1(t.prototype, "componentWillUpdate"), t.m = !0);
  }
  B && B(n);
};
function J(n) {
  return h.bind(null, n);
}
function K(n) {
  return !!n && n.$$typeof === T$2;
}
function Q(n) {
  return K(n) ? L.apply(null, arguments) : n;
}
function X(n) {
  return !!n.__k && (H(null, n), !0);
}
function Y(n) {
  return n && (n.base || 1 === n.nodeType && n) || null;
}
var nn = function nn(n, t) {
  return n(t);
};
var React = {
  useState: m$1,
  useReducer: p$1,
  useEffect: l,
  useLayoutEffect: y$1,
  useRef: d$1,
  useImperativeHandle: s$1,
  useMemo: h$1,
  useCallback: T$1,
  useContext: w$1,
  useDebugValue: A$1,
  version: "16.8.0",
  Children: F,
  render: V,
  hydrate: Z,
  unmountComponentAtNode: X,
  createPortal: D$1,
  createElement: h,
  createContext: M,
  createFactory: J,
  cloneElement: Q,
  createRef: p,
  Fragment: d,
  isValidElement: K,
  findDOMNode: Y,
  Component: m,
  PureComponent: E$2,
  memo: C$1,
  forwardRef: k$1,
  unstable_batchedUpdates: nn,
  StrictMode: d,
  Suspense: M$1,
  SuspenseList: P$1,
  lazy: O
};

function len(a) {
  return a instanceof Set ? a.size : a.length;
}
function setOverlapFactory(a, toElemKey) {
  var elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));
  var setA = elems.size;
  var same = {
    setA: setA,
    setB: setA,
    union: setA,
    intersection: setA
  };
  return function (b) {
    if (b === a) {
      return same;
    }
    var intersection = 0;
    b.forEach(function (e) {
      if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {
        intersection++;
      }
    });
    var setB = len(b);
    return {
      setA: setA,
      setB: setB,
      intersection: intersection,
      union: setA + setB - intersection
    };
  };
}
function setOverlap(a, b, toElemKey) {
  if (len(a) < len(b) || a instanceof Set) {
    return setOverlapFactory(a, toElemKey)(b);
  }
  var r = setOverlapFactory(b, toElemKey)(a);
  return Object.assign({}, r, {
    setA: r.setB,
    setB: r.setA
  });
}
function setElemOverlapFactory(a, toElemKey) {
  var elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));
  var setA = Array.isArray(a) ? a : Array.from(a);
  var same = {
    setA: setA,
    setB: setA,
    union: setA,
    intersection: setA
  };
  return function (b) {
    if (b === a) {
      return same;
    }
    var intersection = [];
    var union = setA.slice();
    b.forEach(function (e) {
      if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {
        intersection.push(e);
      } else {
        union.push(e);
      }
    });
    return {
      setA: setA,
      setB: Array.isArray(b) ? b : Array.from(b),
      intersection: intersection,
      union: union
    };
  };
}
function setElemOverlap(a, b, toElemKey) {
  if (len(a) < len(b) || a instanceof Set) {
    return setElemOverlapFactory(a, toElemKey)(b);
  }
  var r = setElemOverlapFactory(b, toElemKey)(a);
  return Object.assign({}, r, {
    setA: r.setB,
    setB: r.setA
  });
}
function setElemIntersectionFactory(a, toElemKey) {
  var arr = a instanceof Set ? Array.from(a) : a;
  var elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set(arr.map(toElemKey));
  return function (b) {
    if (b === a) {
      return arr;
    }
    var intersection = [];
    b.forEach(function (e) {
      if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {
        intersection.push(e);
      }
    });
    return intersection;
  };
}
function isElemQuery(q) {
  return Array.isArray(q.elems);
}
function isCalcQuery(q) {
  return typeof q.overlap === 'function';
}
function isSetQuery(q) {
  return q.set != null;
}
function queryOverlap(query, what, toElemKey) {
  if (isCalcQuery(query)) {
    return query.overlap;
  }
  if (isSetQuery(query) && query.set.overlap) {
    return query.set.overlap;
  }
  var f = setOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
  return function (s) {
    if (s.overlap && isElemQuery(query) && Array.isArray(query.elems)) {
      return s.overlap(query.elems);
    }
    if (s.overlap && isSetQuery(query)) {
      return s.overlap(query.set);
    }
    return f(s.elems)[what];
  };
}
function queryElemOverlap(query, what, toElemKey) {
  if (isCalcQuery(query)) {
    return function () {
      return null;
    };
  }
  if (what === 'intersection') {
    var _f = setElemIntersectionFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
    return function (s) {
      return _f(s.elems);
    };
  }
  var f = setElemOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
  return function (s) {
    return f(s.elems)[what];
  };
}
function isBaseSet(v) {
  var vt = v;
  return v != null && typeof vt.cardinality === 'number' && typeof v.name === 'string' && Array.isArray(v.elems);
}
function isSet(v) {
  return isBaseSet(v) && v.type === 'set';
}
function isSetCombination(v) {
  var vt = v;
  return isBaseSet(v) && ['composite', 'union', 'intersection', 'distinctIntersection'].includes(vt.type) && vt.sets instanceof Set && typeof vt.degree === 'number';
}
function isSetLike(v) {
  return isSet(v) || isSetCombination(v);
}
function isGenerateSetCombinationOptions(v) {
  var vt = v;
  return v != null && (vt.type == null || ['intersection', 'union'].includes(vt.type));
}
function isUpSetQuery(v) {
  var vt = v;
  return v != null && typeof vt.name === 'string' && typeof vt.color === 'string' && (isElemQuery(vt) || isSetQuery(vt) || isCalcQuery(vt));
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
function byName(a, b) {
  return a.name.localeCompare(b.name);
}
function byCardinality(a, b) {
  return b.cardinality - a.cardinality;
}
function byDegree(a, b) {
  return a.degree - b.degree;
}
function byComposite(func) {
  return function (a, b) {
    return func.reduce(function (acc, f) {
      return acc === 0 ? f(a, b) : acc;
    }, 0);
  };
}
function negate(func) {
  return function (a, b) {
    return -func(a, b);
  };
}
function byGroup(sets) {
  return function (a, b) {
    var fixNotFound = function fixNotFound(v) {
      return v < 0 ? Number.POSITIVE_INFINITY : v;
    };
    var aIndex = fixNotFound(sets.findIndex(function (s) {
      return a.sets.has(s);
    }));
    var bIndex = fixNotFound(sets.findIndex(function (s) {
      return b.sets.has(s);
    }));
    return aIndex - bIndex;
  };
}
function fromSetName(sets, symbol) {
  if (symbol === void 0) {
    symbol = /[∩∪&|]/;
  }
  var byName = new Map(sets.map(function (s) {
    return [s.name, s];
  }));
  return function (s) {
    return s.name.split(symbol).map(function (setName) {
      return byName.get(setName.trim());
    });
  };
}
function toOrder(sets, order) {
  if (!order) {
    return byName;
  }
  var arr = Array.isArray(order) ? order : [order];
  if (arr.length === 0) {
    return byName;
  }
  return byComposite(arr.map(function (o) {
    switch (o) {
      case 'cardinality':
      case 'cardinality:desc':
        return byCardinality;
      case 'cardinality:asc':
        return negate(byCardinality);
      case 'name:desc':
        return negate(byName);
      case 'degree':
      case 'degree:asc':
        return byDegree;
      case 'degree:desc':
        return negate(byDegree);
      case 'group':
      case 'group:asc':
        return byGroup(sets);
      case 'group:desc':
        return negate(byGroup(sets));
      default:
        return byName;
    }
  }));
}
function postprocessCombinations(sets, combinations, options) {
  if (options === void 0) {
    options = {};
  }
  var r = combinations;
  if (options.order) {
    r = r.sort(toOrder(sets, options.order));
  }
  if (options.limit != null) {
    return r.slice(0, options.limit);
  }
  return r;
}
function asCombination(set, type, toSets) {
  var sets = toSets(set);
  return Object.assign({
    type: type,
    cardinality: set.elems.length,
    sets: new Set(sets),
    degree: sets.length
  }, set);
}
function asCombinations(sets, type, toSets) {
  return sets.map(function (set) {
    return asCombination(set, type, toSets);
  });
}
var SET_JOINERS = {
  distinctIntersection: ' ∩ ',
  intersection: ' ∩ ',
  union: ' ∪ ',
  composite: ','
};
function parseColor(color) {
  if (!color) {
    return [255, 255, 255];
  }
  var hex = color.match(/#([\da-f]{2})([\da-f]{2})([\da-f]{2})/i);
  if (hex) {
    return [Number.parseInt(hex[1], 16), Number.parseInt(hex[2], 16), Number.parseInt(hex[3], 16)];
  }
  var rgb = color.match(/\(([\d]+)[, ]([\d]+)[, ]([\d]+)\)/i);
  if (rgb) {
    return [Number.parseInt(rgb[1], 10), Number.parseInt(rgb[2], 10), Number.parseInt(rgb[3], 10)];
  }
  return [255, 255, 255];
}
function mergeColors(colors) {
  if (colors.length === 1) {
    return colors[0];
  }
  if (colors.every(function (d) {
    return d == null;
  })) {
    return undefined;
  }
  var rgb = colors.map(parseColor);
  var r = Math.floor(rgb.reduce(function (acc, v) {
    return acc + v[0];
  }, 0) / rgb.length);
  var g = Math.floor(rgb.reduce(function (acc, v) {
    return acc + v[1];
  }, 0) / rgb.length);
  var b = Math.floor(rgb.reduce(function (acc, v) {
    return acc + v[2];
  }, 0) / rgb.length);
  return "#" + r.toString(16) + g.toString(16) + b.toString(16);
}
function generateName(combo, setIndex, joiner) {
  var sorted = Array.from(combo).sort(function (a, b) {
    return setIndex.get(a) - setIndex.get(b);
  });
  return sorted.length === 1 ? sorted[0].name : "(" + sorted.map(function (d) {
    return d.name;
  }).join(joiner) + ")";
}
function generateSet(type, name, combo, elems, mergeColors) {
  return {
    type: combo.size === 0 ? 'composite' : type,
    elems: elems,
    color: mergeColors(Array.from(combo).map(function (s) {
      return s.color;
    })),
    sets: combo,
    name: name,
    cardinality: elems.length,
    degree: combo.size
  };
}
function mergeIntersection(a, b, lookup, toKey, setIndex, type, mergeColors) {
  var merged = new Set(a.sets);
  b.sets.forEach(function (s) {
    return merged.add(s);
  });
  var name = generateName(merged, setIndex, SET_JOINERS[type]);
  if (a.cardinality === 0 || b.cardinality === 0) {
    return generateSet(type, name, merged, [], mergeColors);
  }
  var small = a;
  var big = b;
  if (a.cardinality > b.cardinality) {
    small = b;
    big = a;
  }
  var keySet = new Set();
  var bigLookup = lookup.get(big);
  var elems = [];
  var l = small.elems.length;
  for (var i = 0; i < l; i++) {
    var e = small.elems[i];
    var key = toKey(e);
    if (!bigLookup.has(key)) {
      continue;
    }
    keySet.add(key);
    elems.push(e);
  }
  var r = generateSet(type, name, merged, elems, mergeColors);
  lookup.set(r, keySet);
  return r;
}
function mergeUnion(a, b, lookup, toKey, setIndex, type, mergeColors) {
  var merged = new Set(a.sets);
  b.sets.forEach(function (s) {
    return merged.add(s);
  });
  var name = generateName(merged, setIndex, SET_JOINERS[type]);
  if (a.cardinality === 0) {
    var _r = generateSet(type, name, merged, b.elems, mergeColors);
    lookup.set(_r, lookup.get(b));
    return _r;
  }
  if (b.cardinality === 0) {
    var _r2 = generateSet(type, name, merged, a.elems, mergeColors);
    lookup.set(_r2, lookup.get(a));
    return _r2;
  }
  var small = a;
  var big = b;
  if (a.cardinality > b.cardinality) {
    small = b;
    big = a;
  }
  var keySet = new Set(lookup.get(big));
  var bigLookup = lookup.get(big);
  var elems = big.elems.slice();
  small.elems.forEach(function (e) {
    var key = toKey(e);
    if (bigLookup.has(key)) {
      return;
    }
    keySet.add(key);
    elems.push(e);
  });
  var r = generateSet(type, name, merged, elems, mergeColors);
  lookup.set(r, keySet);
  return r;
}
function generateEmptySet(type, notPartOfAnySet, allElements, lookup, toKey, mergeColors) {
  if (typeof notPartOfAnySet === 'number') {
    return {
      type: 'composite',
      elems: [],
      color: mergeColors ? mergeColors([]) : undefined,
      sets: new Set(),
      name: '()',
      cardinality: notPartOfAnySet,
      overlap: function overlap(s) {
        return s === this || isSetLike(s) && s.name === this.name && s.cardinality === this.cardinality ? this.cardinality : 0;
      },
      degree: 0
    };
  }
  if (Array.isArray(notPartOfAnySet)) {
    return generateSet(type, '()', new Set(), notPartOfAnySet, mergeColors);
  }
  var lookupArr = Array.from(lookup.values());
  var elems = allElements.filter(function (e) {
    var k = toKey(e);
    return lookupArr.every(function (s) {
      return !s.has(k);
    });
  });
  return generateSet(type, '()', new Set(), elems, mergeColors);
}
function generateCombinations(sets, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'intersection' : _ref$type,
      _ref$min = _ref.min,
      min = _ref$min === void 0 ? 0 : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? Infinity : _ref$max,
      _ref$empty = _ref.empty,
      empty = _ref$empty === void 0 ? false : _ref$empty,
      _ref$elems = _ref.elems,
      allElements = _ref$elems === void 0 ? [] : _ref$elems,
      notPartOfAnySet = _ref.notPartOfAnySet,
      toElemKey = _ref.toElemKey,
      _ref$mergeColors = _ref.mergeColors,
      mergeColors$1 = _ref$mergeColors === void 0 ? mergeColors : _ref$mergeColors,
      postprocess = _objectWithoutPropertiesLoose(_ref, ["type", "min", "max", "empty", "elems", "notPartOfAnySet", "toElemKey", "mergeColors"]);
  var combinations = [];
  var setIndex = new Map(sets.map(function (s, i) {
    return [s, i];
  }));
  var setElems = new Map(sets.map(function (s) {
    return [s, toElemKey ? new Set(s.elems.map(toElemKey)) : new Set(s.elems)];
  }));
  var setDirectElems = toElemKey ? null : setElems;
  var setKeyElems = toElemKey ? setElems : null;
  var calc = type === 'union' ? mergeUnion : mergeIntersection;
  function push(s) {
    if (s.degree < min || s.degree > max || s.cardinality === 0 && !empty) {
      return;
    }
    if (type !== 'distinctIntersection') {
      combinations.push(s);
      return;
    }
    var others = sets.filter(function (d) {
      return !s.sets.has(d);
    });
    var elems = toElemKey ? s.elems.filter(function (e) {
      var key = toElemKey(e);
      return others.every(function (o) {
        return !setKeyElems.get(o).has(key);
      });
    }) : s.elems.filter(function (e) {
      return others.every(function (o) {
        return !setDirectElems.get(o).has(e);
      });
    });
    if (elems.length === s.cardinality) {
      combinations.push(s);
      return;
    }
    var sDistinct = generateSet(type, s.name, s.sets, elems, mergeColors$1);
    if (sDistinct.cardinality === 0 && !empty) {
      return;
    }
    combinations.push(sDistinct);
  }
  function generateLevel(arr, degree, lookup, toKey) {
    if (degree > max) {
      return;
    }
    var l = arr.length;
    for (var i = 0; i < l; i++) {
      var a = arr[i];
      var sub = [];
      for (var j = i + 1; j < l; j++) {
        var b = arr[j];
        var ab = calc(a, b, lookup, toKey, setIndex, type, mergeColors$1);
        push(ab);
        if (type === 'union' || ab.cardinality > 0 || empty) {
          sub.push(ab);
        }
      }
      if (sub.length > 1) {
        generateLevel(sub, degree + 1, lookup, toKey);
      }
    }
  }
  if (min <= 0) {
    if (toElemKey) {
      push(generateEmptySet(type, notPartOfAnySet, allElements, setKeyElems, toElemKey, mergeColors$1));
    } else {
      push(generateEmptySet(type, notPartOfAnySet, allElements, setDirectElems, function (v) {
        return v;
      }, mergeColors$1));
    }
  }
  var degree1 = sets.map(function (s) {
    var r = generateSet(type, s.name, new Set([s]), s.elems, mergeColors$1);
    setElems.set(r, setElems.get(s));
    push(r);
    return r;
  });
  if (toElemKey) {
    generateLevel(degree1, 2, setKeyElems, toElemKey);
  } else {
    generateLevel(degree1, 2, setDirectElems, function (v) {
      return v;
    });
  }
  return postprocessCombinations(sets, combinations, postprocess);
}
function asSet(set) {
  return Object.assign({
    type: 'set',
    cardinality: set.elems.length
  }, set);
}
function toOrder$1(order) {
  if (!order) {
    return byName;
  }
  switch (order) {
    case 'cardinality':
    case 'cardinality:desc':
      return byComposite([byCardinality, byName]);
    case 'cardinality:asc':
      return byComposite([negate(byCardinality), byName]);
    case 'name:desc':
      return negate(byName);
    default:
      return byName;
  }
}
function postprocessSets(sets, options) {
  if (options === void 0) {
    options = {};
  }
  var r = sets;
  if (options.order) {
    var order = toOrder$1(options.order);
    r = r.slice().sort(order);
  }
  if (options.limit != null) {
    return r.slice(0, options.limit);
  }
  return r;
}
function asSets(sets, options) {
  if (options === void 0) {
    options = {};
  }
  return postprocessSets(sets.map(asSet), options);
}
function toKey(s) {
  return s.name + ":" + s.type + "#" + s.cardinality;
}
function isUniverse(s) {
  return s.sets.size === 0;
}
function common(a, b, toKey$1) {
  if (toKey$1 === void 0) {
    toKey$1 = toKey;
  }
  var r = {
    done: null,
    aKey: '',
    bKey: '',
    aIsSet: false,
    bIsSet: false,
    toKey: toKey$1
  };
  if (a === b) {
    r.done = a.cardinality;
    return r;
  }
  if (a.cardinality === 0 || b.cardinality === 0) {
    r.done = 0;
    return r;
  }
  r.aKey = toKey$1(a);
  r.bKey = toKey$1(b);
  if (r.aKey === r.bKey) {
    r.done = a.cardinality;
    return r;
  }
  r.aIsSet = isSet(a);
  r.bIsSet = isSet(b);
  if (!r.aIsSet && isUniverse(a) || !r.bIsSet && isUniverse(b)) {
    r.done = 0;
    return r;
  }
  return r;
}
function aInB(b, r) {
  if (r.bIsSet || !r.aIsSet) {
    return false;
  }
  return Array.from(b.sets).map(r.toKey).includes(r.aKey);
}
function bInA(a, r) {
  if (!r.bIsSet || r.aIsSet) {
    return false;
  }
  return Array.from(a.sets).map(r.toKey).includes(r.bKey);
}
function keyedCombinations(combinations, toKey$1) {
  if (toKey$1 === void 0) {
    toKey$1 = toKey;
  }
  return combinations.map(function (c) {
    var s = Array.from(c.sets).map(toKey$1).sort();
    return {
      key: s.join('&'),
      s: s,
      sets: new Set(s),
      degree: c.degree,
      cardinality: c.cardinality
    };
  });
}
function combinedKey(a, b, r) {
  var sets = new Set();
  if (r.aIsSet) {
    sets.add(r.aKey);
  } else {
    for (var _i = 0, _Array$from = Array.from(a.sets); _i < _Array$from.length; _i++) {
      var s = _Array$from[_i];
      sets.add(r.toKey(s));
    }
  }
  if (r.bIsSet) {
    sets.add(r.bKey);
  } else {
    for (var _i2 = 0, _Array$from2 = Array.from(b.sets); _i2 < _Array$from2.length; _i2++) {
      var _s = _Array$from2[_i2];
      sets.add(r.toKey(_s));
    }
  }
  return Array.from(sets).sort().join('&');
}
function generateDistinctOverlapFunction(combinations, toKey$1) {
  if (toKey$1 === void 0) {
    toKey$1 = toKey;
  }
  var combinationsBySet = new Map();
  for (var _iterator = _createForOfIteratorHelperLoose(keyedCombinations(combinations, toKey$1)), _step; !(_step = _iterator()).done;) {
    var c = _step.value;
    for (var _iterator2 = _createForOfIteratorHelperLoose(c.s), _step2; !(_step2 = _iterator2()).done;) {
      var s = _step2.value;
      if (combinationsBySet.has(s)) {
        combinationsBySet.get(s).push(c);
      } else {
        combinationsBySet.set(s, [c]);
      }
    }
  }
  return function (a, b) {
    var r = common(a, b, toKey$1);
    if (r.done != null) {
      return r.done;
    }
    if (!r.aIsSet && !r.bIsSet) {
      return 0;
    }
    if (r.aIsSet && !r.bIsSet) {
      return aInB(b, r) ? b.cardinality : 0;
    }
    if (!r.aIsSet && r.bIsSet) {
      return bInA(a, r) ? a.cardinality : 0;
    }
    var hasA = combinationsBySet.get(r.aKey);
    var hasB = combinationsBySet.get(r.bKey);
    if (!hasA || !hasB) {
      return 0;
    }
    if (hasA.length < hasB.length) {
      return hasA.reduce(function (acc, c) {
        return acc + (c.sets.has(r.bKey) ? c.cardinality : 0);
      }, 0);
    }
    return hasB.reduce(function (acc, c) {
      return acc + (c.sets.has(r.aKey) ? c.cardinality : 0);
    }, 0);
  };
}
function generateIntersectionOverlapFunction(combinations, toKey$1) {
  if (toKey$1 === void 0) {
    toKey$1 = toKey;
  }
  var combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map(function (d) {
    return [d.key, d.cardinality];
  }));
  return function (a, b) {
    var r = common(a, b, toKey$1);
    if (r.done != null) {
      return r.done;
    }
    if (r.aIsSet && !r.bIsSet && aInB(b, r)) {
      return b.cardinality;
    }
    if (!r.aIsSet && r.bIsSet && bInA(a, r)) {
      return a.cardinality;
    }
    var key = combinedKey(a, b, r);
    if (!combinationsByKey.has(key)) {
      return 0;
    }
    return combinationsByKey.get(key);
  };
}
function generateUnionOverlapFunction(combinations, toKey$1) {
  if (toKey$1 === void 0) {
    toKey$1 = toKey;
  }
  var combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map(function (d) {
    return [d.key, d.cardinality];
  }));
  return function (a, b) {
    var r = common(a, b, toKey$1);
    if (r.done != null) {
      return r.done;
    }
    if (r.aIsSet && !r.bIsSet && aInB(b, r)) {
      return a.cardinality;
    }
    if (!r.aIsSet && r.bIsSet && bInA(a, r)) {
      return b.cardinality;
    }
    var key = combinedKey(a, b, r);
    if (!combinationsByKey.has(key)) {
      return 0;
    }
    return a.cardinality + b.cardinality - combinationsByKey.get(key);
  };
}
function extractFromExpression(combinations, accOrOptions, o) {
  var _ref, _options$type, _options$joiner;
  if (o === void 0) {
    o = {};
  }
  var acc = typeof accOrOptions === 'function' ? accOrOptions : function (e) {
    return e.sets;
  };
  var options = (_ref = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _ref !== void 0 ? _ref : {};
  var type = (_options$type = options.type) !== null && _options$type !== void 0 ? _options$type : 'intersection';
  var joiner = (_options$joiner = options.joiner) !== null && _options$joiner !== void 0 ? _options$joiner : SET_JOINERS[type];
  var sets = [];
  var setLookup = new Map();
  var overlapFunction = null;
  function overlap(that) {
    if (this === that) {
      return this.cardinality;
    }
    return overlapFunction == null ? 0 : overlapFunction(this, that);
  }
  var cs = combinations.map(function (c) {
    var containedSets = acc(c);
    var containedSetsObjects = containedSets.map(function (s) {
      if (setLookup.has(s)) {
        return setLookup.get(s);
      }
      var set = {
        cardinality: 0,
        elems: [],
        name: s,
        type: 'set',
        overlap: overlap
      };
      sets.push(set);
      setLookup.set(set.name, set);
      return set;
    });
    if (type === 'distinctIntersection') {
      for (var _iterator3 = _createForOfIteratorHelperLoose(containedSetsObjects), _step3; !(_step3 = _iterator3()).done;) {
        var s = _step3.value;
        s.cardinality += c.cardinality;
      }
    } else if (containedSets.length === 1) {
      Object.assign(containedSetsObjects[0], {
        cardinality: c.cardinality
      }, c);
    } else if (type === 'intersection') {
      for (var _iterator4 = _createForOfIteratorHelperLoose(containedSetsObjects), _step4; !(_step4 = _iterator4()).done;) {
        var _s2 = _step4.value;
        _s2.cardinality = Math.max(_s2.cardinality, c.cardinality);
      }
    } else if (type === 'union') {
      for (var _iterator5 = _createForOfIteratorHelperLoose(containedSetsObjects), _step5; !(_step5 = _iterator5()).done;) {
        var _s3 = _step5.value;
        _s3.cardinality = Math.min(_s3.cardinality, c.cardinality);
      }
    }
    var name = containedSets.join(joiner);
    return Object.assign({
      type: type,
      elems: [],
      name: name,
      overlap: overlap
    }, c, {
      cardinality: c.cardinality,
      degree: containedSets.length,
      sets: new Set(containedSetsObjects)
    });
  });
  var sortedSets = postprocessSets(sets, {
    order: options.setOrder
  });
  var sortedCombinations = postprocessCombinations(sortedSets, cs, {
    order: options.combinationOrder
  });
  switch (type) {
    case 'distinctIntersection':
      overlapFunction = generateDistinctOverlapFunction(sortedCombinations, options.toKey);
      break;
    case 'union':
      overlapFunction = generateUnionOverlapFunction(sortedCombinations, options.toKey);
      break;
    default:
      overlapFunction = generateIntersectionOverlapFunction(sortedCombinations, options.toKey);
      break;
  }
  return {
    sets: sortedSets,
    combinations: sortedCombinations
  };
}
function extractSets(elements, accOrOptions, o) {
  var _ref;
  if (o === void 0) {
    o = {};
  }
  var acc = typeof accOrOptions === 'function' ? accOrOptions : function (e) {
    return e.sets;
  };
  var options = (_ref = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _ref !== void 0 ? _ref : {};
  var sets = new Map();
  elements.forEach(function (elem) {
    acc(elem).forEach(function (set) {
      var s = String(set);
      if (!sets.has(s)) {
        sets.set(s, [elem]);
      } else {
        sets.get(s).push(elem);
      }
    });
  });
  return postprocessSets(Array.from(sets).map(function (_ref2) {
    var set = _ref2[0],
        elems = _ref2[1];
    var r = {
      type: 'set',
      elems: elems,
      name: String(set),
      cardinality: elems.length
    };
    return r;
  }), options);
}
var bandScale = function bandScale(domain, size, padding) {
  var blocks = domain.length + padding;
  var step = size / Math.max(1, blocks);
  var start = size - step * domain.length;
  var lookup = new Map(domain.map(function (d, i) {
    return [d, i];
  }));
  var bandwidth = step / (1 + padding);
  var scale = function scale(v) {
    var index = lookup.get(v);
    if (index == null) {
      return undefined;
    }
    return start + step * index;
  };
  scale.bandwidth = function () {
    return bandwidth;
  };
  return scale;
};
function hasOverlap(positions, heights, stride) {
  if (stride === void 0) {
    stride = 1;
  }
  for (var i = 0; i < positions.length - stride; i += stride) {
    var pos_i = positions[i];
    var pos_n = positions[i + 1];
    if (pos_i < pos_n) {
      var right = pos_i + heights[i] / 2;
      var left = pos_n - heights[i + 1] / 2;
      if (right > left) {
        return true;
      }
    } else {
      var _left = pos_i - heights[i] / 2;
      var _right = pos_n + heights[i + 1] / 2;
      if (_right > _left) {
        return true;
      }
    }
  }
  return false;
}
function ensureLast(ticks, max, scale, heightPerTick, toStr) {
  var last = ticks[ticks.length - 1];
  if (!last.label) {
    for (var j = ticks.length - 2; j > 0; --j) {
      if (ticks[j].label) {
        last = ticks[j];
        break;
      }
    }
  }
  if (last.value < max) {
    var pos_l = scale(last.value);
    var pos_max = scale(max);
    if (pos_l < pos_max) {
      var right = pos_l + heightPerTick(last.value) / 2;
      var left = pos_max - heightPerTick(max) / 2;
      if (right < left) {
        ticks.push({
          value: max,
          label: toStr(max)
        });
      }
    } else {
      var _left2 = pos_l - heightPerTick(last.value) / 2;
      var _right2 = pos_max + heightPerTick(max) / 2;
      if (_right2 < _left2) {
        ticks.push({
          value: max,
          label: toStr(max)
        });
      }
    }
  }
  return ticks;
}
function genTicks(values, toStr, stride) {
  if (toStr === void 0) {
    toStr = String;
  }
  if (stride === void 0) {
    stride = 1;
  }
  return values.map(function (v, i) {
    return {
      value: v,
      label: stride === 1 || i % stride === 0 ? toStr(v) : undefined
    };
  });
}
function checkValues(values, scale, heightPerTick, max, toStr) {
  var positions = values.map(function (v) {
    return scale(v);
  });
  var heights = values.map(function (v) {
    return heightPerTick(v);
  });
  if (!hasOverlap(positions, heights)) {
    return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);
  }
  if (!hasOverlap(positions, heights, 2)) {
    return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);
  }
  return null;
}
function toStr(v) {
  return v.toLocaleString();
}
function niceFactors(max, maxCount) {
  if (maxCount === void 0) {
    maxCount = 11;
  }
  var digits = Math.max(0, Math.floor(Math.log10(max) - 0.5));
  var factor = Math.pow(10, digits);
  var factors = [1, 2, 5];
  var r = factors.map(function (f) {
    return f * factor;
  });
  if (digits > 0) {
    r.unshift(factors[factors.length - 1] * Math.pow(10, digits - 1));
  }
  r.push(factors[0] * Math.pow(10, digits + 1));
  var lower = Math.ceil(max / maxCount);
  return r.filter(function (d) {
    return d >= lower && d <= max;
  });
}
function range(max, inc) {
  if (inc === void 0) {
    inc = 1;
  }
  var values = [];
  for (var v = 0; v <= max; v += inc) {
    values.push(v);
  }
  return values;
}
function distributeTicks(max, maxCount, scale, heightPerTick) {
  if (maxCount <= 0) {
    return [];
  }
  var factors = niceFactors(max, maxCount);
  for (var i = 0; i < factors.length; i++) {
    var values = range(max, factors[i]);
    var r = checkValues(values, scale, heightPerTick, max, toStr);
    if (r) {
      return r;
    }
  }
  return genTicks([0, max], toStr);
}
var linearScale = function linearScale(max, range, options) {
  var size = range[1] - range[0];
  var domain = max;
  var scale = function scale(v) {
    var n = v / domain;
    return range[0] + n * size;
  };
  scale.ticks = function (count) {
    if (count === void 0) {
      count = 10;
    }
    if (options.orientation === 'vertical') {
      var heightPerTick = Math.ceil(options.fontSizeHint * 1.4);
      return distributeTicks(max, count + 1, scale, function () {
        return heightPerTick;
      });
    }
    var widthPerChar = options.fontSizeHint / 1.4;
    return distributeTicks(max, count + 1, scale, function (v) {
      return Math.ceil(toStr(v).length * widthPerChar);
    });
  };
  scale.tickFormat = function () {
    return toStr;
  };
  return scale;
};
function toStr$1(v) {
  var orders = ['', 'k', 'M', 'G'];
  var order = Math.max(0, Math.min(Math.floor(Math.log10(v) / 3), orders.length - 1));
  var vi = Math.round(v / Math.pow(10, order * 3 - 1)) / 10;
  return "" + vi.toLocaleString() + orders[order];
}
function range$1(max, factor) {
  var values = [];
  var inc = Math.pow(10, factor);
  for (var v = 1; v <= max; v *= inc) {
    values.push(v);
  }
  return values;
}
function generateInnerTicks(max, factor) {
  var values = [];
  var inc = 10;
  for (var v = 1, i = 0; v <= max; v *= inc, i++) {
    values.push({
      value: v,
      label: factor === 1 || i % factor === 0 ? toStr$1(v) : undefined
    });
    for (var vv = v + v; vv < v * inc && vv < max; vv += v * factor) {
      values.push({
        value: vv
      });
    }
  }
  return values;
}
function distributeTicks$1(max, maxCount, scale, heightPerTick) {
  if (maxCount <= 0) {
    return [];
  }
  for (var _i = 0, _arr = [1, 2, 5]; _i < _arr.length; _i++) {
    var factor = _arr[_i];
    var values = range$1(max, factor);
    var r = checkValues(values, scale, heightPerTick, max, toStr$1);
    if (r) {
      return ensureLast(generateInnerTicks(max, factor), max, scale, heightPerTick, toStr$1);
    }
  }
  return genTicks([0, max], toStr$1);
}
var logScale = function logScale(max, range, options) {
  var size = range[1] - range[0];
  var domain = max < 1 ? 1 : Math.log10(max);
  var scale = function scale(v) {
    var n = v <= 1 ? 0 : Math.log10(v) / domain;
    return range[0] + n * size;
  };
  scale.ticks = function (count) {
    if (count === void 0) {
      count = 10;
    }
    if (options.orientation === 'vertical') {
      var heightPerTick = Math.ceil(options.fontSizeHint * 1.4);
      return distributeTicks$1(max, count + 1, scale, function () {
        return heightPerTick;
      });
    }
    var widthPerChar = options.fontSizeHint / 1.4;
    return distributeTicks$1(max, count + 1, scale, function (v) {
      return Math.ceil(toStr$1(v).length * widthPerChar);
    });
  };
  scale.tickFormat = function () {
    return toStr$1;
  };
  return scale;
};
function compressIndicesArray(arr) {
  if (arr.length === 0) {
    return '';
  }
  var encoded = [];
  var startIndex = 0;
  var push = function push(i) {
    if (i === startIndex + 1) {
      encoded.push(arr[startIndex].toString());
    } else if (i === startIndex + 2 && i < 10) {
      encoded.push(arr[startIndex] + "," + arr[startIndex + 1]);
    } else {
      encoded.push(arr[startIndex] + "+" + (i - startIndex - 1));
    }
    return i;
  };
  for (var i = 1; i < arr.length; i++) {
    var expected = arr[i - 1] + 1;
    var v = arr[i];
    if (v !== expected) {
      startIndex = push(i);
      startIndex = i;
    }
  }
  push(arr.length);
  return encoded.join(',');
}
function toIndicesArray(arr, toIndex, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      sortAble = _ref.sortAble,
      _ref$compress = _ref.compress,
      compress = _ref$compress === void 0 ? 'auto' : _ref$compress;
  if (arr.length === 0) {
    return [];
  }
  var base = arr.map(function (v) {
    return toIndex(v);
  });
  if (compress === 'no') {
    return base;
  }
  if (sortAble) {
    base.sort(function (a, b) {
      return a - b;
    });
  }
  var encoded = compressIndicesArray(base);
  var baseLength = JSON.stringify(base).length;
  var encodedLength = encoded.length + 2;
  if (encodedLength < baseLength * 0.6 || baseLength - encodedLength > 50 || compress === 'yes' && encodedLength < baseLength) {
    return encoded;
  }
  return base;
}
function fromIndicesArray(indices, elements) {
  if (typeof indices === 'string') {
    if (indices.length === 0) {
      return [];
    }
    return indices.split(',').map(function (s) {
      if (s.includes('+')) {
        var _s$split$map = s.split('+').map(function (si) {
          return Number.parseInt(si, 10);
        }),
            start = _s$split$map[0],
            length = _s$split$map[1];
        return elements.slice(start, start + length + 1);
      }
      return elements[Number.parseInt(s, 10)];
    }).flat();
  }
  return indices.map(function (i) {
    return elements[i];
  });
}
function withColor(v, s) {
  if (s.color) {
    v.color = s.color;
  }
  return v;
}
function fromDump(dump, elems, options) {
  if (options === void 0) {
    options = {};
  }
  var sets = dump.sets.map(function (set) {
    return asSet(_extends({}, set, {
      elems: fromIndicesArray(set.elems, elems)
    }));
  });
  var gen = function gen() {
    var _dump$combinationOpti;
    return generateCombinations(sets, Object.assign({
      type: 'intersection',
      elems: elems,
      toElemKey: options.toElemKey
    }, (_dump$combinationOpti = dump.combinationOptions) !== null && _dump$combinationOpti !== void 0 ? _dump$combinationOpti : {}));
  };
  var combinations = dump.combinations ? dump.combinations.map(function (c) {
    return asCombination(_extends({}, c, {
      elems: fromIndicesArray(c.elems, elems)
    }), c.type, function (v) {
      return v.sets.map(function (i) {
        return sets[i];
      });
    });
  }) : gen();
  function fromSetRef(ref) {
    if (ref.type === 'set') {
      return sets[ref.index];
    }
    return combinations[ref.index];
  }
  return {
    sets: sets,
    combinations: combinations,
    selection: dump.selection ? typeof dump.selection === 'string' || Array.isArray(dump.selection) ? fromIndicesArray(dump.selection, elems) : fromSetRef(dump.selection) : undefined,
    queries: dump.queries.map(function (query) {
      if (query.set) {
        return {
          name: query.name,
          color: query.color,
          set: fromSetRef(query.set)
        };
      }
      return {
        name: query.name,
        color: query.color,
        elems: fromIndicesArray(query.elems, elems)
      };
    })
  };
}
function toDump(data, config) {
  var _config$toKey;
  if (config === void 0) {
    config = {};
  }
  var indicesOptions = _extends({
    sortAble: true
  }, config);
  var toKey$1 = (_config$toKey = config.toKey) !== null && _config$toKey !== void 0 ? _config$toKey : toKey;
  var bySetKey = new Map(data.sets.map(function (s, i) {
    return [toKey$1(s), i];
  }));
  var byCombinationKey = new Map(data.combinations.map(function (s, i) {
    return [toKey$1(s), i];
  }));
  var toSetRef = function toSetRef(s) {
    if (s.type === 'set') {
      return {
        type: s.type,
        index: bySetKey.get(toKey$1(s))
      };
    }
    var index = byCombinationKey.get(toKey$1(s));
    if (index == null || index < 0) {
      return toIndicesArray(s.elems, data.toElemIndex, indicesOptions);
    }
    return {
      type: s.type,
      index: index
    };
  };
  var setLookup = data.sets.map(function (s, i) {
    return {
      key: toKey$1(s),
      i: i
    };
  });
  return {
    sets: data.sets.map(function (set) {
      return withColor({
        name: set.name,
        cardinality: set.cardinality,
        elems: toIndicesArray(set.elems, data.toElemIndex, indicesOptions)
      }, set);
    }),
    combinations: config.compress === 'no' ? data.combinations.map(function (c) {
      var setKeys = new Set(Array.from(c.sets).map(toKey$1));
      return withColor({
        name: c.name,
        type: c.type,
        cardinality: c.cardinality,
        degree: c.degree,
        sets: setLookup.filter(function (_ref) {
          var key = _ref.key;
          return setKeys.has(key);
        }).map(function (_ref2) {
          var i = _ref2.i;
          return i;
        }),
        elems: toIndicesArray(c.elems, data.toElemIndex, indicesOptions)
      }, c);
    }) : undefined,
    combinationOptions: data.combinationOptions,
    selection: data.selection ? Array.isArray(data.selection) ? toIndicesArray(data.selection, data.toElemIndex, indicesOptions) : toSetRef(data.selection) : undefined,
    queries: data.queries.map(function (query) {
      var elems = isSetQuery(query) ? toSetRef(query.set) : toIndicesArray(Array.from(query.elems), data.toElemIndex, indicesOptions);
      return {
        name: query.name,
        color: query.color,
        set: typeof elems === 'string' || Array.isArray(elems) ? undefined : elems,
        elems: typeof elems === 'string' || Array.isArray(elems) ? elems : undefined
      };
    })
  };
}
function compressLine(line) {
  if (line.length === 0) {
    return '';
  }
  var r = [];
  var start = line[0];
  var len = 1;
  for (var i = 1; i < line.length; i++) {
    var v = line[i];
    if (v === start) {
      len++;
    } else {
      if (len > 1) {
        r.push(start + "=" + (len - 1));
      } else if (start === 0) {
        r.push('');
      } else {
        r.push(start.toString());
      }
      start = v;
      len = 1;
    }
  }
  if (len > 1) {
    r.push(start + "=" + len);
  } else if (start === 0) {
    r.push('');
  } else {
    r.push(start.toString());
  }
  return r.join(',');
}
function decompressLine(line) {
  if (line.length === 0) {
    return [];
  }
  return line.split(',').map(function (v) {
    if (v === '') {
      return 0;
    }
    if (v.includes('=')) {
      var _v$split$map = v.split('=').map(function (v) {
        return Number.parseInt(v, 10);
      }),
          value = _v$split$map[0],
          length = _v$split$map[1];
      return Array(length + 1).fill(value);
    }
    return Number.parseInt(v, 10);
  }).flat();
}
function compressMatrix(matrix) {
  if (matrix.length === 0) {
    return '';
  }
  var rows = matrix.length;
  var flat = matrix.flat();
  return rows + ";" + compressLine(flat);
}
function decompressMatrix(matrix) {
  if (matrix.length === 0) {
    return [];
  }
  var _matrix$split = matrix.split(';'),
      rowsInfo = _matrix$split[0],
      data = _matrix$split[1];
  var rows = Number.parseInt(rowsInfo, 10);
  var values = decompressLine(data);
  var r = [];
  var acc = 0;
  for (var i = rows; i > 0; i--) {
    r.push(values.slice(acc, acc + i));
    acc += i;
  }
  return r;
}
function generateOverlapLookup(sets, combinations, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      toElemKey = _ref.toElemKey,
      _ref$what = _ref.what,
      what = _ref$what === void 0 ? 'intersection' : _ref$what,
      _ref$compress = _ref.compress,
      compress = _ref$compress === void 0 ? 'auto' : _ref$compress;
  var data = sets.concat(combinations);
  function overlapF(set) {
    if (set.overlap) {
      return set.overlap;
    }
    var f = setOverlapFactory(set.elems, toElemKey);
    return function (v) {
      if (v.overlap) {
        return v.overlap(set);
      }
      return f(v.elems)[what];
    };
  }
  var matrix = data.map(function (set, i) {
    var overlap = overlapF(set);
    var r = [];
    for (var j = i + 1; j < data.length; j++) {
      r.push(overlap(data[j]));
    }
    return r;
  });
  matrix.pop();
  if (compress === 'no') {
    return matrix;
  }
  var compressed = compressMatrix(matrix);
  if (compress === 'yes') {
    return compressed;
  }
  var encodedLength = JSON.stringify(matrix).length;
  var compressedLength = compressed.length + 2;
  return compressedLength < encodedLength * 0.6 ? compressed : matrix;
}
function generateOverlapLookupFunction(matrix, sets, combinations, toKey$1) {
  if (toKey$1 === void 0) {
    toKey$1 = toKey;
  }
  var lookup = typeof matrix == 'string' ? decompressMatrix(matrix) : matrix;
  var setIndex = new Map(sets.map(function (set, i) {
    return [toKey$1(set), i];
  }));
  var combinationIndex = new Map(combinations.map(function (set, i) {
    return [toKey$1(set), i + sets.length];
  }));
  var compute = function compute(a, b) {
    if (a === b) {
      return a.cardinality;
    }
    var aKey = toKey$1(a);
    var bKey = toKey$1(b);
    var aIndex = setIndex.has(aKey) ? setIndex.get(aKey) : combinationIndex.get(aKey);
    var bIndex = setIndex.has(bKey) ? setIndex.get(bKey) : combinationIndex.get(bKey);
    if (aIndex === bIndex) {
      return a.cardinality;
    }
    var row = Math.min(aIndex, bIndex);
    var col = Math.max(aIndex, bIndex) - row - 1;
    if (row < 0 || row >= lookup.length || col < 0 || col >= lookup[row].length) {
      return 0;
    }
    return lookup[row][col];
  };
  return {
    setIndex: setIndex,
    compute: compute,
    combinationIndex: combinationIndex
  };
}
function generateName$1(sets, type) {
  if (sets.length === 1) {
    return sets[0].name;
  }
  return "(" + sets.map(function (set) {
    return set.name;
  }).join(SET_JOINERS[type]) + ")";
}
function toStaticDump(data, config) {
  var _config$toKey;
  if (config === void 0) {
    config = {};
  }
  var toKey$1 = (_config$toKey = config.toKey) !== null && _config$toKey !== void 0 ? _config$toKey : toKey;
  var bySetKey = new Map(data.sets.map(function (s, i) {
    return [toKey$1(s), i];
  }));
  var byCombinationKey = new Map(data.combinations.map(function (s, i) {
    return [toKey$1(s), i];
  }));
  var toSelectionSetRef = function toSelectionSetRef(s) {
    if (isSetLike(s)) {
      if (s.type === 'set') {
        return {
          type: s.type,
          index: bySetKey.get(toKey$1(s))
        };
      }
      var index = byCombinationKey.get(toKey$1(s));
      if (index != null && index >= 0) {
        return {
          type: s.type,
          index: index
        };
      }
    }
    var overlapF = setOverlapFactory(isSetLike(s) ? s.elems : s);
    return data.sets.map(function (set) {
      return overlapF(set.elems).intersection;
    }).concat(data.combinations.map(function (set) {
      return overlapF(set.elems).intersection;
    }));
  };
  var setIndex = new Map(data.sets.map(function (set, i) {
    return [toKey$1(set), i];
  }));
  var overlaps = generateOverlapLookup(data.sets, data.combinations, config);
  var shortNames = config.compress === 'yes';
  var compressCombination = function compressCombination(set) {
    var partOf = Array.from(set.sets).map(function (s) {
      return setIndex.get(toKey$1(s));
    }).sort(function (a, b) {
      return a - b;
    });
    var r = {
      c: set.cardinality,
      s: partOf.reduce(function (acc, i) {
        return acc + Math.pow(2, i);
      }, 0)
    };
    if (set.name !== generateName$1(partOf.map(function (i) {
      return data.sets[i];
    }), set.type)) {
      r.n = set.name;
    }
    if (set.type !== 'intersection') {
      r.type = set.type[0];
    }
    if (set.color) {
      r.cc = set.color;
    }
    return r;
  };
  return {
    sets: shortNames ? data.sets.map(function (set) {
      return {
        n: set.name,
        cc: set.color,
        c: set.cardinality
      };
    }) : data.sets.map(function (set) {
      return withColor({
        name: set.name,
        cardinality: set.cardinality
      }, set);
    }),
    combinations: shortNames ? data.combinations.map(compressCombination) : data.combinations.map(function (set) {
      return withColor({
        name: set.name,
        cardinality: set.cardinality,
        type: set.type,
        sets: Array.from(set.sets).map(function (s) {
          return setIndex.get(toKey$1(s));
        }).sort(function (a, b) {
          return a - b;
        })
      }, set);
    }),
    overlaps: overlaps,
    selection: data.selection ? toSelectionSetRef(data.selection) : undefined,
    queries: data.queries.map(function (query) {
      if (isSetQuery(query)) {
        var ref = toSelectionSetRef(query.set);
        if (Array.isArray(ref)) {
          return {
            name: query.name,
            color: query.color,
            overlaps: ref
          };
        }
        return {
          name: query.name,
          color: query.color,
          set: ref
        };
      }
      var overlapF = setOverlapFactory(query.elems);
      var overlaps = data.sets.map(function (set) {
        return overlapF(set.elems).intersection;
      }).concat(data.combinations.map(function (set) {
        return overlapF(set.elems).intersection;
      }));
      return {
        name: query.name,
        color: query.color,
        overlaps: overlaps
      };
    })
  };
}
function isCompressed(s) {
  return typeof s.c === 'number';
}
function isCompressedSet(s) {
  return typeof s.c === 'number';
}
function fromStaticDump(dump, config) {
  var _config$toKey2;
  if (config === void 0) {
    config = {};
  }
  var toKey$1 = (_config$toKey2 = config.toKey) !== null && _config$toKey2 !== void 0 ? _config$toKey2 : toKey;
  var computeF = function computeF() {
    return 0;
  };
  function withOverlap(s) {
    s.overlap = function (b) {
      return computeF(s, b);
    };
    return s;
  }
  var sets = dump.sets.map(function (set) {
    return withOverlap({
      name: isCompressedSet(set) ? set.n : set.name,
      cardinality: isCompressedSet(set) ? set.c : set.cardinality,
      type: 'set',
      elems: []
    });
  });
  var fromBit = function fromBit(v) {
    return sets.filter(function (_, i) {
      var position = Math.pow(2, i);
      return (v & position) === position;
    });
  };
  var combinations = dump.combinations.map(function (set) {
    var _set$type, _set$n;
    var partOf = isCompressed(set) ? fromBit(set.s) : set.sets.map(function (i) {
      return sets[i];
    });
    var lookup = {
      i: 'intersection',
      u: 'union',
      c: 'composite',
      d: 'distinctIntersection'
    };
    var type = lookup[((_set$type = set.type) !== null && _set$type !== void 0 ? _set$type : 'i')[0]];
    return withOverlap({
      name: isCompressed(set) ? (_set$n = set.n) !== null && _set$n !== void 0 ? _set$n : generateName$1(partOf, type) : set.name,
      cardinality: isCompressed(set) ? set.c : set.cardinality,
      type: type,
      degree: partOf.length,
      sets: new Set(partOf),
      elems: []
    });
  });
  var _generateOverlapLooku = generateOverlapLookupFunction(dump.overlaps, sets, combinations, toKey$1),
      setIndex = _generateOverlapLooku.setIndex,
      combinationIndex = _generateOverlapLooku.combinationIndex,
      compute = _generateOverlapLooku.compute;
  computeF = compute;
  function fromSetRef(ref) {
    if (ref.type === 'set') {
      return sets[ref.index];
    }
    return combinations[ref.index];
  }
  function generateOverlap(lookup) {
    return function (v) {
      var key = toKey$1(v);
      var index = setIndex.has(key) ? setIndex.get(key) : combinationIndex.get(key);
      return index == null || index < 0 || index >= lookup.length ? 0 : lookup[index];
    };
  }
  return {
    sets: sets,
    combinations: combinations,
    selection: dump.selection ? Array.isArray(dump.selection) ? generateOverlap(dump.selection) : fromSetRef(dump.selection) : undefined,
    queries: dump.queries.map(function (query) {
      if (query.set) {
        return {
          name: query.name,
          color: query.color,
          set: fromSetRef(query.set)
        };
      }
      return {
        name: query.name,
        color: query.color,
        overlap: generateOverlap(query.overlaps)
      };
    })
  };
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire();
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var lzString = createCommonjsModule(function (module) {
  var LZString = function () {
    var f = String.fromCharCode;
    var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
    var baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i = 0; i < alphabet.length; i++) {
          baseReverseDic[alphabet][alphabet.charAt(i)] = i;
        }
      }
      return baseReverseDic[alphabet][character];
    }
    var LZString = {
      compressToBase64: function compressToBase64(input) {
        if (input == null) return "";
        var res = LZString._compress(input, 6, function (a) {
          return keyStrBase64.charAt(a);
        });
        switch (res.length % 4) {
          default:
          case 0:
            return res;
          case 1:
            return res + "===";
          case 2:
            return res + "==";
          case 3:
            return res + "=";
        }
      },
      decompressFromBase64: function decompressFromBase64(input) {
        if (input == null) return "";
        if (input == "") return null;
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },
      compressToUTF16: function compressToUTF16(input) {
        if (input == null) return "";
        return LZString._compress(input, 15, function (a) {
          return f(a + 32);
        }) + " ";
      },
      decompressFromUTF16: function decompressFromUTF16(compressed) {
        if (compressed == null) return "";
        if (compressed == "") return null;
        return LZString._decompress(compressed.length, 16384, function (index) {
          return compressed.charCodeAt(index) - 32;
        });
      },
      compressToUint8Array: function compressToUint8Array(uncompressed) {
        var compressed = LZString.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2);
        for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
          var current_value = compressed.charCodeAt(i);
          buf[i * 2] = current_value >>> 8;
          buf[i * 2 + 1] = current_value % 256;
        }
        return buf;
      },
      decompressFromUint8Array: function decompressFromUint8Array(compressed) {
        if (compressed === null || compressed === undefined) {
          return LZString.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2);
          for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
            buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
          }
          var result = [];
          buf.forEach(function (c) {
            result.push(f(c));
          });
          return LZString.decompress(result.join(''));
        }
      },
      compressToEncodedURIComponent: function compressToEncodedURIComponent(input) {
        if (input == null) return "";
        return LZString._compress(input, 6, function (a) {
          return keyStrUriSafe.charAt(a);
        });
      },
      decompressFromEncodedURIComponent: function decompressFromEncodedURIComponent(input) {
        if (input == null) return "";
        if (input == "") return null;
        input = input.replace(/ /g, "+");
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrUriSafe, input.charAt(index));
        });
      },
      compress: function compress(uncompressed) {
        return LZString._compress(uncompressed, 16, function (a) {
          return f(a);
        });
      },
      _compress: function _compress(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null) return "";
        var i,
            value,
            context_dictionary = {},
            context_dictionaryToCreate = {},
            context_c = "",
            context_wc = "",
            context_w = "",
            context_enlargeIn = 2,
        context_dictSize = 3,
            context_numBits = 2,
            context_data = [],
            context_data_val = 0,
            context_data_position = 0,
            ii;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else context_data_position++;
        }
        return context_data.join('');
      },
      decompress: function decompress(compressed) {
        if (compressed == null) return "";
        if (compressed == "") return null;
        return LZString._decompress(compressed.length, 32768, function (index) {
          return compressed.charCodeAt(index);
        });
      },
      _decompress: function _decompress(length, resetValue, getNextValue) {
        var dictionary = [],
            next,
            enlargeIn = 4,
            dictSize = 4,
            numBits = 3,
            entry = "",
            result = [],
            i,
            w,
            bits,
            resb,
            maxpower,
            power,
            c,
            data = {
          val: getNextValue(0),
          position: resetValue,
          index: 1
        };
        for (i = 0; i < 3; i += 1) {
          dictionary[i] = i;
        }
        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        switch (next = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits);
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits);
            break;
          case 2:
            return "";
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) {
            return "";
          }
          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 2:
              return result.join('');
          }
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
    return LZString;
  }();
  if ( module != null) {
    module.exports = LZString;
  }
});

function extractStyleId(node) {
  return Array.from(node.classList).find(function (d) {
    return d.startsWith('root-');
  }).slice('root-'.length);
}
function extractTitle(node, styleId) {
  var _node$querySelector$t, _node$querySelector;
  return (_node$querySelector$t = (_node$querySelector = node.querySelector("titleTextStyle-" + styleId)) === null || _node$querySelector === void 0 ? void 0 : _node$querySelector.textContent) !== null && _node$querySelector$t !== void 0 ? _node$querySelector$t : 'UpSetJS';
}
function extractDescription(node, styleId) {
  var _node$querySelector$t2, _node$querySelector2;
  return (_node$querySelector$t2 = (_node$querySelector2 = node.querySelector("descTextStyle-" + styleId)) === null || _node$querySelector2 === void 0 ? void 0 : _node$querySelector2.textContent) !== null && _node$querySelector$t2 !== void 0 ? _node$querySelector$t2 : '';
}
var EMPTY_OBJECT = {};
var EMPTY_ARRAY = [];
var DEFAULT_FONT_SIZES = {
  setLabel: '16px',
  axisTick: '10px',
  chartLabel: '16px',
  barLabel: '10px',
  legend: '10px',
  description: '16px',
  title: '24px',
  valueLabel: '12px',
  exportLabel: '10px'
};
var DEFAULT_WIDTH_RATIO = [0.18, 0.12, 0.7];
var DEFAULT_HEIGHT_RATIO = [0.6, 0.4];
var DEFAULT_COMBINATIONS = {
  type: 'intersection',
  order: ['cardinality:desc', 'name:asc']
};
var FONT_SIZES_KEYS = Object.keys(DEFAULT_FONT_SIZES);
var MULTI_STYLE_KEYS = ['axisTick', 'bar', 'barLabel', 'chartLabel', 'dot', 'legend', 'title', 'description', 'setLabel', 'set', 'valueLabel'];
var EXPORT_OPTION_KEYS = ['dump', 'png', 'share', 'svg', 'vega'];
var sets = [];
var intersections = [];
var bb = {
  x: 0,
  y: 0,
  width: 10,
  height: 10
};
var venn0 = {
  sets: sets,
  intersections: intersections,
  bb: bb
};
var sets$1 = [{
  cx: 0,
  cy: 0,
  r: 5,
  text: {
    x: 3.5,
    y: -4
  },
  align: "start",
  verticalAlign: "bottom"
}];
var intersections$1 = [{
  sets: [0],
  x1: 0,
  y1: 5,
  arcs: [{
    mode: "i",
    ref: 0,
    x2: 0,
    y2: -5,
    sweep: false,
    large: false
  }, {
    mode: "i",
    ref: 0,
    x2: 0,
    y2: 5,
    sweep: false,
    large: false
  }],
  text: {
    x: 0,
    y: 0
  }
}];
var bb$1 = {
  x: -5,
  y: -5,
  width: 10,
  height: 10
};
var venn1 = {
  sets: sets$1,
  intersections: intersections$1,
  bb: bb$1
};
var sets$2 = [{
  cx: -4,
  cy: 0,
  r: 5,
  text: {
    x: -7.5,
    y: 4
  },
  align: "end",
  verticalAlign: "top"
}, {
  cx: 4,
  cy: 0,
  r: 5,
  text: {
    x: 7.5,
    y: -4
  },
  align: "start",
  verticalAlign: "bottom"
}];
var intersections$2 = [{
  sets: [0],
  x1: 0,
  y1: -3,
  arcs: [{
    mode: "i",
    ref: 0,
    x2: 0,
    y2: 3,
    sweep: false,
    large: true
  }, {
    mode: "o",
    ref: 1,
    x2: 0,
    y2: -3,
    sweep: true,
    large: false
  }],
  text: {
    x: -4,
    y: 0
  }
}, {
  sets: [1],
  x1: 0,
  y1: 3,
  arcs: [{
    mode: "i",
    ref: 1,
    x2: 0,
    y2: -3,
    sweep: false,
    large: true
  }, {
    mode: "o",
    ref: 0,
    x2: 0,
    y2: 3,
    sweep: true,
    large: false
  }],
  text: {
    x: 4,
    y: 0
  }
}, {
  sets: [0, 1],
  x1: 0,
  y1: 3,
  arcs: [{
    mode: "i",
    ref: 0,
    x2: 0,
    y2: -3,
    sweep: false,
    large: false
  }, {
    mode: "i",
    ref: 1,
    x2: 0,
    y2: 3,
    sweep: false,
    large: false
  }],
  text: {
    x: 0,
    y: 0
  }
}];
var bb$2 = {
  x: -9,
  y: -5,
  width: 18,
  height: 10
};
var venn2 = {
  sets: sets$2,
  intersections: intersections$2,
  bb: bb$2
};
var sets$3 = [{
  cx: -3.464,
  cy: -2,
  r: 5,
  text: {
    x: -7,
    y: -6
  },
  align: "end"
}, {
  cx: 3.464,
  cy: -2,
  r: 5,
  text: {
    x: 7,
    y: -6
  },
  align: "start"
}, {
  cx: 0,
  cy: 4,
  r: 5,
  text: {
    x: 4,
    y: 7.5
  },
  align: "start",
  verticalAlign: "top"
}];
var intersections$3 = [{
  sets: [0],
  x1: -4.855,
  y1: 2.803,
  arcs: [{
    mode: "o",
    ref: 2,
    x2: -1.39,
    y2: -0.803,
    sweep: true,
    large: false
  }, {
    mode: "o",
    ref: 1,
    x2: 0,
    y2: -5.606,
    sweep: true,
    large: false
  }, {
    mode: "i",
    ref: 0,
    x2: -4.855,
    y2: 2.803,
    sweep: false,
    large: true
  }],
  text: {
    x: -4.216,
    y: -2.434
  }
}, {
  sets: [1],
  x1: 0,
  y1: -5.606,
  arcs: [{
    mode: "o",
    ref: 0,
    x2: 1.39,
    y2: -0.803,
    sweep: true,
    large: false
  }, {
    mode: "o",
    ref: 2,
    x2: 4.855,
    y2: 2.803,
    sweep: true,
    large: false
  }, {
    mode: "i",
    ref: 1,
    x2: 0,
    y2: -5.606,
    sweep: false,
    large: true
  }],
  text: {
    x: 4.216,
    y: -2.434
  }
}, {
  sets: [2],
  x1: -4.855,
  y1: 2.803,
  arcs: [{
    mode: "o",
    ref: 0,
    x2: 0,
    y2: 1.606,
    sweep: false,
    large: false
  }, {
    mode: "o",
    ref: 1,
    x2: 4.855,
    y2: 2.803,
    sweep: false,
    large: false
  }, {
    mode: "i",
    ref: 2,
    x2: -4.855,
    y2: 2.803,
    sweep: true,
    large: true
  }],
  text: {
    x: 0,
    y: 4.869
  }
}, {
  sets: [0, 1],
  x1: 0,
  y1: -5.606,
  arcs: [{
    mode: "i",
    ref: 1,
    x2: -1.39,
    y2: -0.803,
    sweep: false,
    large: false
  }, {
    mode: "o",
    ref: 2,
    x2: 1.39,
    y2: -0.803,
    sweep: true,
    large: false
  }, {
    mode: "i",
    ref: 0,
    x2: 0,
    y2: -5.606,
    sweep: false,
    large: false
  }],
  text: {
    x: 0,
    y: -2.404
  }
}, {
  sets: [0, 2],
  x1: -4.855,
  y1: 2.803,
  arcs: [{
    mode: "i",
    ref: 2,
    x2: -1.39,
    y2: -0.803,
    sweep: true,
    large: false
  }, {
    mode: "o",
    ref: 1,
    x2: 0,
    y2: 1.606,
    sweep: false,
    large: false
  }, {
    mode: "i",
    ref: 0,
    x2: -4.855,
    y2: 2.803,
    sweep: true,
    large: false
  }],
  text: {
    x: -2.082,
    y: 1.202
  }
}, {
  sets: [1, 2],
  x1: 4.855,
  y1: 2.803,
  arcs: [{
    mode: "i",
    ref: 2,
    x2: 1.39,
    y2: -0.803,
    sweep: false,
    large: false
  }, {
    mode: "o",
    ref: 0,
    x2: 0,
    y2: 1.606,
    sweep: true,
    large: false
  }, {
    mode: "i",
    ref: 1,
    x2: 4.855,
    y2: 2.803,
    sweep: false,
    large: false
  }],
  text: {
    x: 2.082,
    y: 1.202
  }
}, {
  sets: [0, 1, 2],
  x1: 1.39,
  y1: -0.803,
  arcs: [{
    mode: "i",
    ref: 0,
    x2: 0,
    y2: 1.606,
    sweep: true,
    large: false
  }, {
    mode: "i",
    ref: 1,
    x2: -1.39,
    y2: -0.803,
    sweep: true,
    large: false
  }, {
    mode: "i",
    ref: 2,
    x2: 1.39,
    y2: -0.803,
    sweep: true,
    large: false
  }],
  text: {
    x: 0,
    y: 0
  }
}];
var bb$3 = {
  x: -8.464,
  y: -7,
  width: 16.928,
  height: 16
};
var venn3 = {
  sets: sets$3,
  intersections: intersections$3,
  bb: bb$3
};
var sets$4 = [{
  cx: 0.439,
  cy: -1.061,
  rx: 2.5,
  ry: 5,
  rotation: 45,
  text: {
    x: 4.5,
    y: -4.5
  },
  align: "start",
  verticalAlign: "bottom"
}, {
  cx: 2.561,
  cy: 1.061,
  rx: 2.5,
  ry: 5,
  rotation: 45,
  text: {
    x: 4,
    y: 3.75
  },
  align: "start",
  verticalAlign: "top"
}, {
  cx: -2.561,
  cy: 1.061,
  rx: 2.5,
  ry: 5,
  rotation: -45,
  text: {
    x: -4,
    y: 3.7
  },
  align: "end",
  verticalAlign: "top"
}, {
  cx: -0.439,
  cy: -1.061,
  rx: 2.5,
  ry: 5,
  rotation: -45,
  text: {
    x: -4.5,
    y: -4.5
  },
  align: "end",
  verticalAlign: "bottom"
}];
var intersections$4 = [{
  sets: [0],
  x1: 0,
  y1: -3.94,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: 4.328,
    y2: -2.828,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 2.179,
    y2: -1.858,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 0,
    y2: -3.94,
    large: false
  }],
  text: {
    x: 2.914,
    y: -3.536
  }
}, {
  sets: [1],
  x1: 4.328,
  y1: -2.828,
  arcs: [{
    ref: 1,
    mode: "i",
    x2: 0,
    y2: 5.006,
    sweep: true,
    large: true
  }, {
    ref: 2,
    mode: "o",
    x2: 1.328,
    y2: 2.828
  }, {
    ref: 3,
    mode: "o",
    x2: 3.108,
    y2: -0.328
  }, {
    ref: 0,
    mode: "o",
    x2: 4.328,
    y2: -2.828
  }],
  text: {
    x: 5.036,
    y: -1.414
  }
}, {
  sets: [2],
  x1: 0,
  y1: 5.006,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: -4.328,
    y2: -2.828,
    sweep: true,
    large: true
  }, {
    ref: 3,
    mode: "o",
    x2: -3.108,
    y2: -0.328
  }, {
    ref: 0,
    mode: "o",
    x2: -1.328,
    y2: 2.828
  }, {
    ref: 1,
    mode: "o",
    x2: 0,
    y2: 5.006
  }],
  text: {
    x: -5.036,
    y: -1.414
  }
}, {
  sets: [3],
  x1: -4.328,
  y1: -2.828,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 0,
    y2: -3.94,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -2.179,
    y2: -1.858,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -4.328,
    y2: -2.828,
    large: false
  }],
  text: {
    x: -2.914,
    y: -3.536
  }
}, {
  sets: [0, 1],
  x1: 4.328,
  y1: -2.828,
  arcs: [{
    ref: 1,
    mode: "i",
    x2: 3.108,
    y2: -0.328,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 2.179,
    y2: -1.858,
    sweep: false,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 4.328,
    y2: -2.828,
    sweep: true,
    large: false
  }],
  text: {
    x: 3.205,
    y: -1.672
  }
}, {
  sets: [0, 2],
  x1: -1.328,
  y1: 2.828,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: -3.108,
    y2: -0.328,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: -0.969,
    y2: 1.755,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -1.328,
    y2: 2.828,
    large: false
  }],
  text: {
    x: -2.212,
    y: 1.591
  }
}, {
  sets: [0, 3],
  x1: 0,
  y1: -3.94,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 2.179,
    y2: -1.858,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 0,
    y2: 0.188,
    sweep: false,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -2.179,
    y2: -1.858,
    sweep: false,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 0,
    y2: -3.94,
    sweep: true
  }],
  text: {
    x: 0,
    y: -1.87
  }
}, {
  sets: [1, 2],
  x1: 1.328,
  y1: 2.828,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: 0,
    y2: 5.006,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: -1.328,
    y2: 2.828,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 0,
    y2: 2.346,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 1.328,
    y2: 2.828
  }],
  text: {
    x: 0,
    y: 3.393
  }
}, {
  sets: [1, 3],
  x1: 3.108,
  y1: -0.328,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 1.328,
    y2: 2.828,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: 0.969,
    y2: 1.755,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: 3.108,
    y2: -0.328,
    large: false
  }],
  text: {
    x: 2.212,
    y: 1.591
  }
}, {
  sets: [2, 3],
  x1: -3.108,
  y1: -0.328,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: -4.328,
    y2: -2.828,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: -2.179,
    y2: -1.858,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -3.108,
    y2: -0.328,
    large: false
  }],
  text: {
    x: -3.205,
    y: -1.672
  }
}, {
  sets: [0, 1, 2],
  x1: 0,
  y1: 2.346,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: -1.328,
    y2: 2.828,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: -0.969,
    y2: 1.755,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 0,
    y2: 2.346,
    large: false
  }],
  text: {
    x: -0.766,
    y: 2.31
  }
}, {
  sets: [0, 1, 3],
  x1: 2.179,
  y1: -1.858,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 3.108,
    y2: -0.328,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 0.969,
    y2: 1.755,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: 0,
    y2: 0.188,
    sweep: false,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: 2.179,
    y2: -1.858,
    sweep: true
  }],
  text: {
    x: 1.558,
    y: -0.056
  }
}, {
  sets: [0, 2, 3],
  x1: -0.969,
  y1: 1.755,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: -3.108,
    y2: -0.328,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: -2.179,
    y2: -1.858,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: 0,
    y2: 0.188,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -0.969,
    y2: 1.755
  }],
  text: {
    x: -1.558,
    y: -0.056
  }
}, {
  sets: [1, 2, 3],
  x1: 1.328,
  y1: 2.828,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 0,
    y2: 2.346,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 0.969,
    y2: 1.755,
    sweep: false,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: 1.328,
    y2: 2.828,
    sweep: true,
    large: false
  }],
  text: {
    x: 0.766,
    y: 2.31
  }
}, {
  sets: [0, 1, 2, 3],
  x1: 0,
  y1: 0.188,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: 0.969,
    y2: 1.755,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 0,
    y2: 2.346,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: -0.969,
    y2: 1.755,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: 0,
    y2: 0.188,
    sweep: true
  }],
  text: {
    x: 0,
    y: 1.43
  }
}];
var bb$4 = {
  x: -6.5,
  y: -5,
  width: 13,
  height: 10
};
var venn4 = {
  sets: sets$4,
  intersections: intersections$4,
  bb: bb$4
};
var sets$5 = [{
  cx: 0.5,
  cy: -1,
  rx: 2.5,
  ry: 5,
  rotation: 0,
  text: {
    x: 2.25,
    y: -5
  },
  align: "start",
  verticalAlign: "bottom"
}, {
  cx: 1.106,
  cy: 0.167,
  rx: 2.5,
  ry: 5,
  rotation: 72,
  text: {
    x: 4.5,
    y: 1.5
  },
  align: "start",
  verticalAlign: "top"
}, {
  cx: 0.183,
  cy: 1.103,
  rx: 2.5,
  ry: 5,
  rotation: 144,
  text: {
    x: 4,
    y: 4
  },
  align: "start",
  verticalAlign: "bottom"
}, {
  cx: -0.992,
  cy: 0.515,
  rx: 2.5,
  ry: 5,
  rotation: 216,
  text: {
    x: -4.7,
    y: 2
  },
  align: "end",
  verticalAlign: "bottom"
}, {
  cx: -0.797,
  cy: -0.785,
  rx: 2.5,
  ry: 5,
  rotation: 288,
  text: {
    x: -4,
    y: -3.6
  },
  align: "end",
  verticalAlign: "bottom"
}];
var intersections$5 = [{
  sets: [0],
  x1: -1.653,
  y1: -3.541,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: 2.857,
    y2: -2.666,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 2.5,
    y2: -2.648,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: -0.495,
    y2: -3.303,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: -1.653,
    y2: -3.541
  }],
  text: {
    x: 0.5,
    y: -5
  }
}, {
  sets: [1],
  x1: 2.857,
  y1: -2.666,
  arcs: [{
    ref: 1,
    mode: "i",
    x2: 3.419,
    y2: 1.893,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: 3.291,
    y2: 1.559,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: 2.988,
    y2: -1.492,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 2.857,
    y2: -2.666
  }],
  text: {
    x: 4.91,
    y: -1.07
  }
}, {
  sets: [2],
  x1: 3.419,
  y1: 1.893,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: -0.744,
    y2: 3.837,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: -0.466,
    y2: 3.612,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 2.342,
    y2: 2.381,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 3.419,
    y2: 1.893
  }],
  text: {
    x: 2.534,
    y: 4.339
  }
}, {
  sets: [3],
  x1: -0.744,
  y1: 3.837,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: -3.879,
    y2: 0.478,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: -3.579,
    y2: 0.673,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -1.54,
    y2: 2.963,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -0.744,
    y2: 3.837
  }],
  text: {
    x: -3.343,
    y: 3.751
  }
}, {
  sets: [4],
  x1: -3.879,
  y1: 0.478,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: -1.653,
    y2: -3.541,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -1.746,
    y2: -3.196,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -3.294,
    y2: -0.549,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: -3.879,
    y2: 0.478
  }],
  text: {
    x: -4.601,
    y: -2.021
  }
}, {
  sets: [0, 1],
  x1: 2.5,
  y1: -2.648,
  arcs: [{
    ref: 1,
    mode: "i",
    x2: 2.857,
    y2: -2.666,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 2.988,
    y2: -1.492,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: 2.572,
    y2: -1.839,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 2.5,
    y2: -2.648
  }],
  text: {
    x: 2.741,
    y: -2.152
  }
}, {
  sets: [0, 2],
  x1: 2.342,
  y1: 2.381,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: -0.466,
    y2: 3.612,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 0.257,
    y2: 2.922,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 2.342,
    y2: 2.381,
    large: false
  }],
  text: {
    x: 0.5,
    y: 3.5
  }
}, {
  sets: [0, 3],
  x1: -0.495,
  y1: -3.303,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 2.5,
    y2: -2.648,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 1.51,
    y2: -2.515,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: -0.495,
    y2: -3.303,
    large: false
  }],
  text: {
    x: 1.653,
    y: -3.125
  }
}, {
  sets: [0, 4],
  x1: -1.653,
  y1: -3.541,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: -0.495,
    y2: -3.303,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: -0.954,
    y2: -3.015,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -1.746,
    y2: -3.196,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: -1.653,
    y2: -3.541
  }],
  text: {
    x: -1.199,
    y: -3.272
  }
}, {
  sets: [1, 2],
  x1: 3.291,
  y1: 1.559,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: 3.419,
    y2: 1.893,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: 2.342,
    y2: 2.381,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 2.544,
    y2: 1.878,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: 3.291,
    y2: 1.559
  }],
  text: {
    x: 2.894,
    y: 1.942
  }
}, {
  sets: [1, 3],
  x1: -1.54,
  y1: 2.963,
  arcs: [{
    ref: 1,
    mode: "i",
    x2: -3.579,
    y2: 0.673,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: -2.7,
    y2: 1.147,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -1.54,
    y2: 2.963,
    large: false
  }],
  text: {
    x: -3.174,
    y: 1.557
  }
}, {
  sets: [1, 4],
  x1: 2.988,
  y1: -1.492,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: 3.291,
    y2: 1.559,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: 2.858,
    y2: 0.659,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 2.988,
    y2: -1.492,
    large: false
  }],
  text: {
    x: 3.483,
    y: 0.606
  }
}, {
  sets: [2, 3],
  x1: -0.466,
  y1: 3.612,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: -0.744,
    y2: 3.837,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: -1.54,
    y2: 2.963,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -1,
    y2: 3,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -0.466,
    y2: 3.612
  }],
  text: {
    x: -0.953,
    y: 3.352
  }
}, {
  sets: [2, 4],
  x1: -3.294,
  y1: -0.549,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: -1.746,
    y2: -3.196,
    sweep: true
  }, {
    ref: 0,
    mode: "o",
    x2: -1.925,
    y2: -2.213
  }, {
    ref: 3,
    mode: "o",
    x2: -3.294,
    y2: -0.549
  }],
  text: {
    x: -2.462,
    y: -2.538
  }
}, {
  sets: [3, 4],
  x1: -3.579,
  y1: 0.673,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: -3.879,
    y2: 0.478,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: -3.294,
    y2: -0.549,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -3.162,
    y2: -0.024,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -3.579,
    y2: 0.673
  }],
  text: {
    x: -3.483,
    y: 0.13
  }
}, {
  sets: [0, 1, 2],
  x1: 2.544,
  y1: 1.878,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: 2.342,
    y2: 2.381,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: 0.257,
    y2: 2.922,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 0.983,
    y2: 2.049,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: 2.544,
    y2: 1.878
  }],
  text: {
    x: 1.457,
    y: 2.331
  }
}, {
  sets: [0, 1, 3],
  x1: 1.51,
  y1: -2.515,
  arcs: [{
    ref: 1,
    mode: "i",
    x2: 2.5,
    y2: -2.648,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: 2.572,
    y2: -1.839,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: 1.51,
    y2: -2.515,
    large: false
  }],
  text: {
    x: 2.194,
    y: -2.334
  }
}, {
  sets: [0, 1, 4],
  x1: 2.572,
  y1: -1.839,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: 2.988,
    y2: -1.492,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 2.858,
    y2: 0.659,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: 2.253,
    y2: -0.302,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 2.572,
    y2: -1.839
  }],
  text: {
    x: 2.667,
    y: -0.665
  }
}, {
  sets: [0, 2, 3],
  x1: 0.257,
  y1: 2.922,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: -0.466,
    y2: 3.612,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: -1,
    y2: 3,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 0.257,
    y2: 2.922,
    large: false
  }],
  text: {
    x: -0.403,
    y: 3.178
  }
}, {
  sets: [0, 2, 4],
  x1: -1.746,
  y1: -3.196,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: -0.954,
    y2: -3.015,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: -1.925,
    y2: -2.213,
    sweep: false,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: -1.746,
    y2: -3.196,
    sweep: true,
    large: false
  }],
  text: {
    x: -1.542,
    y: -2.808
  }
}, {
  sets: [0, 3, 4],
  x1: -0.495,
  y1: -3.303,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: 1.51,
    y2: -2.515,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: 0.409,
    y2: -2.236,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -0.954,
    y2: -3.015,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: -0.495,
    y2: -3.303
  }],
  text: {
    x: 0.192,
    y: -2.742
  }
}, {
  sets: [1, 2, 3],
  x1: -1.54,
  y1: 2.963,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: -2.7,
    y2: 1.147,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: -1.645,
    y2: 1.568,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -1,
    y2: 3,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: -1.54,
    y2: 2.963
  }],
  text: {
    x: -1.767,
    y: 2.106
  }
}, {
  sets: [1, 2, 4],
  x1: 2.858,
  y1: 0.659,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: 3.291,
    y2: 1.559,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "i",
    x2: 2.544,
    y2: 1.878,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: 2.858,
    y2: 0.659,
    large: false
  }],
  text: {
    x: 2.898,
    y: 1.365
  }
}, {
  sets: [1, 3, 4],
  x1: -2.7,
  y1: 1.147,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: -3.579,
    y2: 0.673,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: -3.162,
    y2: -0.024,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: -2.7,
    y2: 1.147,
    large: false
  }],
  text: {
    x: -3.147,
    y: 0.599
  }
}, {
  sets: [2, 3, 4],
  x1: -3.294,
  y1: -0.549,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: -1.925,
    y2: -2.213,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -2,
    y2: -1.08,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -3.162,
    y2: -0.024,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: -3.294,
    y2: -0.549
  }],
  text: {
    x: -2.548,
    y: -1.029
  }
}, {
  sets: [0, 1, 2, 3],
  x1: 0.983,
  y1: 2.049,
  arcs: [{
    ref: 3,
    mode: "i",
    x2: 0.257,
    y2: 2.922,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: -1,
    y2: 3,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: -1.645,
    y2: 1.568,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "o",
    x2: 0.983,
    y2: 2.049
  }],
  text: {
    x: -0.407,
    y: 2.31
  }
}, {
  sets: [0, 1, 2, 4],
  x1: 2.253,
  y1: -0.302,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: 2.858,
    y2: 0.659,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: 2.544,
    y2: 1.878,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "i",
    x2: 0.983,
    y2: 2.049,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "o",
    x2: 2.253,
    y2: -0.302
  }],
  text: {
    x: 2.071,
    y: 1.101
  }
}, {
  sets: [0, 1, 3, 4],
  x1: 1.51,
  y1: -2.515,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: 2.572,
    y2: -1.839,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: 2.253,
    y2: -0.302,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "o",
    x2: 0.409,
    y2: -2.236,
    sweep: false,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: 1.51,
    y2: -2.515,
    sweep: true
  }],
  text: {
    x: 1.687,
    y: -1.63
  }
}, {
  sets: [0, 2, 3, 4],
  x1: -2,
  y1: -1.08,
  arcs: [{
    ref: 0,
    mode: "i",
    x2: -1.925,
    y2: -2.213,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: -0.954,
    y2: -3.015,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: 0.409,
    y2: -2.236,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "o",
    x2: -2,
    y2: -1.08
  }],
  text: {
    x: -1.028,
    y: -2.108
  }
}, {
  sets: [1, 2, 3, 4],
  x1: -1.645,
  y1: 1.568,
  arcs: [{
    ref: 4,
    mode: "i",
    x2: -2.7,
    y2: 1.147,
    sweep: true,
    large: false
  }, {
    ref: 2,
    mode: "i",
    x2: -3.162,
    y2: -0.024,
    sweep: true,
    large: false
  }, {
    ref: 1,
    mode: "i",
    x2: -2,
    y2: -1.08,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "o",
    x2: -1.645,
    y2: 1.568
  }],
  text: {
    x: -2.323,
    y: 0.327
  }
}, {
  sets: [0, 1, 2, 3, 4],
  x1: 0.409,
  y1: -2.236,
  arcs: [{
    ref: 2,
    mode: "i",
    x2: 2.253,
    y2: -0.302,
    sweep: true,
    large: false
  }, {
    ref: 3,
    mode: "i",
    x2: 0.983,
    y2: 2.049,
    sweep: true,
    large: false
  }, {
    ref: 4,
    mode: "i",
    x2: -1.645,
    y2: 1.568,
    sweep: true,
    large: false
  }, {
    ref: 0,
    mode: "i",
    x2: -2,
    y2: -1.08,
    sweep: true
  }, {
    ref: 1,
    mode: "i",
    x2: 0.409,
    y2: -2.236,
    sweep: true
  }],
  text: {
    x: 0,
    y: 0
  }
}];
var bb$5 = {
  x: -5.5,
  y: -6,
  width: 11.6,
  height: 11.8
};
var venn5 = {
  sets: sets$5,
  intersections: intersections$5,
  bb: bb$5
};
function isEllipse(d) {
  return typeof d.rx === 'number';
}
var vennDiagramLayout = {
  maxSets: 5,
  compute: function compute(sets, _combinations, width, height) {
    return layoutImpl(sets.length, width, height);
  }
};
function layoutImpl(sets, width, height) {
  var lookup = [venn0, venn1, venn2, venn3, venn4, venn5];
  var r = lookup[Math.min(lookup.length - 1, sets)];
  var f = Math.min(width / r.bb.width, height / r.bb.height);
  var x = f * -r.bb.x + (width - f * r.bb.width) / 2;
  var y = f * -r.bb.y + (height - f * r.bb.height) / 2;
  var mx = function mx(v) {
    return x + f * v;
  };
  var my = function my(v) {
    return y + f * v;
  };
  return {
    sets: r.sets.map(function (c) {
      return Object.assign({}, c, {
        cx: mx(c.cx),
        cy: my(c.cy),
        text: {
          x: mx(c.text.x),
          y: my(c.text.y)
        }
      }, isEllipse(c) ? {
        rx: c.rx * f,
        ry: c.ry * f
      } : {
        r: c.r * f
      });
    }),
    intersections: r.intersections.map(function (c) {
      return {
        text: {
          x: mx(c.text.x),
          y: my(c.text.y)
        },
        x1: mx(c.x1),
        y1: my(c.y1),
        sets: c.sets,
        arcs: c.arcs.map(function (a) {
          return Object.assign({}, a, {
            x2: mx(a.x2),
            y2: my(a.y2)
          });
        })
      };
    })
  };
}
var lightTheme = {
  selectionColor: '#ffa500',
  color: '#000000',
  hasSelectionColor: '',
  opacity: 1,
  hasSelectionOpacity: -1,
  textColor: '#000000',
  hoverHintColor: '#cccccc',
  notMemberColor: '#d3d3d3',
  alternatingBackgroundColor: 'rgba(0,0,0,0.05)',
  valueTextColor: '#000000',
  strokeColor: '#000000',
  backgroundColor: '#ffffff',
  filled: false
};
var darkTheme = {
  selectionColor: '#ffa500',
  color: '#cccccc',
  hasSelectionColor: '',
  opacity: 1,
  hasSelectionOpacity: -1,
  textColor: '#ffffff',
  hoverHintColor: '#d9d9d9',
  notMemberColor: '#666666',
  alternatingBackgroundColor: 'rgba(255, 255, 255, 0.2)',
  valueTextColor: '#ffffff',
  strokeColor: '#ffffff',
  backgroundColor: '#303030',
  filled: false
};
var vegaTheme = {
  selectionColor: '#4c78a8',
  color: '#4c78a8',
  hasSelectionColor: '#c9d6e5',
  opacity: 1,
  hasSelectionOpacity: -1,
  textColor: '#000000',
  hoverHintColor: '#cccccc',
  notMemberColor: '#d3d3d3',
  alternatingBackgroundColor: 'rgba(0,0,0,0.05)',
  valueTextColor: '#000000',
  strokeColor: '#000000',
  backgroundColor: '#ffffff',
  filled: true
};
function getDefaultTheme(theme) {
  return theme === 'vega' ? vegaTheme : theme === 'dark' ? darkTheme : lightTheme;
}
function areCombinations(combinations) {
  return Array.isArray(combinations);
}
function fillGeneric(base, props, others) {
  if (others === void 0) {
    others = {};
  }
  var theme = getDefaultTheme(props.theme);
  return Object.assign(base, {
    queryLegend: props.queries != null && props.queries.length > 0,
    theme: 'light',
    padding: 20,
    selection: null,
    title: '',
    description: '',
    fontFamily: 'sans-serif',
    queries: EMPTY_ARRAY,
    exportButtons: true,
    className: '',
    fontSizes: DEFAULT_FONT_SIZES,
    classNames: EMPTY_OBJECT,
    style: EMPTY_OBJECT,
    styles: EMPTY_OBJECT,
    toKey: toKey,
    tooltips: true
  }, theme, props, others, props.fontSizes ? {
    fontSizes: Object.assign({}, DEFAULT_FONT_SIZES, props.fontSizes)
  } : EMPTY_OBJECT);
}
function fillDefaultsG(props) {
  return fillGeneric({
    barPadding: 0.3,
    dotPadding: 0.7,
    combinations: DEFAULT_COMBINATIONS,
    combinationName: props.combinations != null && !areCombinations(props.combinations) && props.combinations.type === 'union' ? 'Union Size' : 'Intersection Size',
    barLabelOffset: 2,
    setNameAxisOffset: 'auto',
    combinationNameAxisOffset: 'auto',
    setName: 'Set Size',
    widthRatios: DEFAULT_WIDTH_RATIO,
    heightRatios: DEFAULT_HEIGHT_RATIO,
    numericScale: 'linear',
    bandScale: 'band',
    childrenFactories: EMPTY_OBJECT,
    setAddons: EMPTY_ARRAY,
    combinationAddons: EMPTY_ARRAY,
    setAddonPadding: 1,
    combinationAddonPadding: 1,
    emptySelection: true
  }, props);
}
function valueFormat(v) {
  return v.toLocaleString();
}
function fillDefaults(props) {
  return fillDefaultsG(props);
}
function fillVennDiagramDefaultsG(props) {
  return fillGeneric({
    valueFormat: valueFormat,
    layout: vennDiagramLayout
  }, props, {
    exportButtons: props.exportButtons === false ? false : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, {
      vega: false
    })
  });
}
function fillVennDiagramDefaults(props) {
  return fillVennDiagramDefaultsG(props);
}
function fillKarnaughMapDefaultsG(props) {
  return fillGeneric({
    numericScale: 'linear',
    barPadding: 0.3,
    barLabelOffset: 2,
    combinationName: 'Intersection Size',
    combinationNameAxisOffset: 'auto'
  }, props, {
    exportButtons: props.exportButtons === false ? false : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, {
      vega: false
    })
  });
}
function fillKarnaughMapDefaults(props) {
  return fillKarnaughMapDefaultsG(props);
}
function createSVG(node, toRemove) {
  var clone = node.cloneNode(true);
  clone.style.backgroundColor = getDefaultTheme(node.dataset.theme).backgroundColor;
  if (toRemove) {
    Array.from(clone.querySelectorAll(toRemove)).forEach(function (d) {
      return d.remove();
    });
  }
  return new XMLSerializer().serializeToString(clone);
}
function exportSVG(node, _ref) {
  var _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'png' : _ref$type,
      title = _ref.title,
      toRemove = _ref.toRemove;
  var b = new Blob([createSVG(node, toRemove)], {
    type: 'image/svg+xml;charset=utf-8'
  });
  var styleId = extractStyleId(node);
  var chartTitle = title !== null && title !== void 0 ? title : extractTitle(node, styleId);
  var url = URL.createObjectURL(b);
  if (type === 'svg') {
    downloadUrl(url, chartTitle + "." + type, node.ownerDocument);
    URL.revokeObjectURL(url);
    return Promise.resolve();
  }
  return toPNG(url, node).then(function (purl) {
    downloadUrl(purl, chartTitle + "." + type, node.ownerDocument);
    URL.revokeObjectURL(url);
  });
}
function toPNG(url, node) {
  var canvas = node.ownerDocument.createElement('canvas');
  var bb = node.getBoundingClientRect();
  canvas.width = bb.width;
  canvas.height = bb.height;
  var ctx = canvas.getContext('2d');
  var img = new Image(canvas.width, canvas.height);
  return new Promise(function (resolve) {
    img.onload = function () {
      ctx.drawImage(img, 0, 0);
      var png = canvas.toDataURL('image/png');
      resolve(png);
    };
    img.src = url;
  });
}
function downloadUrl(url, title, doc) {
  var a = doc.createElement('a');
  a.href = url;
  a.style.position = 'absolute';
  a.style.left = '-10000px';
  a.style.top = '-10000px';
  a.download = title;
  doc.body.appendChild(a);
  a.click();
  a.remove();
}
function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function createVegaSpec(svg, title) {
  var _ref, _svg$ownerDocument, _svg$ownerDocument$de, _svg$querySelector$da, _svg$querySelector;
  var resolveStyle = (_ref = svg.getComputedStyle || ((_svg$ownerDocument = svg.ownerDocument) === null || _svg$ownerDocument === void 0 ? void 0 : (_svg$ownerDocument$de = _svg$ownerDocument.defaultView) === null || _svg$ownerDocument$de === void 0 ? void 0 : _svg$ownerDocument$de.getComputedStyle)) !== null && _ref !== void 0 ? _ref : window.getComputedStyle;
  var styleId = extractStyleId(svg);
  var chartTitle = title !== null && title !== void 0 ? title : extractTitle(svg, styleId);
  var sets = Array.from(svg.querySelectorAll('[data-upset=sets] [data-cardinality]')).map(function (set) {
    return {
      name: set.querySelector("text.setTextStyle-" + styleId).textContent,
      cardinality: Number.parseInt(set.dataset.cardinality, 10)
    };
  }).reverse();
  var barLabelOffset = -Number.parseFloat(svg.querySelector(".sBarTextStyle-" + styleId).getAttribute('dx'));
  var color = resolveStyle(svg.querySelector(".fillPrimary-" + styleId)).fill;
  var fillNotMember = resolveStyle(svg.querySelector(".fillNotMember-" + styleId)).fill;
  var textColor = resolveStyle(svg.querySelector('text')).fill;
  var csName = svg.querySelector(".cChartTextStyle-" + styleId).textContent;
  var setName = svg.querySelector(".sChartTextStyle-" + styleId).textContent;
  var combinations = Array.from(svg.querySelectorAll('[data-upset=cs] [data-cardinality]')).map(function (set) {
    return {
      name: set.querySelector("text.hoverBarTextStyle-" + styleId).textContent,
      cardinality: Number.parseInt(set.dataset.cardinality, 10),
      sets: Array.from(set.querySelectorAll(".fillPrimary-" + styleId + " > title")).map(function (n) {
        return n.textContent;
      })
    };
  });
  var translateX = function translateX(v) {
    return Number.parseFloat(v.getAttribute('transform').match(/([\d.]+),/)[1]);
  };
  var translateY = function translateY(v) {
    return Number.parseFloat(v.getAttribute('transform').match(/,([\d.]+)/)[1]);
  };
  var base = svg.querySelector('[data-upset=base]');
  var padding = translateX(base);
  var setWidth = translateX(svg.querySelector('[data-upset=csaxis]'));
  var csWidth = Number.parseFloat(base.querySelector('g').firstElementChild.children[1].getAttribute('x2'));
  var csHeight = translateY(svg.querySelector('[data-upset=setaxis]'));
  var labelWidth = Number.parseFloat(svg.querySelector('defs rect').getAttribute('width'));
  var setHeight = Number.parseFloat(svg.querySelector('defs rect').getAttribute('height'));
  var radius = Number.parseFloat(svg.querySelector("[data-cardinality] circle.fillPrimary-" + styleId).getAttribute('r'));
  var hasPrimarySelection = svg.querySelector('[data-upset=sets-s] [data-cardinality]') != null;
  var hasQuery = svg.querySelector('[data-upset=sets-q] [data-cardinality]') != null;
  var hasSelection = hasPrimarySelection || hasQuery;
  var selectionColor = 'orange';
  if (hasSelection) {
    Array.from(svg.querySelectorAll("[data-upset=sets-" + (hasPrimarySelection ? 's]' : 'q]:first-of-type') + " [data-cardinality]")).forEach(function (elem) {
      var i = sets.length - Number.parseInt(elem.dataset.i, 10) - 1;
      sets[i].selection = Number.parseInt(elem.dataset.cardinality, 10);
    });
    Array.from(svg.querySelectorAll("[data-upset=cs-" + (hasPrimarySelection ? 's]' : 'q]:first-of-type') + " [data-cardinality]")).forEach(function (elem) {
      var i = Number.parseInt(elem.dataset.i, 10);
      combinations[i].selection = Number.parseInt(elem.dataset.cardinality, 10);
    });
    selectionColor = resolveStyle(svg.querySelector("[data-upset=sets-" + (hasPrimarySelection ? 's' : 'q') + "] [data-cardinality]")).fill;
  }
  var highlightedCombination = Number.parseInt((_svg$querySelector$da = (_svg$querySelector = svg.querySelector('[data-upset=cs-ss]')) === null || _svg$querySelector === void 0 ? void 0 : _svg$querySelector.dataset.i) !== null && _svg$querySelector$da !== void 0 ? _svg$querySelector$da : '-1', 10);
  var filter = highlightedCombination >= 0 ? {
    field: 'partOf',
    oneOf: [1, 2]
  } : {
    field: 'partOf',
    equal: 1
  };
  return {
    $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
    title: chartTitle,
    description: extractDescription(svg, styleId),
    datasets: {
      sets: sets,
      combinations: combinations.map(function (c, i) {
        return Object.assign({}, c, {
          partOf: highlightedCombination === i ? 2 : 1,
          nsets: ['']
        });
      }).concat(combinations.map(function (c) {
        return {
          name: c.name,
          cardinality: c.cardinality,
          partOf: 0,
          sets: [''],
          nsets: sets.filter(function (s) {
            return !c.sets.includes(s.name);
          }).map(function (s) {
            return s.name;
          })
        };
      }))
    },
    vconcat: [{
      hconcat: [{
        mark: 'bar',
        width: setWidth + labelWidth - 40,
        height: csHeight
      }, {
        width: csWidth,
        height: csHeight,
        data: {
          name: 'combinations'
        },
        transform: [{
          filter: filter
        }],
        layer: [{
          mark: {
            type: 'bar',
            tooltip: true
          }
        }, {
          mark: {
            type: 'text',
            align: 'center',
            baseline: 'bottom',
            dy: -barLabelOffset
          },
          encoding: {
            text: {
              field: 'cardinality',
              type: 'quantitative'
            }
          }
        }, hasSelection && {
          mark: {
            type: 'bar',
            fill: selectionColor,
            tooltip: true
          },
          encoding: {
            y: {
              field: 'selection',
              type: 'quantitative'
            }
          }
        }].filter(Boolean),
        encoding: {
          x: {
            field: 'name',
            type: 'ordinal',
            axis: null,
            sort: null
          },
          y: {
            field: 'cardinality',
            type: 'quantitative',
            axis: {
              grid: false
            },
            title: csName
          }
        }
      }]
    }, {
      hconcat: [{
        width: setWidth,
        height: setHeight,
        data: {
          name: 'sets'
        },
        layer: [{
          mark: {
            type: 'bar',
            tooltip: true
          }
        }, {
          mark: {
            type: 'text',
            align: 'right',
            baseline: 'middle',
            dx: -barLabelOffset
          },
          encoding: {
            text: {
              field: 'cardinality',
              type: 'quantitative'
            }
          }
        }, hasSelection && {
          mark: {
            type: 'bar',
            fill: selectionColor,
            tooltip: true
          },
          encoding: {
            x: {
              field: 'selection',
              type: 'quantitative'
            }
          }
        }].filter(Boolean),
        encoding: {
          y: {
            field: 'name',
            type: 'ordinal',
            axis: null,
            sort: null
          },
          x: {
            field: 'cardinality',
            type: 'quantitative',
            title: setName,
            sort: 'descending',
            axis: {
              grid: false
            }
          }
        }
      }, {
        data: {
          name: 'sets'
        },
        width: labelWidth,
        height: setHeight,
        mark: {
          type: 'text',
          align: 'center',
          baseline: 'middle',
          fontSize: Number.parseInt(resolveStyle(svg.querySelector(".setTextStyle-" + styleId)).fontSize, 10)
        },
        encoding: {
          y: {
            field: 'name',
            type: 'ordinal',
            axis: null,
            sort: null
          },
          text: {
            field: 'name',
            type: 'ordinal'
          }
        }
      }, {
        width: csWidth,
        height: setHeight,
        data: {
          name: 'combinations'
        },
        transform: [{
          flatten: ['sets'],
          as: ['has_set']
        }, {
          flatten: ['nsets'],
          as: ['has_not_set']
        }, {
          calculate: 'datum.has_set+datum.has_not_set',
          as: 'set'
        }],
        layer: [{
          mark: {
            type: 'circle',
            size: radius * radius * Math.PI,
            tooltip: true
          },
          encoding: {
            color: {
              field: 'partOf',
              type: 'nominal',
              legend: null,
              scale: {
                range: [fillNotMember, color].concat(highlightedCombination >= 0 ? [selectionColor] : [])
              }
            },
            y: {
              field: 'set',
              type: 'ordinal',
              axis: null,
              sort: null,
              scale: {
                domain: sets.map(function (s) {
                  return s.name;
                })
              }
            }
          }
        }, {
          mark: 'rule',
          transform: [{
            filter: filter
          }, {
            calculate: 'datum.sets[datum.sets.length -1]',
            as: 'set_end'
          }],
          encoding: _extends$1({
            y: {
              field: 'sets[0]',
              type: 'ordinal',
              axis: null,
              sort: null
            },
            y2: {
              field: 'set_end'
            }
          }, highlightedCombination < 0 ? {} : {
            color: {
              field: 'partOf',
              type: 'nominal',
              legend: null,
              scale: {
                range: [color, selectionColor]
              }
            }
          })
        }],
        encoding: {
          x: {
            field: 'name',
            type: 'ordinal',
            axis: null,
            sort: null
          }
        }
      }]
    }],
    config: {
      padding: padding,
      background: getDefaultTheme(svg.dataset.theme).backgroundColor,
      concat: {
        spacing: 0
      },
      view: {
        stroke: null
      },
      bar: {
        fill: color
      },
      circle: {
        opacity: 1
      },
      rule: {
        stroke: color,
        strokeWidth: Number.parseInt(resolveStyle(svg.querySelector("[data-upset=cs] [data-cardinality] line")).strokeWidth, 10)
      },
      axis: {
        labelColor: textColor,
        labelFontSize: Number.parseInt(resolveStyle(svg.querySelector(".axisTextStyle-" + styleId)).fontSize, 10),
        titleColor: textColor,
        titleFontSize: Number.parseInt(resolveStyle(svg.querySelector(".cChartTextStyle-" + styleId)).fontSize, 10)
      },
      title: {
        color: textColor
      },
      text: {
        fill: textColor,
        fontSize: Number.parseInt(resolveStyle(svg.querySelector(".sBarTextStyle-" + styleId)).fontSize, 10)
      }
    }
  };
}
function exportVegaLite(svg, _temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
      title = _ref2.title;
  var spec = createVegaSpec(svg, title);
  var url = URL.createObjectURL(new Blob([JSON.stringify(spec, null, 2)], {
    type: 'application/json'
  }));
  downloadUrl(url, spec.title + ".json", svg.ownerDocument);
  URL.revokeObjectURL(url);
}
var THEME_KEYS = ['selectionColor', 'color', 'textColor', 'hoverHintColor', 'notMemberColor', 'alternatingBackgroundColor', 'hasSelectionColor', 'hasSelectionOpacity', 'opacity', 'strokeColor', 'valueTextColor'];
var LAYOUT_KEYS = ['padding', 'barPadding', 'dotPadding', 'widthRatios', 'heightRatios'];
var STYLE_KEYS = ['fontSizes', 'combinationName', 'setName', 'barLabelOffset', 'setNameAxisOffset', 'combinationNameAxisOffset', 'theme', 'fontFamily', 'emptySelection', 'exportButtons', 'queryLegend'];
var DUMP_KEYS = ['bandScale', 'numericScale'].concat(THEME_KEYS, LAYOUT_KEYS, STYLE_KEYS);
function toDumpProps(props) {
  var _props$sets;
  var full = fillDefaults({
    width: 0,
    height: 0,
    sets: (_props$sets = props.sets) !== null && _props$sets !== void 0 ? _props$sets : [],
    combinations: props.combinations,
    theme: props.theme
  });
  var r = {};
  DUMP_KEYS.forEach(function (key) {
    var value = props[key];
    var defaultValue = full[key];
    if (key === 'theme' && value !== 'light') {
      r[key] = value;
      return;
    }
    if (value == null || value === defaultValue) {
      return;
    }
    if (key === 'fontSizes') {
      var empty = true;
      var sub = {};
      FONT_SIZES_KEYS.forEach(function (fKey) {
        var fValue = value[fKey];
        var fDefaultValue = defaultValue[fKey];
        if (fValue !== fDefaultValue) {
          sub[fKey] = fValue;
          empty = false;
        }
      });
      if (!empty) {
        r[key] = sub;
      }
    } else {
      r[key] = value;
    }
  });
  return r;
}
function toUpSetJSDump(dump, elements, props, author, mode) {
  return Object.assign({
    $schema: 'https://upset.js.org/schema.1.0.0.json',
    name: typeof props.title === 'string' ? props.title : 'UpSetJS',
    description: typeof props.description === 'string' ? props.description : '',
    mode: mode,
    author: author,
    elements: elements,
    attrs: [],
    props: toDumpProps(props)
  }, dump);
}
function toUpSetJSStaticDump(dump, props, author, mode) {
  return Object.assign({
    $schema: 'https://upset.js.org/schema-static.1.0.0.json',
    name: typeof props.title === 'string' ? props.title : 'UpSetJS',
    description: typeof props.description === 'string' ? props.description : '',
    mode: mode,
    author: author,
    props: toDumpProps(props)
  }, dump);
}
function exportDumpData(props, data, compress, mode) {
  var _props$queries$filter, _props$queries;
  if (compress === void 0) {
    compress = false;
  }
  var elems = [];
  var lookup = new Map();
  var toElemIndex = function toElemIndex(elem) {
    if (lookup.has(elem)) {
      return lookup.get(elem);
    }
    lookup.set(elem, elems.length);
    elems.push(elem);
    return elems.length - 1;
  };
  var dump = toDump({
    sets: props.sets,
    queries: (_props$queries$filter = (_props$queries = props.queries) === null || _props$queries === void 0 ? void 0 : _props$queries.filter(function (d) {
      return isElemQuery(d) || isSetQuery(d);
    })) !== null && _props$queries$filter !== void 0 ? _props$queries$filter : [],
    toElemIndex: toElemIndex,
    selection: props.selection && isSetLike(props.selection) ? props.selection : undefined,
    combinations: data.cs.v,
    combinationOptions: Array.isArray(props.combinations) ? {} : props.combinations
  }, {
    compress: compress ? 'yes' : 'no'
  });
  return toUpSetJSDump(dump, elems, props, undefined, mode);
}
function exportStaticDumpData(props, data, compress, mode) {
  var _props$queries$filter2, _props$queries2;
  if (compress === void 0) {
    compress = false;
  }
  var dump = toStaticDump({
    sets: props.sets,
    queries: (_props$queries$filter2 = (_props$queries2 = props.queries) === null || _props$queries2 === void 0 ? void 0 : _props$queries2.filter(function (d) {
      return isElemQuery(d) || isSetQuery(d);
    })) !== null && _props$queries$filter2 !== void 0 ? _props$queries$filter2 : [],
    selection: props.selection && isSetLike(props.selection) ? props.selection : undefined,
    combinations: data.cs.v
  }, {
    compress: compress ? 'yes' : 'no'
  });
  return toUpSetJSStaticDump(dump, props, undefined, mode);
}
function exportDump(svg, props, data, mode) {
  var dump = exportDumpData(props, data, false, mode);
  var url = URL.createObjectURL(new Blob([JSON.stringify(dump, null, 2)], {
    type: 'application/json'
  }));
  downloadUrl(url, dump.name + ".json", svg.ownerDocument);
  URL.revokeObjectURL(url);
}
var MAX_URL_LENGTH = 2048 * 2;
function exportSharedLink(props, data, mode) {
  var r = exportDumpData(props, data, true, mode);
  delete r.$schema;
  var arg = lzString.compressToEncodedURIComponent(JSON.stringify(r));
  var url = new URL('https://upset.js.org/app/embed.html');
  url.searchParams.set('p', arg);
  if (url.toString().length < MAX_URL_LENGTH) {
    window.open(url.toString(), '_blank');
    return true;
  }
  var r2 = exportStaticDumpData(props, data, true, mode);
  delete r2.$schema;
  var arg2 = lzString.compressToEncodedURIComponent(JSON.stringify(r2));
  url.searchParams.set('p', arg2);
  if (url.toString().length < MAX_URL_LENGTH) {
    window.open(url.toString(), '_blank');
    return true;
  }
  url.searchParams["delete"]('p');
  var w = window.open(url.toString(), '_blank');
  w === null || w === void 0 ? void 0 : w.addEventListener('load', function () {
    w === null || w === void 0 ? void 0 : w.postMessage(r, url.origin);
  });
  return false;
}
function clsx() {
  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }
  return classNames.filter(Boolean).join(' ');
}
function generateId(_args) {
  return "upset-" + Math.random().toString(36).slice(4);
}
function isSetLike$1(s) {
  return s != null && !Array.isArray(s);
}
function elemOverlapOf(query, toElemKey) {
  var f = setOverlapFactory(query, toElemKey);
  return function (s) {
    return f(s.elems).intersection;
  };
}
function generateSelectionOverlap(selection, toElemKey) {
  if (!selection) {
    return noOverlap;
  }
  if (typeof selection === 'function') {
    return selection;
  }
  if (Array.isArray(selection)) {
    return elemOverlapOf(selection, toElemKey);
  }
  var ss = selection;
  if (ss.overlap) {
    return ss.overlap.bind(ss);
  }
  var f = elemOverlapOf(ss.elems, toElemKey);
  return function (s) {
    return s.overlap ? s.overlap(ss) : f(s);
  };
}
function generateSelectionName(selection) {
  return Array.isArray(selection) ? "Array(" + selection.length + ")" : typeof selection === 'function' ? '?' : selection === null || selection === void 0 ? void 0 : selection.name;
}
function elemElemOverlapOf(query, toElemKey) {
  var f = setElemOverlapFactory(query, toElemKey);
  return function (s) {
    return f(s.elems).intersection;
  };
}
function noOverlap() {
  return 0;
}
function parseFontSize(v) {
  if (v == null) {
    return 10;
  }
  if (v.endsWith('pt')) {
    return Math.floor(4 / 3 * Number.parseInt(v, 10));
  }
  return Number.parseInt(v, 10);
}
function resolveNumericScale(factory) {
  if (factory === 'linear') {
    return linearScale;
  }
  if (factory === 'log') {
    return logScale;
  }
  return factory;
}
function resolveBandScale(factory) {
  return factory === 'band' ? bandScale : factory;
}
function areCombinations$1(combinations) {
  return Array.isArray(combinations);
}
function deriveDataDependent(sets, combinations, sizes, numericScale, bandScale, barLabelFontSize, dotPadding, barPadding, tickFontSize, toKey, toElemKey, id) {
  var numericScaleFactory = resolveNumericScale(numericScale);
  var bandScaleFactory = resolveBandScale(bandScale);
  var cs = areCombinations$1(combinations) ? combinations : generateCombinations(sets, Object.assign({
    toElemKey: toElemKey
  }, DEFAULT_COMBINATIONS, combinations));
  var csKeys = cs.map(toKey);
  var combinationX = bandScaleFactory(csKeys, sizes.cs.w, sizes.padding);
  var maxCSCardinality = cs.reduce(function (acc, d) {
    return Math.max(acc, d.cardinality);
  }, 0);
  var combinationY = numericScaleFactory(maxCSCardinality, [sizes.cs.h, barLabelFontSize], {
    orientation: 'vertical',
    fontSizeHint: tickFontSize
  });
  var guessLabelWidth = function guessLabelWidth(v) {
    return Math.floor(barLabelFontSize / 1.4 * 0.7 * combinationY.tickFormat()(v).length);
  };
  var maxSetCardinality = sets.reduce(function (acc, d) {
    return Math.max(acc, d.cardinality);
  }, 0);
  var largestSetLabelWidth = guessLabelWidth(maxSetCardinality);
  var largestCSLabelWidth = guessLabelWidth(maxCSCardinality);
  var setX = numericScaleFactory(maxSetCardinality, [sizes.sets.w, largestSetLabelWidth], {
    orientation: 'horizontal',
    fontSizeHint: tickFontSize
  });
  var setKeys = sets.map(toKey);
  var setY = bandScaleFactory(setKeys.slice().reverse(), sizes.sets.h, sizes.padding);
  var r = Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2 * dotPadding;
  var triangleSize = Math.max(2, Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2 * barPadding);
  return {
    id: id ? id : generateId(),
    r: r,
    triangleSize: triangleSize,
    sets: {
      v: sets,
      keys: setKeys,
      rv: sets.slice().reverse(),
      x: setX,
      xAxisWidth: sizes.sets.w - largestSetLabelWidth,
      y: function y(s) {
        return setY(toKey(s));
      },
      bandWidth: setY.bandwidth(),
      cy: setY.bandwidth() / 2 + sizes.cs.h,
      format: setX.tickFormat(),
      labelOffset: barLabelFontSize + 9 + 2
    },
    cs: {
      v: cs,
      keys: cs.map(toKey),
      x: function x(s) {
        return combinationX(toKey(s));
      },
      y: combinationY,
      yAxisWidth: sizes.cs.h - barLabelFontSize,
      cx: combinationX.bandwidth() / 2,
      bandWidth: combinationX.bandwidth(),
      format: combinationY.tickFormat(),
      has: function has(v, s) {
        var sk = toKey(s);
        return Array.from(v.sets).some(function (ss) {
          return toKey(ss) === sk;
        });
      },
      labelOffset: largestCSLabelWidth + 9 + 6
    },
    toKey: toKey,
    toElemKey: toElemKey
  };
}
function deriveSizeDependent(width, height, margin, barPadding, widthRatios, heightRatios, setAddons, combinationAddons, id, setAddonPadding, combinationAddonPadding) {
  var setAddonsBefore = setAddons.reduce(function (acc, a) {
    return acc + (a.position === 'before' ? a.size + setAddonPadding : 0);
  }, 0);
  var setAddonsAfter = setAddons.reduce(function (acc, a) {
    return acc + (a.position !== 'before' ? a.size + setAddonPadding : 0);
  }, 0);
  var combinationAddonsBefore = combinationAddons.reduce(function (acc, a) {
    return acc + (a.position === 'before' ? a.size + setAddonPadding : 0);
  }, 0);
  var combinationAddonsAfter = combinationAddons.reduce(function (acc, a) {
    return acc + (a.position !== 'before' ? a.size + setAddonPadding : 0);
  }, 0);
  var h = height - 2 * margin - 20 - combinationAddonsAfter - combinationAddonsBefore;
  var w = width - 2 * margin - setAddonsBefore - setAddonsAfter;
  var setWidth = w * widthRatios[0];
  var labelsWidth = w * widthRatios[1];
  var combinationHeight = h * heightRatios[0];
  return {
    id: id ? id : generateId(),
    cs: {
      before: combinationAddonsBefore,
      after: combinationAddonsAfter,
      x: setAddonsBefore + setWidth + labelsWidth,
      y: combinationAddonsBefore,
      w: w - setWidth - labelsWidth,
      h: combinationHeight,
      addons: combinationAddons,
      addonPadding: combinationAddonPadding
    },
    labels: {
      x: setAddonsBefore + setWidth,
      y: combinationAddonsBefore + combinationHeight,
      w: labelsWidth,
      h: h - combinationHeight
    },
    sets: {
      before: setAddonsBefore,
      after: setAddonsAfter,
      x: setAddonsBefore,
      y: combinationAddonsBefore + combinationHeight,
      w: setWidth,
      h: h - combinationHeight,
      addons: setAddons,
      addonPadding: setAddonPadding
    },
    padding: barPadding,
    legend: {
      x: width / 2
    },
    margin: margin,
    w: width,
    h: height
  };
}
function deriveStyleDependent(theme, styles, classNames, combinationName, combinationNameAxisOffset, setName, setNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips) {
  return {
    theme: theme,
    styles: styles,
    classNames: classNames,
    cs: {
      name: combinationName,
      offset: combinationNameAxisOffset
    },
    sets: {
      name: setName,
      offset: setNameAxisOffset
    },
    emptySelection: emptySelection,
    id: styleId,
    barLabelOffset: barLabelOffset,
    selectionColor: selectionColor,
    title: title,
    description: description,
    tooltips: tooltips
  };
}
function ExportButtons(_ref) {
  var transform = _ref.transform,
      styleId = _ref.styleId,
      exportButtons = _ref.exportButtons,
      exportChart = _ref.exportChart;
  if (!exportButtons) {
    return null;
  }
  var svgWidth = 26;
  var pngWidth = 26;
  var vegaWidth = 34;
  var dumpWidth = 34;
  var shareWidth = 42;
  var space = 2;
  var acc = 0;
  var buttons = [];
  if (exportButtons === true || exportButtons.svg !== false) {
    acc += svgWidth;
    buttons.push(React.createElement("g", {
      key: "svg",
      className: "exportButton-" + styleId,
      onClick: exportChart,
      "data-type": "svg",
      transform: "translate(-" + acc + ", 0)"
    }, React.createElement("title", null, "Download SVG Image"), React.createElement("rect", {
      y: -9,
      width: svgWidth,
      height: 11,
      rx: 2,
      ry: 2
    }), React.createElement("text", {
      className: "exportTextStyle-" + styleId,
      x: svgWidth / 2
    }, "SVG")));
    acc += space;
  }
  if (exportButtons === true || exportButtons.png !== false) {
    acc += pngWidth;
    buttons.push(React.createElement("g", {
      key: "png",
      className: "exportButton-" + styleId,
      onClick: exportChart,
      "data-type": "png",
      transform: "translate(-" + acc + ", 0)"
    }, React.createElement("title", null, "Download PNG Image"), React.createElement("rect", {
      y: -9,
      width: pngWidth,
      height: 11,
      rx: 2,
      ry: 2
    }), React.createElement("text", {
      className: "exportTextStyle-" + styleId,
      x: pngWidth / 2
    }, "PNG")));
    acc += space;
  }
  if (exportButtons === true || exportButtons.vega !== false) {
    acc += vegaWidth;
    buttons.push(React.createElement("g", {
      key: "vega",
      className: "exportButton-" + styleId,
      onClick: exportChart,
      "data-type": "vega",
      transform: "translate(-" + acc + ", 0)"
    }, React.createElement("title", null, "Download VEGA-Lite Specification"), React.createElement("rect", {
      y: -9,
      width: vegaWidth,
      height: 11,
      rx: 2,
      ry: 2
    }), React.createElement("text", {
      className: "exportTextStyle-" + styleId,
      x: vegaWidth / 2
    }, "VEGA")));
    acc += space;
  }
  if (exportButtons === true || exportButtons.dump !== false) {
    acc += dumpWidth;
    buttons.push(React.createElement("g", {
      key: "dump",
      className: "exportButton-" + styleId,
      onClick: exportChart,
      "data-type": "dump",
      transform: "translate(-" + acc + ", 0)"
    }, React.createElement("title", null, "Download UpSet.js JSON Dump"), React.createElement("rect", {
      y: -9,
      width: dumpWidth,
      height: 11,
      rx: 2,
      ry: 2
    }), React.createElement("text", {
      className: "exportTextStyle-" + styleId,
      x: dumpWidth / 2
    }, "DUMP")));
    acc += space;
  }
  if (exportButtons === true || exportButtons.share !== false) {
    acc += shareWidth;
    buttons.push(React.createElement("g", {
      key: "share",
      className: "exportButton-" + styleId,
      onClick: exportChart,
      "data-type": "share",
      transform: "translate(-" + acc + ", 0)"
    }, React.createElement("title", null, "Open a shareable URL"), React.createElement("rect", {
      y: -9,
      width: shareWidth,
      height: 11,
      rx: 2,
      ry: 2
    }), React.createElement("text", {
      className: "exportTextStyle-" + styleId,
      x: shareWidth / 2
    }, "SHARE")));
    acc += space;
  }
  return React.createElement("g", {
    className: "exportButtons-" + styleId,
    transform: transform
  }, buttons);
}
var QueryLegend = React.memo(function QueryLegend(_ref) {
  var queries = _ref.queries,
      x = _ref.x,
      style = _ref.style,
      data = _ref.data;
  return React.createElement("text", {
    transform: "translate(" + x + ",4)",
    style: style.styles.legend,
    className: clsx("legendTextStyle-" + style.id, style.classNames.legend)
  }, queries.map(function (q, i) {
    var count = null;
    if (isSetQuery(q)) {
      count = q.set.cardinality;
    } else if (isElemQuery(q)) {
      count = q.elems instanceof Set ? q.elems.size : q.elems.length;
    }
    return React.createElement(React.Fragment, {
      key: q.name
    }, React.createElement("tspan", {
      className: "fillQ" + i + "-" + data.id
    }, '  ⬤ '), React.createElement("tspan", null, q.name, count != null ? ": " + data.sets.format(count) : ''));
  }));
});
var HorizontalTick = React.memo(function HorizontalTick(_ref) {
  var pos = _ref.pos,
      spacing = _ref.spacing,
      tickSizeInner = _ref.tickSizeInner,
      orient = _ref.orient,
      name = _ref.name,
      style = _ref.style;
  var k = orient === 'top' || orient === 'left' ? -1 : 1;
  return React.createElement("g", {
    transform: "translate(0, " + (pos + 0.5) + ")"
  }, name && React.createElement("text", {
    x: k * spacing,
    dy: '0.32em',
    className: clsx("axisTextStyle-" + style.id, orient === 'right' ? "startText-" + style.id : "endText-" + style.id, style.classNames.axisTick),
    style: style.styles.axisTick
  }, name), React.createElement("line", {
    x2: k * tickSizeInner,
    className: "axisLine-" + style.id
  }));
});
var VerticalTick = React.memo(function VerticalTick(_ref2) {
  var pos = _ref2.pos,
      name = _ref2.name,
      spacing = _ref2.spacing,
      orient = _ref2.orient,
      tickSizeInner = _ref2.tickSizeInner,
      style = _ref2.style;
  var k = orient === 'top' || orient === 'left' ? -1 : 1;
  return React.createElement("g", {
    transform: "translate(" + (pos + 0.5) + ", 0)"
  }, name && React.createElement("text", {
    y: k * spacing,
    dy: orient === 'top' ? '0em' : '0.71em',
    className: clsx("axisTextStyle-" + style.id, style.classNames.axisTick),
    style: style.styles.axisTick
  }, name), React.createElement("line", {
    y2: k * tickSizeInner,
    className: "axisLine-" + style.id
  }));
});
function Axis(_ref3) {
  var scale = _ref3.scale,
      orient = _ref3.orient,
      _ref3$tickSizeInner = _ref3.tickSizeInner,
      tickSizeInner = _ref3$tickSizeInner === void 0 ? 6 : _ref3$tickSizeInner,
      _ref3$tickSizeOuter = _ref3.tickSizeOuter,
      tickSizeOuter = _ref3$tickSizeOuter === void 0 ? 6 : _ref3$tickSizeOuter,
      _ref3$tickPadding = _ref3.tickPadding,
      tickPadding = _ref3$tickPadding === void 0 ? 3 : _ref3$tickPadding,
      size = _ref3.size,
      start = _ref3.start,
      style = _ref3.style,
      transform = _ref3.transform;
  var spacing = Math.max(tickSizeInner, 0) + tickPadding;
  var range0 = start;
  var range1 = size;
  var k = orient === 'top' || orient === 'left' ? -1 : 1;
  var Tick = orient === 'left' || orient === 'right' ? HorizontalTick : VerticalTick;
  var values = scale.ticks().map(function (d) {
    return typeof d === 'number' ? {
      value: d,
      label: String(d)
    } : d;
  });
  return React.createElement("g", {
    transform: transform
  }, values.map(function (d) {
    return React.createElement(Tick, {
      key: d.value,
      pos: scale(d.value),
      name: d.label,
      spacing: spacing,
      tickSizeInner: tickSizeInner,
      orient: orient,
      style: style
    });
  }), React.createElement("path", {
    className: "axisLine-" + style.id,
    d: orient === 'left' || orient === 'right' ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1
  }));
}
var MultilineText = React.memo(function MultilineText(_ref) {
  var width = _ref.width,
      text = _ref.text,
      dy = _ref.dy,
      x = _ref.x,
      style = _ref.style,
      className = _ref.className;
  var ref = d$1(null);
  var _useState = m$1(typeof text === 'string' ? [text] : []),
      lines = _useState[0],
      setLines = _useState[1];
  y$1(function () {
    if (typeof text === 'string') {
      setLines([text]);
    } else {
      setLines([]);
    }
  }, [text]);
  y$1(function () {
    if (!ref.current || ref.current.childElementCount > 0 || typeof text !== 'string') {
      return;
    }
    var len = ref.current.getComputedTextLength();
    var lines = [];
    var lineWidth = width;
    var start = 0;
    var p = ref.current.getStartPositionOfChar(0);
    while (len > lineWidth) {
      p.x = lineWidth;
      var num = ref.current.getCharNumAtPosition(p);
      var space = text.lastIndexOf(' ', num);
      if (space < start) {
        break;
      }
      lines.push(text.slice(start, space + 1));
      var used = ref.current.getEndPositionOfChar(space + 1).x;
      start = space + 1;
      lineWidth = used + width;
    }
    lines.push(text.slice(start));
    setLines(lines);
  }, [ref, text, width]);
  if (!text) {
    return null;
  }
  return React.createElement("tspan", {
    ref: ref,
    dy: dy,
    style: style,
    x: x,
    className: className
  }, lines.length > 1 ? lines.map(function (l, i) {
    return React.createElement("tspan", {
      key: l,
      x: 0,
      dy: i > 0 ? '1.2em' : dy
    }, l);
  }) : text);
});
var UpSetTitle = React.memo(function UpSetTitle(_ref2) {
  var width = _ref2.width,
      _ref2$descriptionWidt = _ref2.descriptionWidth,
      descriptionWidth = _ref2$descriptionWidt === void 0 ? width : _ref2$descriptionWidt,
      style = _ref2.style;
  if (!style.title && !style.description) {
    return null;
  }
  return React.createElement("text", null, React.createElement(MultilineText, {
    text: style.title,
    width: width,
    dy: "10px",
    className: clsx("titleTextStyle-" + style.id, style.classNames.title),
    style: style.styles.title
  }), React.createElement(MultilineText, {
    x: 0,
    width: descriptionWidth,
    dy: style.title ? '2em' : '10px',
    text: style.description,
    className: clsx("descTextStyle-" + style.id, style.classNames.description),
    style: style.styles.description
  }));
});
function noop() {
  return undefined;
}
function wrap(f) {
  if (!f) {
    return noop;
  }
  return function (set, addons) {
    return function (evt) {
      return f.call(this, set, evt.nativeEvent, addons.map(function (a) {
        return a.createOnHandlerData ? a.createOnHandlerData(set) : null;
      }));
    };
  };
}
function addonPositionGenerator(total, padding) {
  var beforeAcc = 0;
  var afterAcc = 0;
  return function (addon) {
    var x = 0;
    if (addon.position === 'before') {
      beforeAcc += addon.size + padding;
      x = -beforeAcc;
    } else {
      x = total + afterAcc + padding;
      afterAcc += addon.size + padding;
    }
    return x;
  };
}
function mergeColor(style, color, prop) {
  var _Object$assign;
  if (prop === void 0) {
    prop = 'fill';
  }
  if (!color) {
    return style;
  }
  if (!style) {
    var _ref;
    return !color ? undefined : (_ref = {}, _ref[prop] = color, _ref);
  }
  return Object.assign((_Object$assign = {}, _Object$assign[prop] = color, _Object$assign), style);
}
var UpSetAxis = React.memo(function UpSetAxis(_ref) {
  var size = _ref.size,
      style = _ref.style,
      data = _ref.data;
  var setPosGen = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);
  var combinationPosGen = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);
  var csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;
  var setNameOffset = style.sets.offset === 'auto' ? data.sets.labelOffset : style.sets.offset;
  return React.createElement("g", null, React.createElement(UpSetTitle, {
    style: style,
    width: size.cs.x - csNameOffset - 20
  }), React.createElement("g", {
    transform: "translate(" + size.cs.x + "," + size.cs.y + ")",
    "data-upset": "csaxis"
  }, React.createElement(Axis, {
    scale: data.cs.y,
    orient: "left",
    size: size.cs.h,
    start: size.cs.h - data.cs.yAxisWidth,
    style: style
  }), React.createElement("line", {
    x1: 0,
    x2: size.cs.w,
    y1: size.cs.h + 1,
    y2: size.cs.h + 1,
    className: "axisLine-" + style.id
  }), React.createElement("text", {
    className: clsx("cChartTextStyle-" + style.id, style.classNames.chartLabel),
    style: style.styles.chartLabel,
    transform: "translate(" + -csNameOffset + ", " + size.cs.h / 2 + ")rotate(-90)"
  }, style.cs.name), size.cs.addons.map(function (addon) {
    return React.createElement("text", {
      key: addon.name,
      className: clsx("cChartTextStyle-" + style.id, style.classNames.chartLabel),
      style: style.styles.chartLabel,
      transform: "translate(" + -csNameOffset + ", " + (combinationPosGen(addon) + addon.size / 2) + ")rotate(-90)"
    }, addon.name);
  })), React.createElement("g", {
    transform: "translate(" + size.sets.x + "," + size.sets.y + ")",
    "data-upset": "setaxis"
  }, React.createElement(Axis, {
    scale: data.sets.x,
    orient: "bottom",
    size: size.sets.w,
    start: size.sets.w - data.sets.xAxisWidth,
    transform: "translate(0, " + size.sets.h + ")",
    style: style
  }), React.createElement("text", {
    className: clsx("sChartTextStyle-" + style.id, style.classNames.chartLabel),
    style: style.styles.chartLabel,
    transform: "translate(" + size.sets.w / 2 + ", " + (size.sets.h + setNameOffset) + ")"
  }, style.sets.name), size.sets.addons.map(function (addon) {
    return React.createElement("text", {
      key: addon.name,
      className: clsx("sChartTextStyle-" + style.id, style.classNames.chartLabel),
      style: style.styles.chartLabel,
      transform: "translate(" + (setPosGen(addon) + addon.size / 2) + ", " + (size.sets.h + setNameOffset) + ")"
    }, addon.name);
  })));
});
var UpSetDot = React.memo(function UpSetDot(_ref) {
  var cx = _ref.cx,
      r = _ref.r,
      cy = _ref.cy,
      name = _ref.name,
      className = _ref.className,
      style = _ref.style,
      fill = _ref.fill;
  return React.createElement("circle", {
    r: r,
    cx: cx,
    cy: cy,
    className: className,
    style: mergeColor(style, fill)
  }, name && React.createElement("title", null, name));
});
var CombinationChart = React.memo(function CombinationChart(_ref) {
  var d = _ref.d,
      h = _ref.h,
      className = _ref.className,
      data = _ref.data,
      size = _ref.size,
      style = _ref.style,
      children = _ref.children;
  var y = data.cs.y(d.cardinality);
  var genPosition = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);
  return React.createElement("g", {
    transform: "translate(" + data.cs.x(d) + ", 0)",
    onMouseEnter: h.onMouseEnter(d, size.cs.addons),
    onMouseLeave: h.onMouseLeave,
    onClick: h.onClick(d, size.cs.addons),
    onContextMenu: h.onContextMenu(d, size.cs.addons),
    onMouseMove: h.onMouseMove(d, size.cs.addons),
    className: className,
    "data-cardinality": d.cardinality
  }, style.tooltips && React.createElement("title", null, d.name, ": ", data.cs.format(d.cardinality)), React.createElement("rect", {
    y: -size.cs.before,
    width: data.cs.bandWidth,
    height: size.sets.h + size.cs.h + size.cs.before + size.cs.after,
    className: "hoverBar-" + style.id
  }), React.createElement("rect", {
    y: y,
    height: size.cs.h - y,
    width: data.cs.bandWidth,
    className: clsx("fillPrimary-" + style.id, style.classNames.bar),
    style: mergeColor(style.styles.bar, d.color)
  }), React.createElement("text", {
    y: y - style.barLabelOffset,
    x: data.cs.bandWidth / 2,
    style: style.styles.barLabel,
    className: clsx("cBarTextStyle-" + style.id, style.classNames.barLabel)
  }, data.cs.format(d.cardinality)), React.createElement("text", {
    y: -style.barLabelOffset - size.cs.before,
    x: data.cs.bandWidth / 2,
    style: style.styles.barLabel,
    className: clsx("hoverBarTextStyle-" + style.id, style.classNames.barLabel)
  }, d.name), data.sets.v.map(function (s, i) {
    var has = data.cs.has(d, s);
    return React.createElement(UpSetDot, {
      key: data.sets.keys[i],
      r: data.r,
      cx: data.cs.cx,
      cy: data.sets.y(s) + data.sets.cy,
      name: style.tooltips ? has ? s.name : d.name : '',
      style: style.styles.dot,
      fill: has ? d.color : undefined,
      className: clsx(has ? "fillPrimary-" + style.id : "fillNotMember-" + style.id, style.classNames.dot)
    });
  }), d.sets.size > 1 && React.createElement("line", {
    x1: data.cs.cx,
    y1: data.sets.y(data.sets.v.find(function (p) {
      return data.cs.has(d, p);
    })) + data.sets.cy,
    x2: data.cs.cx,
    y2: data.sets.y(data.sets.rv.find(function (p) {
      return data.cs.has(d, p);
    })) + data.sets.cy,
    style: d.color ? {
      stroke: d.color
    } : undefined,
    className: "upsetLine-" + data.id
  }), size.cs.addons.map(function (addon) {
    return React.createElement("g", {
      key: addon.name,
      transform: "translate(0," + genPosition(addon) + ")"
    }, addon.render({
      set: d,
      width: data.cs.bandWidth,
      height: addon.size,
      theme: style.theme
    }));
  }), children);
});
var SetChart = React.memo(function SetChart(_ref) {
  var d = _ref.d,
      i = _ref.i,
      h = _ref.h,
      className = _ref.className,
      size = _ref.size,
      data = _ref.data,
      style = _ref.style,
      children = _ref.children;
  var x = data.sets.x(d.cardinality);
  var genPosition = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);
  return React.createElement("g", {
    transform: "translate(0, " + data.sets.y(d) + ")",
    onMouseEnter: h.onMouseEnter(d, size.sets.addons),
    onMouseLeave: h.onMouseLeave,
    onClick: h.onClick(d, size.sets.addons),
    onContextMenu: h.onContextMenu(d, size.sets.addons),
    onMouseMove: h.onMouseMove(d, size.sets.addons),
    className: className,
    "data-cardinality": d.cardinality
  }, style.tooltips && React.createElement("title", null, d.name, ": ", data.sets.format(d.cardinality)), React.createElement("rect", {
    x: -size.sets.before,
    width: size.sets.w + size.labels.w + size.cs.w + size.sets.after,
    height: data.sets.bandWidth,
    className: "hoverBar-" + style.id
  }), i % 2 === 1 && React.createElement("rect", {
    x: size.sets.w,
    width: size.labels.w + size.cs.w + size.sets.after,
    height: data.sets.bandWidth,
    className: "fillAlternating-" + style.id
  }), React.createElement("rect", {
    x: x,
    width: size.sets.w - x,
    height: data.sets.bandWidth,
    className: clsx("fillPrimary-" + style.id, style.classNames.bar),
    style: mergeColor(style.styles.bar, d.color)
  }), React.createElement("text", {
    x: x,
    dx: -style.barLabelOffset,
    y: data.sets.bandWidth / 2,
    style: style.styles.barLabel,
    className: clsx("sBarTextStyle-" + style.id, style.classNames.barLabel)
  }, data.sets.format(d.cardinality)), React.createElement("text", {
    x: size.sets.w + size.labels.w / 2,
    y: data.sets.bandWidth / 2,
    className: clsx("setTextStyle-" + style.id, style.classNames.setLabel),
    style: style.styles.setLabel,
    clipPath: "url(#clip-" + size.id + ")"
  }, d.name), size.sets.addons.map(function (addon) {
    return React.createElement("g", {
      key: addon.name,
      transform: "translate(" + genPosition(addon) + ",0)"
    }, addon.render({
      set: d,
      width: addon.size,
      height: data.sets.bandWidth,
      theme: style.theme
    }));
  }), children);
});
var UpSetChart = React.memo(function UpSetChart(_ref) {
  var data = _ref.data,
      size = _ref.size,
      style = _ref.style,
      h = _ref.h,
      setChildrenFactory = _ref.setChildrenFactory,
      combinationChildrenFactory = _ref.combinationChildrenFactory;
  return React.createElement("g", {
    className: h.hasClick ? "clickAble-" + style.id : undefined
  }, React.createElement("g", {
    transform: "translate(" + size.sets.x + "," + size.sets.y + ")",
    "data-upset": "sets"
  }, data.sets.v.map(function (d, i) {
    return React.createElement(SetChart, {
      key: data.sets.keys[i],
      d: d,
      i: i,
      h: h,
      className: h.hasClick || h.hasHover ? "interactive-" + style.id : undefined,
      data: data,
      style: style,
      size: size
    }, setChildrenFactory && setChildrenFactory(d));
  })), React.createElement("g", {
    transform: "translate(" + size.cs.x + "," + size.cs.y + ")",
    "data-upset": "cs"
  }, data.cs.v.map(function (d, i) {
    return React.createElement(CombinationChart, {
      key: data.cs.keys[i],
      d: d,
      h: h,
      className: h.hasClick || h.hasHover ? "interactive-" + style.id : undefined,
      data: data,
      style: style,
      size: size
    }, combinationChildrenFactory && combinationChildrenFactory(d));
  })));
});
function CombinationSelectionChart(_ref) {
  var data = _ref.data,
      size = _ref.size,
      style = _ref.style,
      elemOverlap = _ref.elemOverlap,
      secondary = _ref.secondary,
      tooltip = _ref.tooltip,
      suffix = _ref.suffix,
      transform = _ref.transform,
      empty = _ref.empty,
      combinationAddons = _ref.combinationAddons;
  var width = data.cs.bandWidth;
  var totalHeight = size.cs.h + size.sets.h;
  var height = size.cs.h;
  var className = clsx("fill" + suffix, !tooltip && "pnone-" + style.id, style.classNames.bar);
  return React.createElement("g", {
    transform: transform,
    "data-upset": secondary ? 'cs-q' : 'cs-s'
  }, data.cs.v.map(function (d, i) {
    var x = data.cs.x(d);
    var key = data.cs.keys[i];
    if (empty && !secondary) {
      return React.createElement("rect", {
        key: key,
        x: x,
        y: height,
        height: 0,
        width: width,
        className: className,
        style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
      }, tooltip && React.createElement("title", null));
    }
    var o = elemOverlap(d);
    if (o === 0) {
      return null;
    }
    var y = data.cs.y(o);
    var title = tooltip && React.createElement("title", null, d.name + " \u2229 " + tooltip + ": " + o);
    var content = secondary ? React.createElement("path", {
      key: key,
      transform: "translate(" + x + ", " + y + ")",
      d: "M0,-1 l" + width + ",0 l0,2 l" + -width + ",0 L-" + data.triangleSize + ",-" + data.triangleSize + " L-" + data.triangleSize + "," + data.triangleSize + " Z",
      className: className,
      "data-i": i,
      "data-cardinality": o,
      style: mergeColor(undefined, !style.selectionColor ? d.color : undefined)
    }, title) : React.createElement("rect", {
      key: key,
      x: x,
      y: y,
      height: height - y,
      "data-i": i,
      "data-cardinality": o,
      width: width,
      className: className,
      style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
    }, title);
    var genPosition = addonPositionGenerator(totalHeight, size.cs.addonPadding);
    var addons = combinationAddons.map(function (addon) {
      var v = genPosition(addon);
      var content = addon.render({
        set: d,
        width: width,
        height: addon.size,
        theme: style.theme
      });
      if (!content) {
        return null;
      }
      return React.createElement("g", {
        key: addon.name,
        transform: "translate(" + x + "," + v + ")"
      }, content);
    }).filter(Boolean);
    if (addons.length === 0) {
      return content;
    }
    return React.createElement("g", {
      key: key
    }, content, addons);
  }));
}
function SetSelectionChart(_ref) {
  var data = _ref.data,
      size = _ref.size,
      style = _ref.style,
      elemOverlap = _ref.elemOverlap,
      suffix = _ref.suffix,
      secondary = _ref.secondary,
      empty = _ref.empty,
      tooltip = _ref.tooltip,
      setAddons = _ref.setAddons,
      transform = _ref.transform;
  var width = size.sets.w;
  var totalWidth = size.sets.w + size.labels.w + size.cs.w;
  var height = data.sets.bandWidth;
  var className = clsx("fill" + suffix, !tooltip && " pnone-" + style.id, style.classNames.bar);
  return React.createElement("g", {
    transform: transform,
    "data-upset": secondary ? 'sets-q' : 'sets-s'
  }, data.sets.v.map(function (d, i) {
    var y = data.sets.y(d);
    var key = data.sets.keys[i];
    if (empty && !secondary) {
      return React.createElement("rect", {
        key: key,
        x: width,
        y: y,
        width: 0,
        height: height,
        className: className,
        style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
      }, style.tooltips && tooltip && React.createElement("title", null));
    }
    var o = elemOverlap(d);
    if (o === 0) {
      return null;
    }
    var x = data.sets.x(o);
    var title = style.tooltips && tooltip && React.createElement("title", null, d.name + " \u2229 " + tooltip + ": " + o);
    var content = secondary ? React.createElement("path", {
      key: key,
      transform: "translate(" + x + ", " + (y + height) + ")",
      d: "M1,0 l0," + -height + " l-2,0 l0," + height + " L-" + data.triangleSize + "," + data.triangleSize + " L" + data.triangleSize + "," + data.triangleSize + " Z",
      "data-i": i,
      "data-cardinality": o,
      className: className,
      style: mergeColor(undefined, !style.selectionColor ? d.color : undefined)
    }, title) : React.createElement("rect", {
      key: key,
      "data-i": i,
      "data-cardinality": o,
      x: x,
      y: y,
      width: width - x,
      height: height,
      className: className,
      style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
    }, title);
    var genPosition = addonPositionGenerator(totalWidth, size.sets.addonPadding);
    var addons = setAddons.map(function (addon) {
      var v = genPosition(addon);
      var content = addon.render({
        set: d,
        width: addon.size,
        height: height,
        theme: style.theme
      });
      if (!content) {
        return null;
      }
      return React.createElement("g", {
        key: addon.name,
        transform: "translate(" + v + "," + y + ")"
      }, content);
    }).filter(Boolean);
    if (addons.length === 0) {
      return content;
    }
    return React.createElement("g", {
      key: key
    }, content, addons);
  }));
}
var EMPTY_ARRAY$1 = [];
var UpSetQueries = React.memo(function UpSetQueries(_ref) {
  var size = _ref.size,
      data = _ref.data,
      style = _ref.style,
      hasHover = _ref.hasHover,
      secondary = _ref.secondary,
      queries = _ref.queries;
  var someAddon = size.sets.addons.some(function (s) {
    return s.renderQuery != null;
  }) || size.cs.addons.some(function (s) {
    return s.renderQuery != null;
  });
  var qs = h$1(function () {
    return queries.map(function (q) {
      return _extends$1({}, q, {
        overlap: queryOverlap(q, 'intersection', data.toElemKey),
        elemOverlap: someAddon ? queryElemOverlap(q, 'intersection', data.toElemKey) : null
      });
    });
  }, [queries, someAddon, data.toElemKey]);
  function wrapAddon(addon, query, index, overlapper, secondary) {
    return _extends$1({}, addon, {
      render: function render(props) {
        var overlap = overlapper(props.set);
        return addon.renderQuery ? addon.renderQuery(_extends$1({
          query: query,
          overlap: overlap,
          index: index,
          secondary: secondary
        }, props)) : null;
      }
    });
  }
  return React.createElement("g", {
    className: hasHover && !secondary ? "pnone-" + style.id : undefined
  }, React.createElement("g", {
    transform: "translate(" + size.sets.x + "," + size.sets.y + ")"
  }, qs.map(function (q, i) {
    return React.createElement(SetSelectionChart, {
      key: q.name,
      data: data,
      size: size,
      style: style,
      elemOverlap: q.overlap,
      suffix: "Q" + i + "-" + data.id,
      secondary: secondary || i > 0,
      tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name,
      setAddons: size.sets.addons.length === 0 ? EMPTY_ARRAY$1 : size.sets.addons.map(function (a, i) {
        return wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0);
      })
    });
  })), React.createElement("g", {
    transform: "translate(" + size.cs.x + "," + size.cs.y + ")"
  }, qs.map(function (q, i) {
    return React.createElement(CombinationSelectionChart, {
      key: q.name,
      data: data,
      size: size,
      style: style,
      elemOverlap: q.overlap,
      suffix: "Q" + i + "-" + data.id,
      secondary: secondary || i > 0,
      tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name,
      combinationAddons: size.cs.addons.length === 0 ? EMPTY_ARRAY$1 : size.cs.addons.map(function (a, i) {
        return wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0);
      })
    });
  })));
});
function LabelsSelection(_ref) {
  var data = _ref.data,
      size = _ref.size,
      style = _ref.style,
      selection = _ref.selection;
  if (!selection || selection.type !== 'set' || !data.sets.keys.includes(data.toKey(selection))) {
    return null;
  }
  var d = selection;
  return React.createElement("rect", {
    y: data.sets.y(d),
    width: size.labels.w + size.cs.w + size.sets.after,
    height: data.sets.bandWidth,
    className: "selectionHint-" + style.id
  });
}
function UpSetSelectionChart(_ref) {
  var data = _ref.data,
      size = _ref.size,
      style = _ref.style,
      selection = _ref.selection;
  var cy = data.sets.bandWidth / 2;
  var cx = data.cs.cx;
  var r = data.r;
  var height = size.sets.h + size.sets.after;
  var width = data.cs.bandWidth;
  if (!selection || selection.type === 'set' || !data.cs) {
    return null;
  }
  var d = selection;
  var index = data.cs.keys.indexOf(data.toKey(d));
  if (index < 0) {
    return null;
  }
  return React.createElement("g", {
    transform: "translate(" + (size.labels.w + data.cs.x(d)) + ", 0)",
    "data-upset": "cs-ss",
    "data-i": index
  }, React.createElement("rect", {
    width: width,
    height: height,
    className: "selectionHint-" + style.id
  }), data.sets.v.filter(function (s) {
    return data.cs.has(d, s);
  }).map(function (s) {
    return React.createElement(UpSetDot, {
      key: data.toKey(s),
      r: r * 1.1,
      cx: cx,
      cy: data.sets.y(s) + cy,
      name: style.tooltips ? s.name : '',
      className: clsx("fillSelection-" + style.id, "pnone-" + style.id, style.classNames.dot),
      style: mergeColor(style.styles.dot, !style.selectionColor ? d.color : undefined)
    });
  }), d.sets.size > 1 && React.createElement("line", {
    x1: cx,
    y1: data.sets.y(data.sets.v.find(function (p) {
      return data.cs.has(d, p);
    })) + cy,
    x2: cx,
    y2: data.sets.y(data.sets.rv.find(function (p) {
      return data.cs.has(d, p);
    })) + cy,
    className: "upsetSelectionLine-" + data.id,
    style: mergeColor(undefined, !style.selectionColor ? d.color : undefined, 'stroke')
  }));
}
var EMPTY_ARRAY$2 = [];
function UpSetSelection(_ref) {
  var size = _ref.size,
      data = _ref.data,
      style = _ref.style,
      selection = _ref.selection,
      hasHover = _ref.hasHover;
  var empty = style.emptySelection;
  var selectionOverlap = generateSelectionOverlap(selection, data.toElemKey);
  var selectionName = generateSelectionName(selection);
  var someAddon = size.sets.addons.some(function (s) {
    return s.renderSelection != null;
  }) || size.cs.addons.some(function (s) {
    return s.renderSelection != null;
  });
  var selectionElemOverlap = selection && typeof selection !== 'function' && someAddon ? elemElemOverlapOf(Array.isArray(selection) ? selection : selection.elems, data.toElemKey) : null;
  function wrapAddon(addon) {
    return _extends$1({}, addon, {
      render: function render(props) {
        var overlap = selectionElemOverlap ? selectionElemOverlap(props.set) : null;
        return addon.renderSelection ? addon.renderSelection(_extends$1({
          selection: selection,
          selectionColor: style.selectionColor || props.set.color || 'orange',
          overlap: overlap
        }, props)) : null;
      }
    });
  }
  return React.createElement("g", {
    className: hasHover ? "pnone-" + style.id : undefined
  }, (selection || empty) && React.createElement(CombinationSelectionChart, {
    data: data,
    size: size,
    style: style,
    transform: "translate(" + size.cs.x + "," + size.cs.y + ")",
    empty: empty && !selection,
    elemOverlap: selectionOverlap,
    suffix: "Selection-" + style.id,
    tooltip: hasHover ? undefined : selectionName,
    combinationAddons: size.cs.addons.length === 0 ? EMPTY_ARRAY$2 : size.cs.addons.map(wrapAddon)
  }), (selection || empty) && React.createElement(SetSelectionChart, {
    data: data,
    size: size,
    style: style,
    transform: "translate(" + size.sets.x + "," + size.sets.y + ")",
    empty: empty && !selection,
    elemOverlap: selectionOverlap,
    suffix: "Selection-" + style.id,
    tooltip: hasHover ? undefined : selectionName,
    setAddons: size.sets.addons.length === 0 ? EMPTY_ARRAY$2 : size.sets.addons.map(wrapAddon)
  }), React.createElement("g", {
    transform: "translate(" + size.labels.x + "," + size.labels.y + ")"
  }, isSetLike$1(selection) && React.createElement(LabelsSelection, {
    data: data,
    size: size,
    style: style,
    selection: selection
  }), isSetLike$1(selection) && React.createElement(UpSetSelectionChart, {
    data: data,
    size: size,
    style: style,
    selection: selection
  })));
}
function propRule(value, prop) {
  if (prop === void 0) {
    prop = 'font-size';
  }
  return value ? prop + ": " + value + ";" : '';
}
function baseRules(styleId, theme, fontFamily, fontSizes) {
  var hasS = [];
  if (theme.hasSelectionColor) {
    hasS.push("fill: " + theme.hasSelectionColor + ";");
  }
  if (theme.hasSelectionOpacity != null && theme.hasSelectionOpacity >= 0) {
    hasS.push("fill-opacity: " + theme.hasSelectionOpacity + ";");
  }
  return {
    p: propRule,
    root: "\n  .root-" + styleId + " {\n    " + propRule(fontFamily, 'font-family') + "\n  }\n  ",
    text: "\n  .titleTextStyle-" + styleId + " {\n    fill: " + theme.textColor + ";\n    " + propRule(fontSizes.title) + "\n  }\n  .descTextStyle-" + styleId + " {\n    fill: " + theme.textColor + ";\n    " + propRule(fontSizes.description) + "\n  }\n\n  .legendTextStyle-" + styleId + " {\n    fill: " + theme.textColor + ";\n    " + propRule(fontSizes.legend) + "\n    text-anchor: middle;\n    dominant-baseline: hanging;\n    pointer-events: none;\n  }\n  ",
    hasSFill: hasS.join(' '),
    hasSStroke: hasS.join(' ').replace('fill:', 'stroke:').replace('fill-', 'stroke-'),
    fill: "\n  .fillPrimary-" + styleId + " { fill: " + theme.color + "; fill-opacity: " + theme.opacity + "; }\n  " + (hasS.length > 0 ? ".root-" + styleId + "[data-selection] .fillPrimary-" + styleId + " { " + hasS.join(' ') + " }" : '') + "\n  " + (theme.selectionColor ? ".fillSelection-" + styleId + " { fill: " + theme.selectionColor + "; }" : '') + "\n  .fillTransparent-" + styleId + " { fill: transparent; }\n\n  .selectionHint-" + styleId + " {\n    fill: transparent;\n    pointer-events: none;\n    " + propRule(theme.selectionColor, 'stroke') + "\n  }\n  .clickAble-" + styleId + " {\n    cursor: pointer;\n  }\n\n  .startText-" + styleId + " {\n    text-anchor: start;\n  }\n  .endText-" + styleId + " {\n    text-anchor: end;\n  }\n  .pnone-" + styleId + " {\n    pointer-events: none;\n  }",
    "export": "\n  .exportTextStyle-" + styleId + " {\n    fill: " + theme.textColor + ";\n    " + propRule(fontSizes.exportLabel) + "\n  }\n  .exportButtons-" + styleId + " {\n    text-anchor: middle;\n  }\n  .exportButton-" + styleId + " {\n    cursor: pointer;\n    opacity: 0.5;\n  }\n  .exportButton-" + styleId + ":hover {\n    opacity: 1;\n  }\n  .exportButton-" + styleId + " > rect {\n    fill: none;\n    stroke: " + theme.textColor + ";\n  }\n  "
  };
}
function useHandler(p) {
  var onClick = p.onClick;
  return h$1(function () {
    return {
      hasClick: onClick != null,
      hasHover: p.onHover != null,
      onClick: wrap(onClick),
      onMouseEnter: wrap(p.onHover),
      onContextMenu: wrap(p.onContextMenu),
      onMouseLeave: p.onHover ? function (evt) {
        return p.onHover(null, evt.nativeEvent, []);
      } : undefined,
      onMouseMove: wrap(p.onMouseMove),
      reset: function reset(evt) {
        return onClick ? onClick(null, evt.nativeEvent, []) : null;
      }
    };
  }, [onClick, p.onHover, p.onContextMenu, p.onMouseMove]);
}
var UpSetJS = k$1(function UpSetJS(props, ref) {
  var _p$theme;
  var p = fillDefaults(props);
  var _p$selection = p.selection,
      selection = _p$selection === void 0 ? null : _p$selection,
      _p$queries = p.queries,
      queries = _p$queries === void 0 ? [] : _p$queries,
      fontSizes = p.fontSizes;
  var styleId = h$1(function () {
    return p.id ? p.id : generateId();
  }, [p.id, p.fontFamily, fontSizes.axisTick, fontSizes.barLabel, fontSizes.chartLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.hoverHintColor, p.color, p.hasSelectionColor, p.selectionColor, p.notMemberColor, p.alternatingBackgroundColor, p.opacity, p.hasSelectionOpacity]);
  var styleInfo = h$1(function () {
    return deriveStyleDependent(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, p.setName, p.setNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips);
  }, [p.theme, p.styles, p.classNames, p.barLabelOffset, p.combinationName, p.combinationNameAxisOffset, p.setName, p.setNameAxisOffset, styleId, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips]);
  var sizeInfo = h$1(function () {
    return deriveSizeDependent(p.width, p.height, p.padding, p.barPadding, p.widthRatios, p.heightRatios, p.setAddons, p.combinationAddons, p.id, p.setAddonPadding, p.combinationAddonPadding);
  }, [p.width, p.height, p.padding, p.barPadding, p.widthRatios, p.heightRatios, p.setAddons, p.combinationAddons, p.id, p.setAddonPadding, p.combinationAddonPadding]);
  var dataInfo = h$1(function () {
    return deriveDataDependent(p.sets, p.combinations, sizeInfo, p.numericScale, p.bandScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.dotPadding, p.barPadding, parseFontSize(fontSizes.axisTick), p.toKey, p.toElemKey, p.id);
  }, [p.sets, p.combinations, sizeInfo, p.numericScale, p.bandScale, p.barLabelOffset, fontSizes.barLabel, p.dotPadding, p.barPadding, fontSizes.axisTick, p.toKey, p.toElemKey, p.id]);
  var rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
  var h = useHandler(p);
  var rules = "\n  " + rulesHelper.root + "\n  " + rulesHelper.text + "\n\n  .axisTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.axisTick) + "\n    text-anchor: middle;\n  }\n  .barTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.barLabel) + "\n  }\n  .cBarTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.barLabel) + "\n    text-anchor: middle;\n  }\n  .sBarTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.barLabel) + "\n    text-anchor: end;\n    dominant-baseline: central;\n  }\n  .hoverBarTextStyle-" + styleId + " {\n    " + rulesHelper.p(fontSizes.barLabel) + "\n    fill: " + p.hoverHintColor + ";\n    display: none;\n    text-anchor: middle;\n  }\n  .setTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.setLabel) + "\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .cChartTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.chartLabel) + "\n    text-anchor: middle;\n  }\n  .sChartTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.chartLabel) + "\n    text-anchor: middle;\n    dominant-baseline: hanging;\n  }\n\n  " + rulesHelper.fill + "\n  .fillNotMember-" + styleId + " { fill: " + p.notMemberColor + "; }\n  .fillAlternating-" + styleId + " { fill: " + (p.alternatingBackgroundColor || 'transparent') + "; }\n\n  .axisLine-" + styleId + " {\n    fill: none;\n    stroke: " + p.textColor + ";\n  }\n  .hoverBar-" + styleId + " {\n    fill: transparent;\n  }\n\n  .interactive-" + styleId + ":hover > .hoverBar-" + styleId + " {\n    stroke: " + p.hoverHintColor + ";\n  }\n  .interactive-" + styleId + ":hover > .hoverBarTextStyle-" + styleId + " {\n    display: unset;\n  }\n\n  " + rulesHelper["export"] + "\n\n  .upsetLine-" + dataInfo.id + " {\n    stroke-linecap: round;\n    stroke-width: " + dataInfo.r * 0.6 + ";\n    stroke: " + p.color + ";\n    stroke-opacity: " + p.opacity + ";\n  }\n  " + (rulesHelper.hasSStroke ? ".root-" + styleId + "[data-selection] .upsetLine-" + dataInfo.id + " { " + rulesHelper.hasSStroke + " }" : '') + "\n\n  .upsetSelectionLine-" + dataInfo.id + " {\n    stroke-width: " + dataInfo.r * 0.6 * 1.1 + ";\n    " + rulesHelper.p(p.selectionColor, 'stroke') + "\n    pointer-events: none;\n  }\n\n  " + queries.map(function (q, i) {
    return ".fillQ" + i + "-" + dataInfo.id + " {\n    fill: " + q.color + ";\n  }";
  }).join('\n') + "\n  ";
  var exportChart = T$1(function (evt) {
    var svg = evt.currentTarget.closest('svg');
    var type = evt.currentTarget.dataset.type || 'png';
    switch (type) {
      case 'vega':
        exportVegaLite(svg);
        break;
      case 'dump':
        exportDump(svg, props, dataInfo);
        break;
      case 'share':
        exportSharedLink(props, dataInfo);
        break;
      case 'svg':
      case 'png':
        exportSVG(svg, {
          type: type,
          toRemove: "." + evt.currentTarget.getAttribute('class')
        });
    }
  }, [dataInfo, props]);
  var selectionName = generateSelectionName(selection);
  return React.createElement("svg", {
    id: p.id,
    className: clsx("root-" + styleId, p.className),
    style: p.style,
    width: p.width,
    height: p.height,
    ref: ref,
    viewBox: "0 0 " + p.width + " " + p.height,
    "data-theme": (_p$theme = p.theme) !== null && _p$theme !== void 0 ? _p$theme : 'light',
    "data-selection": selectionName ? selectionName : undefined
  }, React.createElement("style", null, rules), React.createElement("defs", null, React.createElement("clipPath", {
    id: "clip-" + sizeInfo.id
  }, React.createElement("rect", {
    x: sizeInfo.sets.w,
    y: 0,
    width: sizeInfo.labels.w,
    height: sizeInfo.sets.h
  }))), p.queryLegend && React.createElement(QueryLegend, {
    queries: queries,
    x: sizeInfo.legend.x,
    style: styleInfo,
    data: dataInfo
  }), React.createElement(ExportButtons, {
    transform: "translate(" + (sizeInfo.w - 2) + "," + (sizeInfo.h - 3) + ")",
    styleId: styleId,
    exportButtons: p.exportButtons,
    exportChart: exportChart
  }), React.createElement("g", {
    transform: "translate(" + p.padding + "," + p.padding + ")",
    "data-upset": "base"
  }, p.onClick && React.createElement("rect", {
    width: sizeInfo.cs.x,
    height: sizeInfo.sets.y,
    onClick: h.reset,
    className: "fillTransparent-" + styleId
  }), React.createElement(UpSetAxis, {
    size: sizeInfo,
    style: styleInfo,
    data: dataInfo
  }), React.createElement(UpSetChart, {
    size: sizeInfo,
    style: styleInfo,
    data: dataInfo,
    h: h,
    setChildrenFactory: p.setChildrenFactory,
    combinationChildrenFactory: p.combinationChildrenFactory
  }), React.createElement(UpSetSelection, {
    size: sizeInfo,
    style: styleInfo,
    data: dataInfo,
    hasHover: h.hasHover,
    selection: selection
  }), React.createElement(UpSetQueries, {
    size: sizeInfo,
    style: styleInfo,
    data: dataInfo,
    hasHover: h.hasHover,
    queries: queries,
    secondary: p.onHover != null || selection != null
  })), props.children);
});
function SVGWrapper(_ref) {
  var _p$theme, _p$queries;
  var rules = _ref.rules,
      style = _ref.style,
      size = _ref.size,
      p = _ref.p,
      data = _ref.data,
      tRef = _ref.tRef,
      children = _ref.children,
      exportChart = _ref.exportChart,
      selectionName = _ref.selectionName,
      h = _ref.h;
  return React.createElement("svg", {
    id: p.id,
    className: clsx("root-" + style.id, p.className),
    style: p.style,
    width: p.width,
    height: p.height,
    ref: tRef,
    viewBox: "0 0 " + p.width + " " + p.height,
    "data-theme": (_p$theme = p.theme) !== null && _p$theme !== void 0 ? _p$theme : 'light',
    "data-selection": selectionName ? selectionName : undefined
  }, React.createElement("style", null, rules), p.onClick && React.createElement("rect", {
    width: size.w,
    height: size.h,
    onClick: h.reset,
    className: "fillTransparent-" + style.id
  }), p.queryLegend && React.createElement(QueryLegend, {
    queries: (_p$queries = p.queries) !== null && _p$queries !== void 0 ? _p$queries : [],
    x: size.legend.x,
    style: style,
    data: data
  }), React.createElement(ExportButtons, {
    transform: "translate(" + (size.w - 2) + "," + (size.h - 3) + ")",
    styleId: style.id,
    exportButtons: p.exportButtons,
    exportChart: exportChart
  }), React.createElement("g", {
    transform: "translate(" + p.padding + "," + p.padding + ")",
    "data-upset": "base"
  }, children), p.children);
}
function generateArcSlicePath(s, refs, p) {
  if (p === void 0) {
    p = 0;
  }
  if (s.path) {
    return s.path;
  }
  return "M " + (s.x1 - p) + "," + (s.y1 - p) + " " + s.arcs.map(function (arc) {
    var ref = refs[arc.ref].l;
    var rx = isEllipse(ref) ? ref.rx : ref.r;
    var ry = isEllipse(ref) ? ref.ry : ref.r;
    var rot = isEllipse(ref) ? ref.rotation : 0;
    return "A " + (rx - p) + " " + (ry - p) + " " + rot + " " + (arc.large ? 1 : 0) + " " + (arc.sweep ? 1 : 0) + " " + (arc.x2 - p) + " " + (arc.y2 - p);
  }).join(' ');
}
function SelectionPattern(p) {
  var _p$rotate;
  if (p.v >= 1 || p.v <= 0) {
    return null;
  }
  var ratio = Math.round(p.v * 10.0) / 100;
  return React.createElement("defs", null, React.createElement("pattern", {
    id: p.id,
    width: "1",
    height: "0.1",
    patternContentUnits: "objectBoundingBox",
    patternTransform: "rotate(" + ((_p$rotate = p.rotate) !== null && _p$rotate !== void 0 ? _p$rotate : 0) + ")"
  }, p.bgFilled && React.createElement("rect", {
    x: "0",
    y: "0",
    width: "1",
    height: "0.1",
    style: {
      fill: p.bgFill
    },
    className: "fillPrimary-" + p.styleId
  }), React.createElement("rect", {
    x: "0",
    y: "0",
    width: "1",
    height: ratio,
    className: "fill" + p.suffix,
    style: p.fill ? {
      fill: p.fill
    } : undefined
  })));
}
function sliceRotate(slice, center) {
  if (slice.text.x === center.cx) {
    return 0;
  }
  if (slice.text.x > center.cx) {
    return slice.text.y <= center.cy ? 60 : -60;
  }
  return slice.text.y <= center.cy ? -60 : 60;
}
function generateTitle(d, s, sName, secondary, qs, queries, data, cx) {
  var dc = data.format(d.cardinality);
  var baseName = !sName ? d.name : d.name + " \u2229 " + sName;
  var baseCardinality = !sName ? dc : data.format(s) + "/" + dc;
  if (qs.length === 0) {
    return {
      tooltip: baseName + ": " + baseCardinality,
      title: d.type === 'set' ? React.createElement(React.Fragment, null, React.createElement("tspan", {
        dy: "-0.6em"
      }, d.name), React.createElement("tspan", {
        x: cx,
        dy: "1.2em"
      }, baseCardinality)) : baseCardinality
    };
  }
  if (qs.length === 1 && !secondary && !sName) {
    return {
      tooltip: d.name + " \u2229 " + queries[0].name + ": " + data.format(qs[0]) + "/" + dc,
      title: d.type === 'set' ? React.createElement(React.Fragment, null, React.createElement("tspan", {
        dy: "-0.6em"
      }, d.name), React.createElement("tspan", {
        x: cx,
        dy: "1.2em"
      }, data.format(qs[0]) + "/" + dc)) : data.format(qs[0]) + "/" + dc
    };
  }
  var queryLine = React.createElement("tspan", {
    x: cx,
    dy: "1.2em"
  }, queries.map(function (q, i) {
    return React.createElement(React.Fragment, {
      key: q.name
    }, React.createElement("tspan", {
      className: "fillQ" + i + "-" + data.id
    }, '⬤'), React.createElement("tspan", null, " " + data.format(qs[i]) + "/" + dc + (i < queries.length - 1 ? ' ' : '')));
  }));
  return {
    tooltip: baseName + ": " + baseCardinality + "\n" + queries.map(function (q, i) {
      return d.name + " \u2229 " + q.name + ": " + data.format(qs[i]) + "/" + dc;
    }).join('\n'),
    title: d.type === 'set' ? React.createElement(React.Fragment, null, React.createElement("tspan", {
      dy: "-1.2em"
    }, d.name), React.createElement("tspan", {
      x: cx,
      dy: "1.2em"
    }, baseCardinality), queryLine) : React.createElement(React.Fragment, null, React.createElement("tspan", {
      dy: "-0.6em"
    }, baseCardinality), queryLine)
  };
}
function VennArcSliceSelection(_ref) {
  var slice = _ref.slice,
      d = _ref.d,
      i = _ref.i,
      data = _ref.data,
      style = _ref.style,
      elemOverlap = _ref.elemOverlap,
      selected = _ref.selected,
      selectionName = _ref.selectionName,
      h = _ref.h,
      queries = _ref.queries,
      size = _ref.size,
      fill = _ref.fill,
      qs = _ref.qs;
  var p = generateArcSlicePath(slice, data.sets.d);
  var rotate = sliceRotate(slice, size.area);
  var o = elemOverlap ? elemOverlap(d) : 0;
  var fillFullSelection = o === d.cardinality && d.cardinality > 0 || selected;
  var className = clsx("arc-" + style.id, o === 0 && !selected && (fill ? 'fillPrimary' : 'arcP') + "-" + style.id, fillFullSelection && "fillSelection-" + style.id, style.classNames.set);
  var id = "upset-" + style.id + "-" + i;
  var secondary = elemOverlap != null || h.onMouseLeave != null;
  var qsOverlaps = qs.map(function (q) {
    return q(d);
  });
  var _generateTitle = generateTitle(d, o, selectionName, secondary, qsOverlaps, queries, data, slice.text.x),
      title = _generateTitle.title,
      tooltip = _generateTitle.tooltip;
  return React.createElement("g", null, React.createElement(SelectionPattern, {
    id: id,
    v: o === 0 ? 0 : o / d.cardinality,
    suffix: "Selection-" + style.id,
    rotate: rotate,
    bgFill: d.color,
    bgFilled: d.color != null || fill,
    fill: !style.selectionColor ? d.color : undefined,
    styleId: style.id
  }), React.createElement("path", {
    onMouseEnter: h.onMouseEnter(d, []),
    onMouseLeave: h.onMouseLeave,
    onClick: h.onClick(d, []),
    onContextMenu: h.onContextMenu(d, []),
    onMouseMove: h.onMouseMove(d, []),
    d: p,
    className: className,
    style: mergeColor(style.styles.set, o > 0 && o < d.cardinality ? "url(#" + id + ")" : !fillFullSelection || !style.selectionColor ? d.color : undefined)
  }, style.tooltips && React.createElement("title", null, tooltip)), React.createElement("text", {
    x: slice.text.x,
    y: slice.text.y,
    className: clsx((d.type === 'set' ? 'set' : 'value') + "TextStyle-" + style.id, "pnone-" + style.id)
  }, title));
}
function deriveVennDataDependent(sets, combinations, size, layout, format, toKey, toElemKey, id) {
  var ss = sets.length > layout.maxSets ? sets.slice(0, layout.maxSets) : sets;
  var _calculateCombination = calculateCombinations(ss, toKey, combinations),
      cs = _calculateCombination.cs,
      setKeys = _calculateCombination.setKeys,
      csKeys = _calculateCombination.csKeys;
  var l = layout.compute(ss, cs, size.area.w, size.area.h);
  return {
    id: id ? id : generateId(),
    sets: {
      d: l.sets.map(function (l, i) {
        return {
          v: ss[i],
          l: l,
          key: setKeys[i]
        };
      }),
      v: ss,
      format: format
    },
    format: format,
    cs: {
      d: l.intersections.map(function (l, i) {
        return {
          v: cs[i],
          l: l,
          key: csKeys[i]
        };
      }),
      v: cs,
      has: function has(v, s) {
        var sk = toKey(s);
        return Array.from(v.sets).some(function (ss) {
          return toKey(ss) === sk;
        });
      }
    },
    toKey: toKey,
    toElemKey: toElemKey
  };
}
function calculateCombinations(ss, toKey, combinations, options) {
  if (options === void 0) {
    options = {
      min: 1
    };
  }
  var setKeys = ss.map(toKey);
  var cs = [];
  if (areCombinations$1(combinations)) {
    var given = new Map(combinations.map(function (c) {
      return [Array.from(c.sets).map(toKey).sort().join('#'), c];
    }));
    var helperSets = ss.map(function (s) {
      return {
        type: 'set',
        cardinality: 0,
        elems: [],
        name: s.name,
        s: s
      };
    });
    cs = generateCombinations(helperSets, Object.assign({
      type: 'distinctIntersection',
      empty: true,
      order: ['degree:asc', 'group:asc']
    }, options)).map(function (c) {
      var key = Array.from(c.sets).map(function (s) {
        return toKey(s.s);
      }).sort().join('#');
      if (given.has(key)) {
        return given.get(key);
      }
      return {
        name: c.name,
        cardinality: 0,
        degree: c.degree,
        elems: [],
        sets: new Set(Array.from(c.sets).map(function (s) {
          return s.s;
        })),
        type: 'distinctIntersection'
      };
    });
  } else {
    cs = generateCombinations(ss, Object.assign({
      type: 'distinctIntersection',
      empty: true,
      order: ['degree:asc', 'group:asc']
    }, options, combinations !== null && combinations !== void 0 ? combinations : {}));
  }
  var csKeys = cs.map(toKey);
  return {
    cs: cs,
    setKeys: setKeys,
    csKeys: csKeys
  };
}
function deriveVennSizeDependent(width, height, margin, id) {
  var h = height - 2 * margin;
  var w = width - 2 * margin;
  var r = Math.min(w, h) / 2;
  return {
    id: id ? id : generateId(),
    legend: {
      x: width / 2
    },
    area: {
      w: w,
      h: h,
      cx: w / 2,
      cy: h / 2,
      r: r
    },
    margin: margin,
    w: width,
    h: height
  };
}
function deriveVennStyleDependent(theme, styles, classNames, styleId, selectionColor, title, description, tooltips) {
  return {
    theme: theme,
    styles: styles,
    classNames: classNames,
    id: styleId,
    selectionColor: selectionColor,
    title: title,
    description: description,
    tooltips: tooltips
  };
}
function useCreateCommon(p) {
  var _p$selection = p.selection,
      selection = _p$selection === void 0 ? null : _p$selection,
      _p$queries = p.queries,
      queries = _p$queries === void 0 ? [] : _p$queries,
      fontSizes = p.fontSizes;
  var styleId = h$1(function () {
    return p.id ? p.id : generateId();
  }, [p.id, p.fontFamily, fontSizes.valueLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.color, p.hasSelectionColor, p.strokeColor, p.valueTextColor, p.selectionColor, p.opacity, p.hasSelectionOpacity]);
  var styleInfo = h$1(function () {
    return deriveVennStyleDependent(p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips);
  }, [p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips]);
  var sizeInfo = h$1(function () {
    return deriveVennSizeDependent(p.width, p.height, p.padding, p.id);
  }, [p.width, p.height, p.padding, p.id]);
  var h = useHandler(p);
  var selectionKey = selection != null && isSetLike$1(selection) ? p.toKey(selection) : null;
  var selectionOverlap = selection == null ? null : generateSelectionOverlap(selection, p.toElemKey);
  var selectionName = generateSelectionName(selection);
  var qs = React.useMemo(function () {
    return queries.map(function (q) {
      return queryOverlap(q, 'intersection', p.toElemKey);
    });
  }, [queries, p.toElemKey]);
  var rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
  return {
    styleId: styleId,
    size: sizeInfo,
    style: styleInfo,
    h: h,
    selectionKey: selectionKey,
    selectionName: selectionName,
    selectionOverlap: selectionOverlap,
    qs: qs,
    rulesHelper: rulesHelper
  };
}
function useExportChart(dataInfo, props, mode) {
  return T$1(function (evt) {
    var svg = evt.currentTarget.closest('svg');
    var type = evt.currentTarget.dataset.type || 'png';
    switch (type) {
      case 'dump':
        exportDump(svg, props, dataInfo, mode);
        break;
      case 'share':
        exportSharedLink(props, dataInfo, mode);
        break;
      case 'svg':
      case 'png':
        exportSVG(svg, {
          type: type,
          toRemove: "." + evt.currentTarget.getAttribute('class')
        });
    }
  }, [dataInfo, props, mode]);
}
var VennDiagram = k$1(function VennDiagram(props, ref) {
  var p = fillVennDiagramDefaults(props);
  var _p$selection = p.selection,
      selection = _p$selection === void 0 ? null : _p$selection,
      _p$queries = p.queries,
      queries = _p$queries === void 0 ? [] : _p$queries,
      fontSizes = p.fontSizes;
  var v = useCreateCommon(p);
  var size = v.size,
      style = v.style,
      rulesHelper = v.rulesHelper;
  var dataInfo = h$1(function () {
    return deriveVennDataDependent(p.sets, p.combinations, size, p.layout, p.valueFormat, p.toKey, p.toElemKey, p.id);
  }, [p.sets, p.combinations, size, p.valueFormat, p.toKey, p.toElemKey, p.id, p.layout]);
  var rules = "\n  " + rulesHelper.root + "\n  " + rulesHelper.text + "\n\n  .valueTextStyle-" + style.id + " {\n    fill: " + p.valueTextColor + ";\n    " + rulesHelper.p(fontSizes.valueLabel) + "\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .setTextStyle-" + style.id + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.setLabel) + "\n    text-anchor: middle;\n  }\n\n  .topText-" + style.id + " {\n    dominant-baseline: hanging;\n  }\n\n  .stroke-circle-" + style.id + " {\n    fill: none;\n    stroke: " + p.strokeColor + ";\n  }\n\n  .arc-" + style.id + " {\n    fill-rule: evenodd;\n  }\n  .arcP-" + style.id + " {\n    fill: transparent;\n    fill-opacity: " + p.opacity + ";\n  }\n  " + rulesHelper.fill + "\n  " + rulesHelper["export"] + "\n\n  " + (rulesHelper.hasSFill ? ".root-" + style.id + "[data-selection] .arcP-" + style.id + " { " + rulesHelper.hasSFill + " }" : '') + "\n\n  " + queries.map(function (q, i) {
    return ".fillQ" + i + "-" + dataInfo.id + " {\n    fill: " + q.color + ";\n  }";
  }).join('\n') + "\n  ";
  var exportChart = useExportChart(dataInfo, p, 'venn');
  var maxWidth = dataInfo.sets.d.reduce(function (acc, d) {
    return Math.min(acc, d.l.cx - (isEllipse(d.l) ? d.l.rx : d.l.r));
  }, size.area.w);
  return React.createElement(SVGWrapper, {
    rules: rules,
    style: style,
    selectionName: v.selectionName,
    size: size,
    p: p,
    data: dataInfo,
    tRef: ref,
    h: v.h,
    exportChart: exportChart
  }, React.createElement(UpSetTitle, {
    style: style,
    width: maxWidth
  }), React.createElement("g", {
    className: clsx(p.onClick && "clickAble-" + style.id)
  }, dataInfo.sets.d.map(function (d, i) {
    return React.createElement("text", {
      key: d.key,
      x: d.l.text.x,
      y: d.l.text.y,
      onClick: v.h.onClick(dataInfo.sets.v[i], []),
      onMouseEnter: v.h.onMouseEnter(dataInfo.sets.v[i], []),
      onMouseLeave: v.h.onMouseLeave,
      onContextMenu: v.h.onContextMenu(dataInfo.sets.v[i], []),
      onMouseMove: v.h.onMouseMove(dataInfo.sets.v[i], []),
      className: clsx("setTextStyle-" + style.id, d.l.align + "Text-" + style.id, d.l.verticalAlign + "Text-" + style.id)
    }, dataInfo.sets.v[i].name);
  })), React.createElement("g", {
    className: clsx(p.onClick && "clickAble-" + style.id)
  }, dataInfo.cs.d.map(function (l, i) {
    return React.createElement(VennArcSliceSelection, {
      key: l.key,
      d: l.v,
      i: i,
      slice: l.l,
      size: size,
      style: style,
      data: dataInfo,
      fill: p.filled,
      h: v.h,
      selectionName: v.selectionName,
      selected: v.selectionKey === l.key || isSet(selection) && dataInfo.cs.has(l.v, selection),
      elemOverlap: v.selectionOverlap,
      queries: queries,
      qs: v.qs
    });
  })), React.createElement("g", null, dataInfo.sets.d.map(function (l) {
    return isEllipse(l.l) ? React.createElement("ellipse", {
      key: l.key,
      rx: l.l.rx,
      ry: l.l.ry,
      transform: "translate(" + l.l.cx + "," + l.l.cy + ")rotate(" + l.l.rotation + ")",
      className: clsx("stroke-circle-" + style.id, style.classNames.set),
      style: style.styles.set
    }) : React.createElement("circle", {
      key: l.key,
      cx: l.l.cx,
      cy: l.l.cy,
      r: l.l.r,
      className: clsx("stroke-circle-" + style.id, style.classNames.set),
      style: style.styles.set
    });
  })));
});
var KMapCell = React.memo(function KMapCell(_ref) {
  var d = _ref.d,
      i = _ref.i,
      h = _ref.h,
      className = _ref.className,
      data = _ref.data,
      style = _ref.style;
  var l = data.cs.l[i];
  var y = data.cs.scale(d.cardinality);
  var x = (data.cell - data.cs.bandWidth) / 2;
  return React.createElement("g", {
    transform: "translate(" + l.x + ", " + l.y + ")",
    onMouseEnter: h.onMouseEnter(d, []),
    onMouseLeave: h.onMouseLeave,
    onClick: h.onClick(d, []),
    onContextMenu: h.onContextMenu(d, []),
    onMouseMove: h.onMouseMove(d, []),
    className: className,
    "data-cardinality": d.cardinality
  }, style.tooltips && React.createElement("title", null, d.name, ": ", data.sets.format(d.cardinality)), React.createElement("rect", {
    width: data.cell,
    height: data.cell,
    className: "fillTransparent-" + style.id
  }), React.createElement("rect", {
    x: x,
    y: y,
    height: data.cell - y,
    width: data.cs.bandWidth,
    className: clsx("fillPrimary-" + style.id, style.classNames.bar),
    style: mergeColor(style.styles.bar, d.color)
  }), React.createElement("text", {
    y: y - style.barLabelOffset,
    x: data.cell / 2,
    style: style.styles.barLabel,
    className: clsx("barTextStyle-" + style.id, style.classNames.barLabel)
  }, data.sets.format(d.cardinality)));
});
function generateGridPath(cell, vCells, hCells, level) {
  var h = cell * vCells;
  var w = cell * hCells;
  return [level.x.map(function (x) {
    return "M " + x * cell + ",0 l0," + h;
  }), level.y.map(function (y) {
    return "M 0," + y * cell + " l" + w + ",0";
  })].flat().join(' ');
}
var KMapChart = React.memo(function KMapChart(_ref) {
  var data = _ref.data,
      style = _ref.style,
      size = _ref.size,
      h = _ref.h;
  var csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;
  return React.createElement("g", null, React.createElement("g", {
    transform: "translate(" + (size.w - csNameOffset - 2) + ", " + (size.h - data.cell - 50) + ")"
  }, React.createElement(Axis, {
    scale: data.cs.scale,
    orient: "left",
    size: data.cell,
    start: data.cs.barLabelFontSize,
    style: style
  }), React.createElement("text", {
    className: clsx("cChartTextStyle-" + style.id, style.classNames.chartLabel),
    style: style.styles.chartLabel,
    transform: "translate(" + -csNameOffset + ", " + data.cell + ")rotate(-90)"
  }, style.cs.name)), React.createElement("g", null, data.sets.l.map(function (l, i) {
    var s = data.sets.v[i];
    var name = s.name;
    return React.createElement("g", {
      key: name,
      onClick: h.onClick(s, []),
      onMouseEnter: h.onMouseEnter(s, []),
      onMouseLeave: h.onMouseLeave,
      onContextMenu: h.onContextMenu(s, []),
      onMouseMove: h.onMouseMove(s, []),
      className: clsx(h.hasClick && "clickAble-" + style.id)
    }, l.text.map(function (p, i) {
      return React.createElement("text", {
        key: i,
        transform: "translate(" + p.x + "," + p.y + ")" + (!l.hor ? 'rotate(-90)' : ''),
        className: clsx("setTextStyle-" + style.id)
      }, name);
    }));
  }), data.sets.l.map(function (l, i) {
    var name = data.sets.v[i].name;
    return React.createElement(React.Fragment, {
      key: name
    }, l.notText.map(function (p, i) {
      return React.createElement("text", {
        key: i,
        transform: "translate(" + p.x + "," + p.y + ")" + (!l.hor ? 'rotate(-90)' : ''),
        className: clsx("setTextStyle-" + style.id, "not-" + style.id)
      }, name);
    }));
  })), React.createElement("g", {
    className: clsx(h.hasClick && "clickAble-" + style.id)
  }, data.cs.v.map(function (c, i) {
    return React.createElement(KMapCell, {
      key: data.cs.keys[i],
      d: c,
      i: i,
      h: h,
      style: style,
      data: data
    });
  })), React.createElement("g", {
    transform: "translate(" + data.grid.x + ", " + data.grid.y + ")"
  }, data.grid.levels.map(function (l, i) {
    return React.createElement("path", {
      key: i,
      d: generateGridPath(data.cell, data.grid.vCells, data.grid.hCells, l),
      className: "gridStyle-" + style.id + " gridStyle-" + style.id + "-" + i
    });
  })));
});
function KMapQueries(_ref) {
  var data = _ref.data,
      style = _ref.style,
      elemOverlap = _ref.elemOverlap,
      secondary = _ref.secondary,
      tooltip = _ref.tooltip,
      suffix = _ref.suffix,
      empty = _ref.empty;
  var width = data.cs.bandWidth;
  var offset = (data.cell - width) / 2;
  var className = clsx("fill" + suffix, !tooltip && "pnone-" + style.id, style.classNames.bar);
  return React.createElement("g", {
    "data-upset": secondary ? 'cs-q' : 'cs-s'
  }, data.cs.v.map(function (d, i) {
    var l = data.cs.l[i];
    var key = data.cs.keys[i];
    if (empty && !secondary) {
      return React.createElement("rect", {
        key: key,
        x: l.x + offset,
        y: l.y + data.cell,
        height: 0,
        width: width,
        className: className,
        style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
      }, tooltip && React.createElement("title", null));
    }
    var o = elemOverlap(d);
    if (o === 0) {
      return null;
    }
    var y = data.cs.scale(o);
    var title = tooltip && React.createElement("title", null, d.name + " \u2229 " + tooltip + ": " + o);
    return secondary ? React.createElement("path", {
      key: key,
      transform: "translate(" + (l.x + offset) + ", " + (l.y + y) + ")",
      d: "M0,-1 l" + width + ",0 l0,2 l" + -width + ",0 L-" + data.triangleSize + ",-" + data.triangleSize + " L-" + data.triangleSize + "," + data.triangleSize + " Z",
      className: className,
      "data-i": i,
      "data-cardinality": o,
      style: mergeColor(undefined, !style.selectionColor ? d.color : undefined)
    }, title) : React.createElement("rect", {
      key: key,
      x: l.x + offset,
      y: l.y + y,
      height: data.cell - y,
      "data-i": i,
      "data-cardinality": o,
      width: width,
      className: className,
      style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined)
    }, title);
  }));
}
var KMapQueries$1 = React.memo(function KMapQueries$1(_ref) {
  var data = _ref.data,
      style = _ref.style,
      hasHover = _ref.hasHover,
      secondary = _ref.secondary,
      queries = _ref.queries;
  var qs = h$1(function () {
    return queries.map(function (q) {
      return _extends$1({}, q, {
        overlap: queryOverlap(q, 'intersection', data.toElemKey)
      });
    });
  }, [queries, data.toElemKey]);
  return React.createElement("g", {
    className: hasHover && !secondary ? "pnone-" + style.id : undefined
  }, qs.map(function (q, i) {
    return React.createElement(KMapQueries, {
      key: q.name,
      data: data,
      style: style,
      elemOverlap: q.overlap,
      suffix: "Q" + i + "-" + data.id,
      secondary: secondary || i > 0,
      tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name
    });
  }));
});
function KMapSelection(_ref) {
  var data = _ref.data,
      style = _ref.style,
      selection = _ref.selection,
      hasHover = _ref.hasHover;
  var empty = style.emptySelection;
  var selectionOverlap = generateSelectionOverlap(selection, data.toElemKey);
  var selectionName = generateSelectionName(selection);
  return React.createElement("g", {
    className: hasHover ? "pnone-" + style.id : undefined
  }, (selection || empty) && React.createElement(KMapQueries, {
    data: data,
    style: style,
    empty: empty && !selection,
    elemOverlap: selectionOverlap,
    suffix: "Selection-" + style.id,
    tooltip: hasHover ? undefined : selectionName
  }));
}
function ranged(count, cb) {
  return Array(count).fill(0).map(function (_, i) {
    return cb(i);
  });
}
function generateLevels(numSets) {
  var lines = Array(Math.pow(2, numSets)).fill(0);
  ranged(numSets, function (i) {
    var shift = Math.pow(2, i);
    for (var _i = 0; _i < lines.length; _i += shift) {
      lines[_i]++;
    }
  });
  var levels = ranged(Math.max(numSets, 1), function () {
    return [];
  });
  lines.forEach(function (l, i) {
    var level = Math.max(0, l - 1);
    levels[level].push(i);
  });
  levels[levels.length - 1].push(lines.length);
  return levels;
}
function generate(sets, cs, has, options) {
  var _bounds = bounds(sets.length, options),
      xBefore = _bounds.xBefore,
      yBefore = _bounds.yBefore,
      cell = _bounds.cell,
      hCells = _bounds.hCells,
      vCells = _bounds.vCells,
      horizontalSets = _bounds.horizontalSets,
      verticalSets = _bounds.verticalSets;
  var s = setLabels(sets.length, options);
  var shifts = generateShiftLookup(sets, hCells, vCells, has);
  var c = cs.map(function (c) {
    var _shifts$reduceRight = shifts.reduceRight(function (acc, s) {
      return s(c, acc);
    }, [0, 0]),
        i = _shifts$reduceRight[0],
        j = _shifts$reduceRight[1];
    return {
      x: xBefore + i * cell,
      y: yBefore + j * cell
    };
  });
  var hLevels = generateLevels(horizontalSets);
  var vLevels = generateLevels(verticalSets);
  return {
    s: s,
    c: c,
    cell: cell,
    grid: {
      x: xBefore,
      y: yBefore,
      hCells: hCells,
      vCells: vCells,
      levels: hLevels.map(function (l, i) {
        return {
          x: l,
          y: i < vLevels.length ? vLevels[i] : []
        };
      })
    }
  };
}
function generateShiftLookup(sets, hCells, vCells, has) {
  return sets.map(function (s, k) {
    var index = Math.floor(k / 2);
    var hor = k % 2 === 0;
    var numLabels = Math.pow(2, index);
    var span = (hor ? hCells : vCells) / numLabels / 2;
    return function (cs, _ref) {
      var i = _ref[0],
          j = _ref[1];
      if (has(cs, s)) {
        return [i, j];
      }
      if (span > 1) {
        if (hor) {
          return [span - 1 - i + span, j];
        }
        return [i, span - 1 - j + span];
      }
      if (hor) {
        return [i + span, j];
      }
      return [i, j + span];
    };
  });
}
function setLabels(sets, options) {
  var _bounds2 = bounds(sets, options),
      xOffset = _bounds2.xOffset,
      yOffset = _bounds2.yOffset,
      cell = _bounds2.cell,
      xBefore = _bounds2.xBefore,
      yBefore = _bounds2.yBefore,
      hCells = _bounds2.hCells,
      vCells = _bounds2.vCells;
  var xAfterEnd = options.width - xOffset;
  var yAfterEnd = options.height - yOffset;
  return ranged(sets, function (k) {
    var index = Math.floor(k / 2);
    var hor = k % 2 === 0;
    var numLabels = Math.pow(2, index);
    var span = (hor ? hCells : vCells) / numLabels / 2;
    var xPos = hor ? xBefore : yBefore;
    var labels = [{
      v: true,
      x: xPos + span * cell * 0.5
    }, {
      v: false,
      x: xPos + span * cell * 1.5
    }];
    var _loop = function _loop(i) {
      var offset = span * Math.pow(2, i) * cell;
      var l = labels.length - 1;
      labels.push.apply(labels, labels.map(function (li, i) {
        return {
          v: labels[l - i].v,
          x: li.x + offset
        };
      }));
    };
    for (var i = 1; i <= index; i++) {
      _loop(i);
    }
    var inAfterGroup = index % 2 === 1;
    var withinGroupIndex = Math.floor(index / 2);
    var yPos = 0;
    if (inAfterGroup) {
      var end = hor ? yAfterEnd : xAfterEnd;
      yPos = end - options.labelHeight * (0.5 + withinGroupIndex);
    } else {
      var start = hor ? yOffset : xOffset;
      yPos = start + options.labelHeight * (0.5 + withinGroupIndex);
    }
    if (hor) {
      return {
        hor: true,
        span: span,
        text: labels.filter(function (d) {
          return d.v;
        }).map(function (l) {
          return {
            x: l.x,
            y: yPos
          };
        }),
        notText: labels.filter(function (d) {
          return !d.v;
        }).map(function (l) {
          return {
            x: l.x,
            y: yPos
          };
        })
      };
    }
    return {
      hor: false,
      span: span,
      text: labels.filter(function (d) {
        return d.v;
      }).map(function (l) {
        return {
          x: yPos,
          y: l.x
        };
      }),
      notText: labels.filter(function (d) {
        return !d.v;
      }).map(function (l) {
        return {
          x: yPos,
          y: l.x
        };
      })
    };
  });
}
function bounds(sets, options) {
  var horizontalSets = Math.ceil(sets / 2);
  var verticalSets = Math.floor(sets / 2);
  var hCells = Math.pow(2, horizontalSets);
  var vCells = Math.pow(2, verticalSets);
  var cell = Math.floor(Math.min((options.width - options.labelHeight * verticalSets) / hCells, (options.height - options.labelHeight * horizontalSets) / vCells));
  var xOffset = (options.width - hCells * cell - options.labelHeight * verticalSets) / 2;
  var yOffset = (options.height - vCells * cell - options.labelHeight * horizontalSets) / 2;
  var xBefore = xOffset + Math.ceil(verticalSets / 2) * options.labelHeight;
  var yBefore = yOffset + Math.ceil(horizontalSets / 2) * options.labelHeight;
  return {
    xOffset: xOffset,
    horizontalSets: horizontalSets,
    yOffset: yOffset,
    verticalSets: verticalSets,
    cell: cell,
    xBefore: xBefore,
    yBefore: yBefore,
    hCells: hCells,
    vCells: vCells
  };
}
function deriveKarnaughDataDependent(sets, combinations, size, numericScale, barLabelFontSize, barPadding, setLabelFontSize, tickFontSize, toKey, toElemKey, id) {
  var numericScaleFactory = resolveNumericScale(numericScale);
  var setKeys = sets.map(toKey);
  var cs = areCombinations$1(combinations) ? combinations : generateCombinations(sets, Object.assign({
    type: 'distinctIntersection'
  }, combinations !== null && combinations !== void 0 ? combinations : {}));
  var csKeys = cs.map(toKey);
  var has = function has(v, s) {
    var sk = toKey(s);
    return Array.from(v.sets).some(function (ss) {
      return toKey(ss) === sk;
    });
  };
  var labelHeight = Math.ceil(setLabelFontSize * 1.2);
  var l = generate(sets, cs, has, {
    width: size.area.w,
    height: size.area.h,
    labelHeight: labelHeight
  });
  var maxCSCardinality = cs.reduce(function (acc, d) {
    return Math.max(acc, d.cardinality);
  }, 0);
  var scale = numericScaleFactory(maxCSCardinality, [l.cell, barLabelFontSize], {
    orientation: 'vertical',
    fontSizeHint: tickFontSize
  });
  var bandWidth = Math.round(l.cell * (1 - barPadding));
  var triangleSize = Math.min(Math.max(2, bandWidth / 2 * barPadding), 5);
  var guessLabelWidth = function guessLabelWidth(v) {
    return Math.floor(barLabelFontSize / 1.4 * 0.7 * scale.tickFormat()(v).length);
  };
  var largestCSLabelWidth = guessLabelWidth(maxCSCardinality);
  return {
    id: id ? id : generateId(),
    grid: l.grid,
    sets: {
      keys: setKeys,
      l: l.s,
      v: sets,
      labelHeight: labelHeight,
      format: scale.tickFormat()
    },
    triangleSize: triangleSize,
    cell: l.cell,
    cs: {
      keys: csKeys,
      l: l.c,
      v: cs,
      barLabelFontSize: barLabelFontSize,
      has: has,
      scale: scale,
      bandWidth: bandWidth,
      labelOffset: largestCSLabelWidth + 9 + 6
    },
    toKey: toKey,
    toElemKey: toElemKey
  };
}
function deriveStyleDependent$1(theme, styles, classNames, combinationName, combinationNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips) {
  return {
    theme: theme,
    styles: styles,
    classNames: classNames,
    emptySelection: emptySelection,
    id: styleId,
    barLabelOffset: barLabelOffset,
    selectionColor: selectionColor,
    title: title,
    description: description,
    tooltips: tooltips,
    cs: {
      name: combinationName,
      offset: combinationNameAxisOffset
    }
  };
}
var KarnaughMap = k$1(function KarnaughMap(props, ref) {
  var p = fillKarnaughMapDefaults(props);
  var _p$queries = p.queries,
      queries = _p$queries === void 0 ? [] : _p$queries,
      fontSizes = p.fontSizes,
      _p$selection = p.selection,
      selection = _p$selection === void 0 ? null : _p$selection;
  var styleId = h$1(function () {
    return p.id ? p.id : generateId();
  }, [p.id, p.fontFamily, fontSizes.axisTick, fontSizes.barLabel, fontSizes.legend, fontSizes.setLabel, fontSizes.title, fontSizes.exportLabel, fontSizes.description, p.textColor, p.color, p.hasSelectionColor, p.strokeColor, p.selectionColor, p.opacity, p.hasSelectionOpacity]);
  var style = h$1(function () {
    return deriveStyleDependent$1(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips);
  }, [p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips]);
  var size = h$1(function () {
    return deriveVennSizeDependent(p.width, p.height, p.padding, p.id);
  }, [p.width, p.height, p.padding, p.id]);
  var data = h$1(function () {
    return deriveKarnaughDataDependent(p.sets, p.combinations, size, p.numericScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.barPadding, parseFontSize(fontSizes.setLabel), parseFontSize(fontSizes.axisTick), p.toKey, p.toElemKey, p.id);
  }, [p.sets, p.combinations, size, p.numericScale, p.barLabelOffset, fontSizes.barLabel, p.barPadding, fontSizes.axisTick, fontSizes.setLabel, p.toKey, p.toElemKey, p.id]);
  var h = useHandler(p);
  var selectionName = generateSelectionName(selection);
  var rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
  var rules = "\n  " + rulesHelper.root + "\n  " + rulesHelper.text + "\n\n  .axisTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.axisTick) + "\n    text-anchor: end;\n  }\n  .barTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.barLabel) + "\n    text-anchor: middle;\n  }\n  .setTextStyle-" + style.id + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.setLabel) + "\n    text-anchor: middle;\n    dominant-baseline: central;\n  }\n  .cChartTextStyle-" + styleId + " {\n    fill: " + p.textColor + ";\n    " + rulesHelper.p(fontSizes.chartLabel) + "\n  }\n\n  .not-" + style.id + " {\n    text-decoration: overline;\n  }\n\n  .axisLine-" + styleId + " {\n    fill: none;\n    stroke: " + p.textColor + ";\n  }\n\n  .gridStyle-" + style.id + " {\n    fill: none;\n    stroke: " + p.strokeColor + ";\n    stroke-linecap: round;\n  }\n  .gridStyle-" + style.id + "-1 {\n    stroke-width: 2;\n  }\n  .gridStyle-" + style.id + "-2 {\n    stroke-width: 3;\n  }\n\n  " + rulesHelper.fill + "\n  " + rulesHelper["export"] + "\n\n  " + queries.map(function (q, i) {
    return ".fillQ" + i + "-" + data.id + " {\n    fill: " + q.color + ";\n  }";
  }).join('\n') + "\n  ";
  var exportChart = useExportChart(data, p, 'kmap');
  var maxWidth = data.sets.l.reduce(function (acc, d) {
    return Math.min(acc, d.text[0].x - data.sets.labelHeight);
  }, size.area.w);
  return React.createElement(SVGWrapper, {
    rules: rules,
    style: style,
    size: size,
    p: p,
    data: data,
    tRef: ref,
    selectionName: selectionName,
    h: h,
    exportChart: exportChart
  }, React.createElement(UpSetTitle, {
    style: style,
    width: maxWidth
  }), React.createElement(KMapChart, {
    style: style,
    data: data,
    h: h,
    size: size
  }), React.createElement(KMapSelection, {
    style: style,
    data: data,
    hasHover: h.hasHover,
    selection: selection
  }), React.createElement(KMapQueries$1, {
    style: style,
    data: data,
    hasHover: h.hasHover,
    queries: queries,
    secondary: h.hasHover || selection != null
  }));
});
var defaults = {
  background: '#F4F4F4',
  color: '#A6A8AB',
  secondaryColor: '#E1E2E3'
};
function prepare(props) {
  var _props$color, _props$secondaryColor, _props$background;
  var color = (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : defaults.color;
  var secondary = (_props$secondaryColor = props.secondaryColor) !== null && _props$secondaryColor !== void 0 ? _props$secondaryColor : defaults.secondaryColor;
  var rest = Object.assign({}, props);
  var background = (_props$background = props.background) !== null && _props$background !== void 0 ? _props$background : defaults.background;
  delete rest.color;
  delete rest.secondaryColor;
  delete rest.background;
  if (background) {
    var _rest$style;
    rest.style = Object.assign({
      background: background
    }, (_rest$style = rest.style) !== null && _rest$style !== void 0 ? _rest$style : {});
  }
  return {
    color: color,
    secondary: secondary,
    rest: rest
  };
}
var UpSetJSSkeleton = C$1( k$1(function UpSetJSSkeleton(props, ref) {
  var _prepare = prepare(props),
      color = _prepare.color,
      secondary = _prepare.secondary,
      rest = _prepare.rest;
  var wi = 20;
  var padding = 10;
  var sWidth = 75;
  var sY = 110;
  var cHeight = 100;
  var csX = 85;
  var cOffsets = [10, 20, 35, 60, 65, 80, 90];
  var sOffsets = [50, 30, 15];
  return React.createElement("svg", Object.assign({
    viewBox: "0 0 300 200",
    ref: ref
  }, rest), cOffsets.map(function (offset, i) {
    return React.createElement("rect", {
      key: i,
      x: csX + i * (wi + padding),
      y: offset,
      width: wi,
      height: cHeight - offset,
      fill: color
    });
  }), sOffsets.map(function (offset, i) {
    return React.createElement("rect", {
      key: i,
      x: offset,
      y: sY + i * (wi + padding),
      width: sWidth - offset,
      height: wi,
      fill: color
    });
  }), cOffsets.map(function (_, i) {
    return sOffsets.map(function (_, j) {
      var filled = j === 2 - i || i === 3 && j > 0 || i === 4 && j !== 1 || i === 5 && j < 2 || i === 6;
      return React.createElement("circle", {
        key: i + "x" + j,
        cx: csX + i * (wi + padding) + wi / 2,
        cy: sY + j * (wi + padding) + wi / 2,
        r: wi / 2,
        fill: filled ? color : secondary
      });
    });
  }), React.createElement("rect", {
    x: "182",
    y: "150",
    width: "6",
    height: "30",
    fill: color
  }), React.createElement("rect", {
    x: "212",
    y: "120",
    width: "6",
    height: "60",
    fill: color
  }), React.createElement("rect", {
    x: "242",
    y: "120",
    width: "6",
    height: "30",
    fill: color
  }), React.createElement("rect", {
    x: "272",
    y: "120",
    width: "6",
    height: "60",
    fill: color
  }));
}));
var VennDiagramSkeleton = C$1( k$1(function VennDiagramSkeleton(props, ref) {
  var _prepare = prepare(props),
      color = _prepare.color,
      secondary = _prepare.secondary,
      rest = _prepare.rest;
  var padding = 10;
  var l = layoutImpl(3, 300 - padding * 2, 3200 - padding * 2);
  return React.createElement("svg", Object.assign({
    viewBox: "0 0 300 200",
    ref: ref
  }, rest), l.sets.map(function (set, i) {
    return React.createElement("circle", {
      key: i,
      cx: set.cx,
      cy: set.cy + padding,
      r: set.r,
      fill: secondary
    });
  }), l.sets.map(function (set, i) {
    return React.createElement("circle", {
      key: i,
      cx: set.cx,
      cy: set.cy + padding,
      r: set.r,
      stroke: color,
      fill: "none"
    });
  }));
}));
var KarnaughMapSkeleton = C$1( k$1(function KarnaughMapSkeleton(props, ref) {
  var _prepare = prepare(props),
      rest = _prepare.rest,
      color = _prepare.color,
      secondary = _prepare.secondary;
  var _bounds = bounds(2, {
    width: 270,
    height: 170,
    labelHeight: 20
  }),
      xBefore = _bounds.xBefore,
      yBefore = _bounds.yBefore,
      cell = _bounds.cell,
      hCells = _bounds.hCells,
      vCells = _bounds.vCells;
  var gw = hCells * cell;
  var gh = vCells * cell;
  var v1 = 0.9;
  var v2 = 0.5;
  var v3 = 0.26;
  var v4 = 0.75;
  return React.createElement("svg", Object.assign({
    viewBox: "0 0 300 200",
    ref: ref,
    fontFamily: "sans-serif"
  }, rest), React.createElement("g", {
    transform: "translate(" + (xBefore + 10) + "," + (yBefore + 10) + ")"
  }, React.createElement("text", {
    x: cell * 0.5,
    y: -3,
    fill: color,
    textAnchor: "middle"
  }, "A"), React.createElement("text", {
    x: cell * 1.5,
    y: -3,
    fill: color,
    textAnchor: "middle",
    style: {
      textDecoration: 'overline'
    }
  }, "A"), React.createElement("text", {
    x: -3,
    y: cell * 0.5,
    fill: color,
    textAnchor: "end",
    dominantBaseline: "central"
  }, "B"), React.createElement("text", {
    x: -3,
    y: cell * 1.5,
    fill: color,
    textAnchor: "end",
    dominantBaseline: "central",
    style: {
      textDecoration: 'overline'
    }
  }, "B"), React.createElement("rect", {
    x: cell * 0.1,
    y: cell * (1 - v1),
    height: cell * v1,
    width: cell * 0.8,
    fill: secondary
  }), React.createElement("rect", {
    x: cell * 1.1,
    y: cell * (1 - v2),
    height: cell * v2,
    width: cell * 0.8,
    fill: secondary
  }), React.createElement("rect", {
    x: cell * 0.1,
    y: cell * (1 - v3 + 1),
    height: cell * v3,
    width: cell * 0.8,
    fill: secondary
  }), React.createElement("rect", {
    x: cell * 1.1,
    y: cell * (1 - v4 + 1),
    height: cell * v4,
    width: cell * 0.8,
    fill: secondary
  }), React.createElement("path", {
    d: "M0,0 l" + gw + ",0 l0," + gh + " l" + -gw + ",0 l0," + -gh + " M" + gw / 2 + ",0 l0," + gh + " M0," + gh / 2 + " l" + gw + ",0",
    fill: "none",
    stroke: color
  })));
}));
var DEG2RAD = 1 / 180 * Math.PI;
function pointAtCircle(cx, cy, radius, angle) {
  return {
    x: cx + Math.cos(angle * DEG2RAD) * radius,
    y: cy + Math.sin(angle * DEG2RAD) * radius
  };
}
function center(circles) {
  var sumX = circles.reduce(function (acc, a) {
    return acc + a.x;
  }, 0);
  var sumY = circles.reduce(function (acc, a) {
    return acc + a.y;
  }, 0);
  return {
    x: sumX / circles.length,
    y: sumY / circles.length
  };
}
function angleAtCircle(p, c) {
  var x = p.x - c.x;
  var y = p.y - c.y;
  return Math.atan2(y, x) / DEG2RAD;
}
function createVennJSAdapter(layout, options) {
  return {
    maxSets: Infinity,
    compute: function compute(sets, combinations, width, height) {
      var overlaps = combinations.map(function (c) {
        return {
          sets: Array.from(c.sets).map(function (s) {
            return s.name;
          }),
          size: c.cardinality
        };
      });
      var r = layout(overlaps, Object.assign({}, {
        width: width,
        height: height,
        distinct: true
      }, options !== null && options !== void 0 ? options : {}));
      var singleSets = r.filter(function (d) {
        return d.data.sets.length === 1;
      });
      var setNames = new Map(sets.map(function (d, i) {
        return [d.name, i];
      }));
      var setCircles = singleSets.map(function (d) {
        return d.circles[0];
      });
      var eulerCenter = center(setCircles);
      var asArc = function asArc(a) {
        return {
          x2: a.p1.x,
          y2: a.p1.y,
          cx: a.circle.x,
          cy: a.circle.y,
          sweep: true,
          large: a.width > a.circle.radius,
          ref: setCircles.findIndex(function (d) {
            return Math.abs(d.x - a.circle.x) < 0.05 && Math.abs(d.y - a.circle.y) < 0.05;
          }),
          mode: 'i'
        };
      };
      return {
        sets: singleSets.map(function (d) {
          var c = d.circles[0];
          var angle = angleAtCircle(c, eulerCenter);
          return {
            cx: c.x,
            cy: c.y,
            r: c.radius,
            align: angle > 90 ? 'end' : 'start',
            verticalAlign: 'bottom',
            text: pointAtCircle(c.x, c.y, c.radius * 1.1, angle)
          };
        }),
        intersections: r.map(function (d) {
          var arcs = d.arcs;
          var text = {
            x: d.text.x,
            y: d.text.y
          };
          if (arcs.length === 0) {
            return {
              sets: d.data.sets.map(function (s) {
                return setNames.get(s);
              }),
              text: text,
              x1: 0,
              y1: 0,
              arcs: []
            };
          }
          if (arcs.length === 1) {
            var c = d.arcs[0].circle;
            return {
              sets: d.data.sets.map(function (s) {
                return setNames.get(s);
              }),
              text: text,
              x1: d.arcs[0].p2.x,
              y1: c.y - c.radius,
              arcs: [asArc(d.arcs[0]), Object.assign(asArc(d.arcs[0]), {
                y2: c.y - c.radius
              })],
              path: d.distinctPath || d.path
            };
          }
          return {
            sets: d.data.sets.map(function (s) {
              return setNames.get(s);
            }),
            text: text,
            x1: d.arcs[0].p2.x,
            y1: d.arcs[0].p2.y,
            arcs: d.arcs.map(function (e) {
              return asArc(e);
            }),
            path: d.distinctPath || d.path
          };
        })
      };
    }
  };
}
function widthRatios(value) {
  return value == null || Array.isArray(value) && value.length === 3 && value.every(function (v) {
    return typeof v === 'number';
  });
}
function heightRatios(value) {
  return value == null || Array.isArray(value) && value.length === 2 && value.every(function (v) {
    return typeof v === 'number';
  });
}
function sets$6(value) {
  return Array.isArray(value) && value.every(isSet);
}
function combinations(value) {
  return value == null || Array.isArray(value) && value.every(isSetCombination) || isGenerateSetCombinationOptions(value);
}
function selection(value) {
  return value == null || Array.isArray(value) || isSetLike(value);
}
function onHover(value) {
  return value == null || typeof value === 'function';
}
function onClick(value) {
  return value == null || typeof value === 'function';
}
function queries(value) {
  return !value || Array.isArray(value) && value.every(isUpSetQuery);
}
function stringOrFalse(value) {
  return value == null || typeof value === 'string' || value === false;
}
function theme(value) {
  return value == null || value === 'light' || value === 'dark' || value === 'vega';
}
function classNames(value) {
  return value == null || Object.keys(value).every(function (k) {
    return MULTI_STYLE_KEYS.includes(k) && typeof value[k] === 'string';
  });
}
function fontSizes(value) {
  return value == null || Object.keys(value).every(function (k) {
    return FONT_SIZES_KEYS.includes(k) && typeof value[k] === 'string';
  });
}
function numericScale(value) {
  return value == null || value === 'linear' || value === 'log' || typeof value === 'function';
}
function bandScale$1(value) {
  return value == null || value === 'band' || typeof value === 'function';
}
function axisOffset(value) {
  return value == null || value === 'auto' || typeof value === 'number';
}
function style(value) {
  return value == null || typeof value === 'object';
}
function styles(value) {
  return value == null || Object.keys(value).every(function (k) {
    return MULTI_STYLE_KEYS.includes(k);
  });
}
function exportButtons(value) {
  return value == null || typeof value === 'boolean' || Object.keys(value).every(function (k) {
    return EXPORT_OPTION_KEYS.includes(k) && typeof value[k] === 'boolean';
  });
}
var validators = {
  __proto__: null,
  widthRatios: widthRatios,
  heightRatios: heightRatios,
  sets: sets$6,
  combinations: combinations,
  selection: selection,
  onHover: onHover,
  onClick: onClick,
  queries: queries,
  stringOrFalse: stringOrFalse,
  theme: theme,
  classNames: classNames,
  fontSizes: fontSizes,
  numericScale: numericScale,
  bandScale: bandScale$1,
  axisOffset: axisOffset,
  style: style,
  styles: styles,
  exportButtons: exportButtons
};

function quantilesInterpolate(arr, length, interpolate) {
  var n1 = length - 1;
  var compute = function compute(q) {
    var index = q * n1;
    var lo = Math.floor(index);
    var h = index - lo;
    var a = arr[lo];
    return h === 0 ? a : interpolate(a, arr[Math.min(lo + 1, n1)], h);
  };
  return {
    q1: compute(0.25),
    median: compute(0.5),
    q3: compute(0.75)
  };
}
function quantilesType7(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  return quantilesInterpolate(arr, length, function (a, b, alpha) {
    return a + alpha * (b - a);
  });
}
function quantilesLinear(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  return quantilesInterpolate(arr, length, function (i, j, fraction) {
    return i + (j - i) * fraction;
  });
}
function quantilesLower(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  return quantilesInterpolate(arr, length, function (i) {
    return i;
  });
}
function quantilesHigher(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  return quantilesInterpolate(arr, length, function (_, j) {
    return j;
  });
}
function quantilesNearest(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  return quantilesInterpolate(arr, length, function (i, j, fraction) {
    return fraction < 0.5 ? i : j;
  });
}
function quantilesMidpoint(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  return quantilesInterpolate(arr, length, function (i, j) {
    return (i + j) * 0.5;
  });
}
function fivenum(arr, length) {
  if (length === void 0) {
    length = arr.length;
  }
  var n = length;
  var n4 = Math.floor((n + 3) / 2) / 2;
  var compute = function compute(d) {
    return 0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);
  };
  return {
    q1: compute(n4),
    median: compute((n + 1) / 2),
    q3: compute(n + 1 - n4)
  };
}
var methodLookup = {
  hinges: fivenum,
  fivenum: fivenum,
  type7: quantilesType7,
  quantiles: quantilesType7,
  linear: quantilesLinear,
  lower: quantilesLower,
  higher: quantilesHigher,
  nearest: quantilesNearest,
  midpoint: quantilesMidpoint
};
function determineQuantiles(q) {
  if (typeof q === 'function') {
    return q;
  }
  return methodLookup[q] || quantilesType7;
}
function determineStatsOptions(options) {
  var _options$coef, _options$quantiles;
  if (options === void 0) {
    options = {};
  }
  return {
    coef: (_options$coef = options.coef) !== null && _options$coef !== void 0 ? _options$coef : 1.5,
    quantiles: determineQuantiles((_options$quantiles = options.quantiles) !== null && _options$quantiles !== void 0 ? _options$quantiles : 'type7')
  };
}
function boxplot(data, options) {
  if (options === void 0) {
    options = {};
  }
  var min = Number.POSITIVE_INFINITY;
  var max = Number.NEGATIVE_INFINITY;
  var sum = 0;
  var valid = 0;
  var length = data.length;
  var _determineStatsOption = determineStatsOptions(options),
      quantiles = _determineStatsOption.quantiles,
      coef = _determineStatsOption.coef;
  var vs = new Float32Array(length);
  for (var i = 0; i < length; ++i) {
    var v = data[i];
    if (v == null || Number.isNaN(v)) {
      continue;
    }
    vs[valid] = v;
    valid++;
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
    sum += v;
  }
  var missing = length - valid;
  var invalid = {
    min: NaN,
    max: NaN,
    mean: NaN,
    missing: missing,
    count: length,
    whiskerHigh: NaN,
    whiskerLow: NaN,
    outlier: [],
    median: NaN,
    q1: NaN,
    q3: NaN
  };
  if (valid === 0) {
    return invalid;
  }
  var s = vs.subarray(0, valid).sort(function (a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  });
  var _quantiles = quantiles(s, valid),
      median = _quantiles.median,
      q1 = _quantiles.q1,
      q3 = _quantiles.q3;
  var iqr = q3 - q1;
  var coefValid = typeof coef === 'number' && coef > 0;
  var left = coefValid ? Math.max(min, q1 - coef * iqr) : min;
  var right = coefValid ? Math.min(max, q3 + coef * iqr) : max;
  var outlier = [];
  var whiskerLow = left;
  for (var _i = 0; _i < valid; ++_i) {
    var _v = s[_i];
    if (left < _v) {
      whiskerLow = _v;
      break;
    }
    if (outlier.length === 0 || outlier[outlier.length - 1] !== _v) {
      outlier.push(_v);
    }
  }
  var whiskerHigh = right;
  var reversedOutliers = [];
  for (var _i2 = valid - 1; _i2 >= 0; --_i2) {
    var _v2 = s[_i2];
    if (_v2 < right) {
      whiskerHigh = _v2;
      break;
    }
    if ((reversedOutliers.length === 0 || reversedOutliers[reversedOutliers.length - 1] !== _v2) && (outlier.length === 0 || outlier[outlier.length - 1] !== _v2)) {
      reversedOutliers.push(_v2);
    }
  }
  return {
    min: min,
    max: max,
    count: length,
    missing: missing,
    mean: sum / valid,
    whiskerHigh: whiskerHigh,
    whiskerLow: whiskerLow,
    outlier: outlier.concat(reversedOutliers.reverse()),
    median: median,
    q1: q1,
    q3: q3
  };
}
function denormalize(range) {
  var delta = range[1] - range[0];
  return function (v) {
    return v * delta + range[0];
  };
}
function normalize(domain) {
  var delta = domain[1] - domain[0];
  return function (v) {
    return (v - domain[0]) / delta;
  };
}
function colorGen(dark) {
  var schemeDark2 = ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d'];
  var schemeSet2 = ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494'];
  var set = dark ? schemeDark2.concat(schemeSet2) : schemeSet2.concat(schemeDark2);
  var acc = 0;
  return function () {
    return set[acc++ % set.length];
  };
}
function bin(hist, values) {
  var map = new Map(hist.map(function (bin) {
    return [bin.value, 0];
  }));
  values.forEach(function (value) {
    if (value == null) {
      return;
    }
    var key = value.toString();
    if (!map.has(key)) {
      return;
    }
    map.set(key, map.get(key) + 1);
  });
  return map;
}
function categoricalHistogram(values, categories, base, dark) {
  if (dark === void 0) {
    dark = false;
  }
  var nextColor = colorGen(dark);
  var generateCat = function generateCat(value) {
    return {
      value: value,
      label: value.length > 0 ? "" + value[0].toUpperCase() + value.slice(1) : value,
      color: nextColor()
    };
  };
  var hist = categories.map(function (cat) {
    return Object.assign({
      count: 0,
      acc: 0,
      percentage: 0
    }, generateCat(typeof cat === 'string' ? cat : cat.value), typeof cat === 'string' ? {} : cat);
  });
  var map = bin(hist, values);
  var baseMap = base ? bin(hist, base) : null;
  var total = Array.from(map.values()).reduce(function (acc, v) {
    return acc + v;
  }, 0);
  var acc = 0;
  hist.forEach(function (bin) {
    bin.acc = acc;
    bin.count = map.get(bin.value);
    bin.percentage = bin.count / total;
    acc += baseMap ? baseMap.get(bin.value) : bin.count;
  });
  return hist;
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function round2(v) {
  return Math.round(v * 100) / 100;
}
var defaultFormatter = function defaultFormatter(v) {
  return v.toFixed(2);
};
function _toString(b, nf) {
  return "Min: " + nf(b.min) + ", 25% Quantile: " + nf(b.q1) + ", Median: " + nf(b.median) + ", 75% Quantile: " + nf(b.q3) + ", Max: " + nf(b.max);
}
var Boxplot = function Boxplot(p) {
  var _p$theme = p.theme,
      theme = _p$theme === void 0 ? 'light' : _p$theme,
      _p$mode = p.mode,
      mode = _p$mode === void 0 ? 'normal' : _p$mode,
      boxStyle = p.boxStyle,
      lineStyle = p.lineStyle,
      outlierStyle = p.outlierStyle,
      _p$margin = p.margin,
      margin = _p$margin === void 0 ? 0 : _p$margin,
      _p$boxPadding = p.boxPadding,
      bpp = _p$boxPadding === void 0 ? 0.1 : _p$boxPadding,
      _p$outlierRadius = p.outlierRadius,
      outlierRadius = _p$outlierRadius === void 0 ? 3 : _p$outlierRadius,
      _p$numberFormat = p.numberFormat,
      nf = _p$numberFormat === void 0 ? defaultFormatter : _p$numberFormat,
      options = _objectWithoutPropertiesLoose$1(p, ["theme", "mode", "boxStyle", "lineStyle", "outlierStyle", "margin", "boxPadding", "outlierRadius", "numberFormat"]);
  var b = Array.isArray(p.values) ? boxplot(p.values, options) : p.values;
  if (Number.isNaN(b.median)) {
    return React.createElement("g", null);
  }
  var hor = p.orient !== 'vertical';
  var n = normalize([p.min, p.max]);
  var dn = denormalize([0, hor ? p.width : p.height]);
  var scale = function scale(v) {
    return round2(dn(n(v)));
  };
  var s = {
    max: scale(b.max),
    avg: scale(b.mean),
    med: scale(b.median),
    min: scale(b.min),
    q1: scale(b.q1),
    q3: scale(b.q3),
    wh: scale(b.whiskerHigh),
    wl: scale(b.whiskerLow)
  };
  var title = p.tooltips !== false && React.createElement("title", null, _toString(b, nf));
  var inner = getDefaultTheme(theme).notMemberColor;
  var styles = {
    box: Object.assign({
      fill: inner
    }, boxStyle),
    line: Object.assign({
      fill: 'none',
      stroke: theme === 'light' ? 'black' : '#cccccc'
    }, lineStyle),
    outlier: Object.assign({
      fill: inner
    }, outlierStyle)
  };
  if (hor) {
    var c = p.height / 2;
    var bp = round2(p.height * bpp) + margin;
    var hp = p.height - bp;
    var w1 = "M" + s.wl + "," + margin + " l0," + (p.height - margin * 2) + " M" + s.wl + "," + c + " L" + s.q1 + "," + c;
    var w2 = "M" + s.q3 + "," + c + " L" + s.wh + "," + c + " M" + s.wh + "," + margin + " L" + s.wh + "," + (p.height - margin);
    var box = "M" + s.q1 + "," + bp + " L" + s.q3 + "," + bp + " L" + s.q3 + "," + hp + " L" + s.q1 + "," + hp + " L" + s.q1 + "," + bp + " M" + s.med + "," + bp + " l0," + (hp - bp);
    var path = React.createElement("path", {
      d: w1 + " " + w2 + " " + box,
      style: styles.line
    });
    if (mode === 'indicator') {
      return path;
    }
    return React.createElement("g", null, title, mode === 'normal' && React.createElement("rect", {
      x: s.q1,
      y: bp,
      width: s.q3 - s.q1,
      height: p.height - 2 * bp,
      style: styles.box
    }), path, b.outlier.map(function (o) {
      return React.createElement("circle", {
        key: o,
        r: outlierRadius,
        cy: c,
        cx: scale(o),
        style: styles.outlier
      }, React.createElement("title", null, "$", nf(o)));
    }));
  }
  {
    var _c = p.width / 2;
    var _bp = round2(p.width * bpp) + margin;
    var wp = p.width - _bp;
    var _w = "M" + margin + "," + s.wl + " l" + (p.width - 2 * margin) + ",0 M" + _c + "," + s.wl + " L" + _c + "," + s.q1;
    var _w2 = "M" + _c + "," + s.q3 + " L" + _c + "," + s.wh + " M" + margin + "," + s.wh + " L" + (p.width - margin) + "," + s.wh;
    var _box = "M" + _bp + "," + s.q1 + " L" + _bp + "," + s.q3 + " l" + (wp - _bp) + ",0 L" + wp + "," + s.q1 + " L" + _bp + "," + s.q1 + " M" + _bp + "," + s.med + " l" + (wp - _bp) + ",0";
    var _path = React.createElement("path", {
      d: _w + " " + _w2 + " " + _box,
      style: styles.line
    });
    if (mode === 'indicator') {
      return _path;
    }
    return React.createElement("g", null, title, mode === 'normal' && React.createElement("rect", {
      y: s.q1,
      x: _bp,
      height: s.q3 - s.q1,
      width: p.width - 2 * _bp,
      style: styles.box
    }), _path, b.outlier.map(function (o) {
      return React.createElement("circle", {
        key: o,
        r: outlierRadius,
        cx: _c,
        cy: scale(o),
        style: styles.outlier
      }, React.createElement("title", null, "$", nf(o)));
    }));
  }
};
var BoxplotMemo = React.memo(Boxplot);
function boxplotAddon(prop, elems, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 100 : _ref$size,
      position = _ref.position,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? prop.toString() : _ref$name,
      extras = _objectWithoutPropertiesLoose$1(_ref, ["size", "position", "name"]);
  var acc = typeof prop === 'function' ? prop : function (v) {
    return v[prop];
  };
  var min = Number.POSITIVE_INFINITY;
  var max = Number.NEGATIVE_INFINITY;
  if (Array.isArray(elems)) {
    elems.forEach(function (elem) {
      var v = acc(elem);
      if (v == null || Number.isNaN(v)) {
        return;
      }
      if (v < min) {
        min = v;
      }
      if (v > max) {
        max = v;
      }
    });
  } else {
    var d = elems;
    min = d.min;
    max = d.max;
  }
  return {
    name: name,
    position: position,
    size: size,
    createOnHandlerData: function createOnHandlerData(set) {
      var b = boxplot(set.elems.map(acc), extras);
      return {
        id: 'boxplot',
        name: name,
        value: Object.assign(_extends$2({}, b, {
          toString: function toString() {
            var _extras$numberFormat;
            return _toString(this, (_extras$numberFormat = extras.numberFormat) !== null && _extras$numberFormat !== void 0 ? _extras$numberFormat : defaultFormatter);
          }
        }), b)
      };
    },
    render: function render(_ref2) {
      var width = _ref2.width,
          height = _ref2.height,
          set = _ref2.set,
          theme = _ref2.theme;
      var values = set.elems.map(acc);
      return React.createElement(BoxplotMemo, Object.assign({
        values: values,
        width: width,
        height: height,
        min: min,
        max: max,
        theme: theme
      }, extras));
    },
    renderSelection: function renderSelection(_ref3) {
      var width = _ref3.width,
          height = _ref3.height,
          overlap = _ref3.overlap,
          selectionColor = _ref3.selectionColor,
          theme = _ref3.theme;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var values = overlap.map(acc);
      return React.createElement(BoxplotMemo, Object.assign({
        values: values,
        width: width,
        height: height,
        min: min,
        max: max,
        mode: "box",
        lineStyle: {
          stroke: selectionColor,
          strokeWidth: 2
        },
        outlierStyle: {
          fill: selectionColor
        },
        theme: theme
      }, extras));
    },
    renderQuery: function renderQuery(_ref4) {
      var width = _ref4.width,
          height = _ref4.height,
          overlap = _ref4.overlap,
          query = _ref4.query,
          secondary = _ref4.secondary,
          index = _ref4.index,
          theme = _ref4.theme;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var values = overlap.map(acc);
      return React.createElement(BoxplotMemo, Object.assign({
        values: values,
        width: width,
        height: height,
        min: min,
        max: max,
        mode: secondary ? 'indicator' : 'box',
        margin: secondary ? index + 2 : 0,
        lineStyle: {
          stroke: query.color,
          strokeWidth: secondary ? 1 : 2
        },
        outlierStyle: {
          fill: query.color
        },
        theme: theme
      }, extras));
    }
  };
}
function boxplotAggregatedAddon(acc, domain, _temp2) {
  var _ref5 = _temp2 === void 0 ? {} : _temp2,
      _ref5$size = _ref5.size,
      size = _ref5$size === void 0 ? 100 : _ref5$size,
      position = _ref5.position,
      _ref5$name = _ref5.name,
      name = _ref5$name === void 0 ? 'BoxPlot' : _ref5$name,
      extras = _objectWithoutPropertiesLoose$1(_ref5, ["size", "position", "name"]);
  var min = domain.min;
  var max = domain.max;
  return {
    name: name,
    position: position,
    size: size,
    createOnHandlerData: function createOnHandlerData(set) {
      var b = acc(set.elems);
      b.toString = function () {
        var _extras$numberFormat2;
        return _toString(this, (_extras$numberFormat2 = extras.numberFormat) !== null && _extras$numberFormat2 !== void 0 ? _extras$numberFormat2 : defaultFormatter);
      };
      return {
        id: 'boxplot',
        name: name,
        value: b
      };
    },
    render: function render(_ref6) {
      var width = _ref6.width,
          height = _ref6.height,
          set = _ref6.set,
          theme = _ref6.theme;
      var values = acc(set.elems);
      return React.createElement(BoxplotMemo, Object.assign({
        values: values,
        width: width,
        height: height,
        min: min,
        max: max,
        theme: theme
      }, extras));
    },
    renderSelection: function renderSelection(_ref7) {
      var width = _ref7.width,
          height = _ref7.height,
          overlap = _ref7.overlap,
          selectionColor = _ref7.selectionColor,
          theme = _ref7.theme;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var values = acc(overlap);
      return React.createElement(BoxplotMemo, Object.assign({
        values: values,
        width: width,
        height: height,
        min: min,
        max: max,
        mode: "box",
        lineStyle: {
          stroke: selectionColor,
          strokeWidth: 2
        },
        outlierStyle: {
          fill: selectionColor
        },
        theme: theme
      }, extras));
    },
    renderQuery: function renderQuery(_ref8) {
      var width = _ref8.width,
          height = _ref8.height,
          overlap = _ref8.overlap,
          query = _ref8.query,
          secondary = _ref8.secondary,
          index = _ref8.index,
          theme = _ref8.theme;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var values = acc(overlap);
      return React.createElement(BoxplotMemo, Object.assign({
        values: values,
        width: width,
        height: height,
        min: min,
        max: max,
        mode: secondary ? 'indicator' : 'box',
        margin: secondary ? index + 2 : 0,
        lineStyle: {
          stroke: query.color,
          strokeWidth: secondary ? 1 : 2
        },
        outlierStyle: {
          fill: query.color
        },
        theme: theme
      }, extras));
    }
  };
}
function isGiven(p) {
  return Array.isArray(p.bins);
}
function _toString$1(cat) {
  return cat.map(function (bin) {
    return bin.label + ": " + bin.count;
  }).join(', ');
}
var Categorical = function Categorical(p) {
  var _p$base$length, _p$base;
  var _p$margin = p.margin,
      margin = _p$margin === void 0 ? 0 : _p$margin,
      _p$rectStyle = p.rectStyle,
      rectStyle = _p$rectStyle === void 0 ? {} : _p$rectStyle;
  var bins = isGiven(p) ? p.bins : categoricalHistogram(p.values, p.categories, p.base, p.theme === 'dark');
  var n = normalize([0, isGiven(p) ? p.bins.reduce(function (acc, v) {
    return acc + v.count;
  }, 0) : (_p$base$length = (_p$base = p.base) === null || _p$base === void 0 ? void 0 : _p$base.length) !== null && _p$base$length !== void 0 ? _p$base$length : p.values.length]);
  var hor = p.orient !== 'vertical';
  var dn = denormalize([0, hor ? p.width : p.height]);
  var scale = function scale(v) {
    return dn(n(v));
  };
  if (hor) {
    return React.createElement("g", null, bins.map(function (bin) {
      return React.createElement("rect", {
        key: bin.value,
        x: scale(bin.acc),
        width: scale(bin.count),
        y: margin,
        height: p.height - 2 * margin,
        style: Object.assign({
          fill: bin.color
        }, rectStyle)
      }, p.tooltips !== false && React.createElement("title", null, bin.label + ": " + bin.count));
    }));
  }
  return React.createElement("g", null, bins.map(function (bin) {
    return React.createElement("rect", {
      key: bin.value,
      y: scale(bin.acc),
      height: scale(bin.count),
      x: margin,
      width: p.width - 2 * margin,
      style: Object.assign({
        fill: bin.color
      }, rectStyle)
    }, p.tooltips !== false && React.createElement("title", null, bin.label + ": " + bin.count));
  }));
};
var CategoricalMemo = React.memo(Categorical);
var lightOverlap = 'rgba(255,255,255,0.2)';
var darkOverlap = 'rgba(0,0,0,0.1)';
function categoricalAddon(prop, elems, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 100 : _ref$size,
      position = _ref.position,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? prop.toString() : _ref$name,
      extras = _objectWithoutPropertiesLoose$1(_ref, ["size", "position", "name"]);
  var acc = typeof prop === 'function' ? prop : function (v) {
    return v[prop];
  };
  var categories = [];
  if (Array.isArray(elems)) {
    var cats = new Set();
    elems.forEach(function (elem) {
      var v = acc(elem);
      if (v == null) {
        return;
      }
      cats.add(v.toString());
    });
    categories = Array.from(cats).sort();
  } else {
    categories = elems.categories;
  }
  return {
    name: name,
    position: position,
    size: size,
    createOnHandlerData: function createOnHandlerData(set) {
      var b = categoricalHistogram(set.elems.map(acc), categories, undefined, extras.theme === 'dark');
      b.toString = function () {
        return _toString$1(this);
      };
      return {
        id: 'categorical',
        name: name,
        value: b
      };
    },
    render: function render(_ref2) {
      var width = _ref2.width,
          height = _ref2.height,
          set = _ref2.set,
          theme = _ref2.theme;
      var values = set.elems.map(acc);
      return React.createElement(CategoricalMemo, Object.assign({
        values: values,
        categories: categories,
        width: width,
        height: height,
        theme: theme
      }, extras));
    },
    renderSelection: function renderSelection(_ref3) {
      var width = _ref3.width,
          height = _ref3.height,
          set = _ref3.set,
          theme = _ref3.theme,
          overlap = _ref3.overlap,
          selectionColor = _ref3.selectionColor;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var base = set.elems.map(acc);
      var values = overlap.map(acc);
      return React.createElement(CategoricalMemo, Object.assign({
        values: values,
        base: base,
        categories: categories,
        width: width,
        height: height,
        theme: theme,
        rectStyle: {
          stroke: selectionColor,
          strokeWidth: 2,
          fill: theme === 'light' ? darkOverlap : lightOverlap
        }
      }, extras));
    },
    renderQuery: function renderQuery(_ref4) {
      var width = _ref4.width,
          height = _ref4.height,
          overlap = _ref4.overlap,
          set = _ref4.set,
          query = _ref4.query,
          secondary = _ref4.secondary,
          index = _ref4.index,
          theme = _ref4.theme;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var base = set.elems.map(acc);
      var values = overlap.map(acc);
      return React.createElement(CategoricalMemo, Object.assign({
        values: values,
        base: base,
        categories: categories,
        width: width,
        height: height,
        margin: secondary ? index + 2 : 0,
        rectStyle: {
          stroke: query.color,
          fill: theme === 'light' ? darkOverlap : lightOverlap
        },
        theme: theme
      }, extras));
    }
  };
}
function categoricalAggregatedAddon(acc, _temp2) {
  var _ref5 = _temp2 === void 0 ? {} : _temp2,
      _ref5$size = _ref5.size,
      size = _ref5$size === void 0 ? 100 : _ref5$size,
      position = _ref5.position,
      _ref5$name = _ref5.name,
      name = _ref5$name === void 0 ? 'Histogram' : _ref5$name,
      extras = _objectWithoutPropertiesLoose$1(_ref5, ["size", "position", "name"]);
  return {
    name: name,
    position: position,
    size: size,
    createOnHandlerData: function createOnHandlerData(set) {
      var b = acc(set.elems);
      return {
        id: 'categorical',
        name: name,
        value: Object.assign(_extends$2({}, b, {
          toString: function toString() {
            return _toString$1(this);
          }
        }), b)
      };
    },
    render: function render(_ref6) {
      var width = _ref6.width,
          height = _ref6.height,
          set = _ref6.set,
          theme = _ref6.theme;
      var values = acc(set.elems);
      return React.createElement(CategoricalMemo, Object.assign({
        bins: values,
        width: width,
        height: height,
        theme: theme
      }, extras));
    },
    renderSelection: function renderSelection(_ref7) {
      var width = _ref7.width,
          height = _ref7.height,
          theme = _ref7.theme,
          overlap = _ref7.overlap,
          selectionColor = _ref7.selectionColor;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var values = acc(overlap);
      return React.createElement(CategoricalMemo, Object.assign({
        bins: values,
        width: width,
        height: height,
        theme: theme,
        rectStyle: {
          stroke: selectionColor,
          strokeWidth: 2,
          fill: theme === 'light' ? darkOverlap : lightOverlap
        }
      }, extras));
    },
    renderQuery: function renderQuery(_ref8) {
      var width = _ref8.width,
          height = _ref8.height,
          overlap = _ref8.overlap,
          query = _ref8.query,
          secondary = _ref8.secondary,
          index = _ref8.index,
          theme = _ref8.theme;
      if (overlap == null || overlap.length === 0) {
        return null;
      }
      var values = acc(overlap);
      return React.createElement(CategoricalMemo, Object.assign({
        bins: values,
        width: width,
        height: height,
        margin: secondary ? index + 2 : 0,
        rectStyle: {
          stroke: query.color,
          fill: theme === 'light' ? darkOverlap : lightOverlap
        },
        theme: theme
      }, extras));
    }
  };
}

function boxplotAddon$1(prop, elems, options) {
  if (options === void 0) {
    options = {};
  }
  return boxplotAddon(prop, elems, options);
}
function boxplotAggregatedAddon$1(acc, domain, options) {
  if (options === void 0) {
    options = {};
  }
  return boxplotAggregatedAddon(acc, domain, options);
}

function categoricalAddon$1(prop, elems, options) {
  if (options === void 0) {
    options = {};
  }
  return categoricalAddon(prop, elems, options);
}
function categoricalAggregatedAddon$1(acc, options) {
  if (options === void 0) {
    options = {};
  }
  return categoricalAggregatedAddon(acc, options);
}

function fillDefaults$1(props) {
  var p = props;
  return fillDefaults(p);
}
function fillVennDiagramDefaults$1(props) {
  var p = props;
  return fillVennDiagramDefaults(p);
}
function fillKarnaughMapDefaults$1(props) {
  var p = props;
  return fillKarnaughMapDefaults(p);
}
function render(node, props) {
  var p = props;
  H(h(UpSetJS, p), node);
}
function renderVennDiagram(node, props) {
  var p = props;
  H(h(VennDiagram, p), node);
}
function renderKarnaughMap(node, props) {
  var p = props;
  H(h(KarnaughMap, p), node);
}
function renderSkeleton(node, props) {
  var p = props;
  H(h(UpSetJSSkeleton, p), node);
}
function renderVennDiagramSkeleton(node, props) {
  var p = props;
  H(h(VennDiagramSkeleton, p), node);
}
function renderKarnaughMapSkeleton(node, props) {
  var p = props;
  H(h(KarnaughMapSkeleton, p), node);
}
var renderUpSet = render;
function hydrate(node, props) {
  var p = props;
  I(h(UpSetJS, p), node);
}
function hydrateVennDiagram(node, props) {
  var p = props;
  I(h(VennDiagram, p), node);
}
function hydrateKarnaughMap(node, props) {
  var p = props;
  I(h(KarnaughMap, p), node);
}
function hydrateSkeleton(node, props) {
  var p = props;
  I(h(UpSetJSSkeleton, p), node);
}
function hydrateVennDiagramSkeleton(node, props) {
  var p = props;
  I(h(VennDiagramSkeleton, p), node);
}
function hydrateKarnaughMapSkeleton(node, props) {
  var p = props;
  I(h(KarnaughMapSkeleton, p), node);
}
var hydrateUpSet = hydrate;
function exportSVG$1(node, options) {
  return exportSVG(node, options);
}
function downloadUrl$1(url, title, doc) {
  downloadUrl(url, title, doc);
}
function toUpSetJSDump$1(dump, elements, props, author, mode) {
  return toUpSetJSDump(dump, elements, props, author, mode);
}
function toUpSetJSStaticDump$1(dump, props, author, mode) {
  return toUpSetJSStaticDump(dump, props, author, mode);
}

export { asCombination, asCombinations, asSet, asSets, bandScale, boxplot, boxplotAddon$1 as boxplotAddon, boxplotAggregatedAddon$1 as boxplotAggregatedAddon, categoricalAddon$1 as categoricalAddon, categoricalAggregatedAddon$1 as categoricalAggregatedAddon, categoricalHistogram, createVennJSAdapter, downloadUrl$1 as downloadUrl, exportSVG$1 as exportSVG, extractFromExpression, extractSets, fillDefaults$1 as fillDefaults, fillKarnaughMapDefaults$1 as fillKarnaughMapDefaults, fillVennDiagramDefaults$1 as fillVennDiagramDefaults, fromDump, fromIndicesArray, fromSetName, fromStaticDump, generateCombinations, getDefaultTheme, hydrate, hydrateKarnaughMap, hydrateKarnaughMapSkeleton, hydrateSkeleton, hydrateUpSet, hydrateVennDiagram, hydrateVennDiagramSkeleton, isCalcQuery, isElemQuery, isGenerateSetCombinationOptions, isSet, isSetCombination, isSetLike, isSetQuery, isUpSetQuery, linearScale, logScale, mergeColors, parseColor, validators as propValidators, queryElemOverlap, queryOverlap, render, renderKarnaughMap, renderKarnaughMapSkeleton, renderSkeleton, renderUpSet, renderVennDiagram, renderVennDiagramSkeleton, setElemIntersectionFactory, setElemOverlap, setElemOverlapFactory, setOverlap, setOverlapFactory, toDump, toIndicesArray, toKey, toStaticDump, toUpSetJSDump$1 as toUpSetJSDump, toUpSetJSStaticDump$1 as toUpSetJSStaticDump };
//# sourceMappingURL=upsetjs.esm.js.map
