/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>
 */
interface IBaseSet<T = any> {
    /**
     * name of the set
     */
    readonly name: string;
    /**
     * optional set color
     */
    readonly color?: string;
    /**
     * elements in this set
     */
    readonly elems: readonly T[];
    /**
     * number of elements in the set
     */
    readonly cardinality: number;
    /**
     * custom overlap computation function
     * @param o to compare with
     */
    overlap?(o: ISetLike<T> | readonly T[]): number;
}
interface ISet<T = any> extends IBaseSet<T> {
    /**
     * a fixed set type to separate between sets and set combinations
     */
    readonly type: 'set';
}
interface IBaseSetCombination<T> extends IBaseSet<T> {
    /**
     * sets this set intersection is composed of
     */
    readonly sets: ReadonlySet<ISet<T>>;
    /**
     * number of set in this set intersection
     */
    readonly degree: number;
}
interface ISetIntersection<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'intersection';
}
interface IDistinctSetIntersection<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'distinctIntersection';
}
interface ISetUnion<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'union';
}
interface ISetComposite<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'composite';
}
/**
 * union of all set combination types
 */
declare type ISetCombination<T = any> = ISetIntersection<T> | ISetUnion<T> | ISetComposite<T> | IDistinctSetIntersection<T>;
declare type SetCombinationType = 'intersection' | 'union' | 'composite' | 'distinctIntersection';
/**
 * union of a set or a set combination
 */
declare type ISetLike<T = any> = ISet<T> | ISetCombination<T>;
/**
 * readonly array of sets
 */
declare type ISets<T = any> = readonly ISet<T>[];
/**
 * readonly array of set combinations
 */
declare type ISetCombinations<T = any> = readonly ISetCombination<T>[];
/**
 * readonly array of set like objects
 */
declare type ISetLikes<T = any> = readonly ISetLike<T>[];
/**
 * helper method to generate a key for a given set
 * @param s the set to compute the key for
 */
declare function toKey(s: ISetLike<any>): string;

/**
 * helper method to create proper UpSet.js structures by adding extra properties
 * @param set the set to complete
 */
declare function asSet<T, S extends {
    name: string;
    elems: readonly T[];
}>(set: S): S & ISet<T>;
/**
 * possible set sort orders
 */
declare type SortSetOrder = 'cardinality' | 'name' | 'cardinality:desc' | 'name:asc' | 'cardinality:asc' | 'name:desc';
declare type PostprocessSetOptions = {
    /**
     * order the set by the given criteria
     */
    order?: SortSetOrder;
    /**
     * limit to the top N sets after sorting
     */
    limit?: number;
};
/**
 * helper to create a proper data structures for UpSet.js sets by adding extra properties
 * @param sets set like structures
 * @param options additional postprocessing options
 */
declare function asSets<T, S extends {
    name: string;
    elems: readonly T[];
}>(sets: readonly S[], options?: PostprocessSetOptions): (S & ISet<T>)[];

/**
 * helper method to extract the sets in a set combination from its name, e.g. S1&S2 => S1,S2
 * @param sets the list of possible sets
 * @param symbol the regex to split a name
 */
declare function fromSetName<T>(sets: ISets<T>, symbol?: RegExp): (s: {
    name: string;
}) => ISet<T>[];
/**
 * sort orders for set combinations
 */
declare type SortCombinationOrder = SortSetOrder | 'group' | 'degree' | 'group:asc' | 'group:desc' | 'degree:asc' | 'degree:desc';
declare type SortCombinationOrders = readonly SortCombinationOrder[];
declare type PostprocessCombinationsOptions = {
    /**
     * order the sets combinations by the given criteria
     */
    order?: SortCombinationOrder | SortCombinationOrders;
    /**
     * limit to the top N after sorting
     */
    limit?: number;
};
/**
 * helper to create a proper data structures for UpSet.js sets by adding extra properties
 * @param sets set like structures
 */
declare function asCombination<T, S extends {
    name: string;
    elems: readonly T[];
}>(set: S, type: SetCombinationType, toSets: (s: S) => ISets<T>): S & ISetCombination<T>;
/**
 * helper to create a proper data structures for UpSet.js sets by adding extra properties
 * @param sets set like structures
 * @param type hint for the type of combinations
 * @param toSets resolver of the contained sets
 */
declare function asCombinations<T, S extends {
    name: string;
    elems: readonly T[];
}>(sets: readonly S[], type: SetCombinationType, toSets: (s: S) => ISets<T>): (S & ISetCombination<T>)[];

declare type GenerateSetCombinationsOptions<T = any> = {
    /**
     * type of set combination
     * @default intersection
     */
    type?: SetCombinationType;
    /**
     * minimum number of intersecting sets
     * @default 0
     */
    min?: number;
    /**
     * maximum number of intersecting sets
     * @default Infinity
     */
    max?: number;
    /**
     * include empty intersections
     * @default false
     */
    empty?: boolean;
    /**
     * list of all elements used to compute the elements which aren't part of any given set
     */
    elems?: readonly T[];
    /**
     * alternative to `.elems` by directly specifying the elements that are not part of any set
     * just makes sense with min=0
     */
    notPartOfAnySet?: readonly T[] | number;
    /**
     * optional elem key function
     * @param v
     */
    toElemKey?(v: T): string;
    /**
     * optional color merger
     **/
    mergeColors?: (colors: readonly (string | undefined)[]) => string | undefined;
} & PostprocessCombinationsOptions;
/**
 * generate set intersection/unions for a given list of sets
 * @param sets the sets with their elements
 * @param options additional customization options
 */
declare function generateCombinations<T = any>(sets: ISets<T>, { type, min, max, empty, elems: allElements, notPartOfAnySet, toElemKey, mergeColors, ...postprocess }?: GenerateSetCombinationsOptions<T>): ISetCombinations<T>;

interface ExtractFromExpressionOptions {
    type?: SetCombinationType;
    setOrder?: SortSetOrder;
    combinationOrder?: SortCombinationOrder | SortCombinationOrders;
    joiner?: string;
    /**
     * optional function to identify the same sets
     * @param set the set to generate a key for
     */
    toKey?: (set: ISetLike<unknown>) => string;
}
/**
 * extract sets and combinations out of a given list of static combination information.
 * In addition an accessor is used to specify the set names
 * @param combinations list of combinations
 * @param accessor accessor to get the list of sets the combination belong to
 * @param options hints about the given combinations
 */
declare function extractFromExpression<T extends {
    cardinality: number;
}>(combinations: readonly T[], accessor: (elem: T) => string[], options?: ExtractFromExpressionOptions): {
    sets: ISets<unknown>;
    combinations: readonly (T & ISetCombination<unknown>)[];
};
/**
 * extract sets out of a given element array which have a `.sets` property
 * @param combinations
 * @param options hints about the given combinations
 */
declare function extractFromExpression<T extends {
    sets: string[];
    cardinality: number;
}>(combinations: readonly T[], options?: ExtractFromExpressionOptions): {
    sets: ISets<unknown>;
    combinations: readonly (T & ISetCombination<unknown>)[];
};

/**
 * extract sets out of a given element array, where an accessor is used to specify the set names
 * @param elements list of elements
 * @param acc accessor to get the list of sets the element belong to
 * @param options postprocess options
 */
declare function extractSets<T>(elements: readonly T[], acc: (elem: T) => string[], options?: PostprocessSetOptions): ISets<T>;
/**
 * extract sets out of a given element array which have a `.sets` property
 * @param elements
 * @param options postprocess options
 */
declare function extractSets<T extends {
    sets: string[];
}>(elements: readonly T[], options?: PostprocessSetOptions): ISets<T>;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>
 */
declare type SetOverlap = {
    setA: number;
    setB: number;
    union: number;
    intersection: number;
};
declare type SetElemOverlap<T> = {
    setA: readonly T[];
    setB: readonly T[];
    union: readonly T[];
    intersection: readonly T[];
};
declare function setOverlapFactory<T>(a: Set<T> | readonly T[], toElemKey?: (e: T) => string): (b: Set<T> | readonly T[]) => SetOverlap;
declare function setOverlap<T>(a: Set<T> | readonly T[], b: Set<T> | readonly T[], toElemKey?: (e: T) => string): SetOverlap;
declare function setElemOverlapFactory<T>(a: Set<T> | readonly T[], toElemKey?: (e: T) => string): (b: Set<T> | readonly T[]) => SetElemOverlap<T>;
declare function setElemOverlap<T>(a: Set<T> | readonly T[], b: Set<T> | readonly T[], toElemKey?: (e: T) => string): SetElemOverlap<T>;
declare function setElemIntersectionFactory<T>(a: Set<T> | readonly T[], toElemKey?: (e: T) => string): (b: Set<T> | readonly T[]) => readonly T[];

declare type UpSetElemQuery<T = any> = {
    /**
     * name of this query for the tooltip
     */
    readonly name: string;
    /**
     * color for highlighting
     */
    readonly color: string;
    /**
     * elements within this query
     */
    readonly elems: readonly T[] | Set<T>;
};
declare type UpSetSetQuery<T = any> = {
    /**
     * name of this query for the tooltip
     */
    readonly name: string;
    /**
     * color for highlighting
     */
    readonly color: string;
    /**
     * set to highlight
     */
    readonly set: ISetLike<T>;
};
declare type UpSetCalcQuery<T = any> = {
    /**
     * name of this query for the tooltip
     */
    readonly name: string;
    /**
     * color for highlighting
     */
    readonly color: string;
    /**
     * computes the overlap of the given set to this query
     * @param s the current set to evaluate
     * @return at most `s.cardinality`
     */
    overlap(s: ISetLike<T> | readonly T[]): number;
};
declare type UpSetQuery<T = any> = UpSetElemQuery<T> | UpSetCalcQuery<T> | UpSetSetQuery<T>;
declare type UpSetQueries<T = any> = readonly UpSetQuery<T>[];
declare function isElemQuery<T>(q: UpSetQuery<T>): q is UpSetElemQuery<T>;
declare function isCalcQuery<T>(q: UpSetQuery<T>): q is UpSetCalcQuery<T>;
declare function isSetQuery<T>(q: UpSetQuery<T>): q is UpSetSetQuery<T>;
/**
 * helper method to create an overlap function for a given query
 * @param query the query
 * @param what type of overlap
 * @param toElemKey optional key function
 */
declare function queryOverlap<T>(query: UpSetQuery<T>, what: keyof SetOverlap, toElemKey?: (e: T) => string): (s: ISet<T> | ISetIntersection<T> | ISetUnion<T> | ISetComposite<T> | IDistinctSetIntersection<T> | readonly T[]) => number;
/**
 * helper method to create an overlap function of elements for a given query
 * @param query the query
 * @param what type of overlap
 * @param toElemKey optional key function
 */
declare function queryElemOverlap<T>(query: UpSetQuery<T>, what: keyof SetElemOverlap<T>, toElemKey?: (e: T) => string): (s: ISetLike<T>) => readonly T[] | null;

declare function isSet(v: any): v is ISet<any>;
declare function isSetCombination(v: any): v is ISetCombination<any>;
declare function isSetLike(v: any): v is ISetLike<any>;
declare function isGenerateSetCombinationOptions(v: any): v is GenerateSetCombinationsOptions<any>;
declare function isUpSetQuery(v: any): v is UpSetQuery<any>;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>
 */
declare type BandScaleLike = {
    (v: string): number | undefined;
    bandwidth(): number;
};
declare type BandScaleFactory = {
    (domain: string[], size: number, padding: number): BandScaleLike;
};
declare const bandScale: BandScaleFactory;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>
 */
declare type TickOptions = {
    orientation: 'horizontal' | 'vertical';
    fontSizeHint: number;
};
declare type NumericScaleTick = {
    value: number;
    label?: string;
};
declare type NumericScaleLike = {
    (v: number): number;
    ticks(count?: number): readonly (NumericScaleTick | number)[];
    tickFormat(): (v: number) => string;
};
declare type NumericScaleFactory = {
    (max: number, range: [number, number], options: TickOptions): NumericScaleLike;
};

declare const linearScale: NumericScaleFactory;

declare const logScale: NumericScaleFactory;

/**
 * creates an (compressed) indices array for the given array of elements
 * @param arr the array to compress
 * @param toIndex the element to index function
 */
declare function toIndicesArray<T>(arr: readonly T[], toIndex: (v: T) => number, { sortAble, compress }?: {
    sortAble?: boolean;
    compress?: 'no' | 'yes' | 'auto';
}): string | readonly number[];
/**
 * reverse operation of `toIndicesArray` by supporting compressed indices notation
 * @param indices the (compressed) indices
 * @param elements the elements to refer by index
 */
declare function fromIndicesArray<T>(indices: string | readonly number[], elements: readonly T[]): readonly T[];

interface IUpSetDumpRef {
    type: 'set' | SetCombinationType;
    index: number;
}

interface IUpSetFromDumpConfig<T> {
    toElemKey?(set: T): string;
}
declare function fromDump<T>(dump: IUpSetDump, elems: readonly T[], options?: IUpSetFromDumpConfig<T>): {
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
    selection?: ISetLike<T> | readonly T[];
    queries: ReadonlyArray<UpSetElemQuery<T> | UpSetSetQuery<T>>;
};
declare type UpSetCompressedIndices = readonly number[] | string;
interface IUpSetDump {
    sets: ReadonlyArray<{
        name: string;
        color?: string;
        cardinality: number;
        elems: UpSetCompressedIndices;
    }>;
    combinations?: ReadonlyArray<{
        name: string;
        color?: string;
        type: SetCombinationType;
        sets: readonly number[];
        degree: number;
        cardinality: number;
        elems: UpSetCompressedIndices;
    }>;
    combinationOptions?: Omit<GenerateSetCombinationsOptions, 'elems'>;
    selection?: IUpSetDumpRef | UpSetCompressedIndices;
    queries: ReadonlyArray<{
        name: string;
        color: string;
        set?: IUpSetDumpRef;
        elems?: UpSetCompressedIndices;
    }>;
}
interface IUpSetDumpData<T> {
    toElemIndex(v: T): number;
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
    combinationOptions?: GenerateSetCombinationsOptions<T>;
    selection?: ISetLike<T> | readonly T[];
    queries: ReadonlyArray<UpSetElemQuery<T> | UpSetSetQuery<T>>;
}
interface IUpSetToDumpConfig<T> {
    compress?: 'no' | 'yes' | 'auto';
    toKey?(set: ISetLike<T>): string;
}
declare function toDump<T>(data: IUpSetDumpData<T>, config?: IUpSetToDumpConfig<T>): IUpSetDump;

declare type UpSetFromStaticDumpFullCombination = {
    name: string;
    type: SetCombinationType;
    sets: readonly number[];
    cardinality: number;
};
declare type UpSetFromStaticDumpCompressedCombination = {
    n?: string;
    cc?: string;
    c: number;
    type?: 'c' | 'i' | 'u' | 'd';
    s: number;
};
interface IUpSetStaticDump {
    sets: ReadonlyArray<{
        name: string;
        color?: string;
        cardinality: number;
    } | {
        n: string;
        cc?: string;
        c: number;
    }>;
    combinations: ReadonlyArray<UpSetFromStaticDumpFullCombination | UpSetFromStaticDumpCompressedCombination>;
    selection?: IUpSetDumpRef | readonly number[];
    queries: ReadonlyArray<{
        name: string;
        color: string;
        set?: IUpSetDumpRef;
        overlaps?: readonly number[];
    }>;
    overlaps: readonly (readonly number[])[] | string;
}
interface IUpSetStaticDumpData<T> {
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
    selection?: ISetLike<T> | readonly T[];
    queries: ReadonlyArray<UpSetElemQuery<T> | UpSetSetQuery<T>>;
}
interface IUpSetToStaticDumpConfig<T> {
    compress?: 'no' | 'yes' | 'auto';
    toKey?(set: ISetLike<T>): string;
    toElemKey?(set: T): string;
}
declare function toStaticDump<T>(data: IUpSetStaticDumpData<T>, config?: IUpSetToStaticDumpConfig<T>): IUpSetStaticDump;
interface IUpSetFromStaticDumpConfig<T> {
    toKey?(set: ISetLike<T>): string;
}
declare function fromStaticDump(dump: IUpSetStaticDump, config?: IUpSetFromStaticDumpConfig<never>): {
    sets: ISets<never>;
    combinations: ISetCombinations<never>;
    selection?: ISetLike<never> | ((v: ISetLike<never>) => number);
    queries: ReadonlyArray<UpSetCalcQuery<never> | UpSetSetQuery<never>>;
};

declare function parseColor(color?: string): [number, number, number];
declare function mergeColors(colors: readonly (string | undefined)[]): string | undefined;

interface ITextLocation {
    text: {
        x: number;
        y: number;
    };
}
interface ICircle {
    r: number;
    cx: number;
    cy: number;
}
interface IEllipse {
    rx: number;
    ry: number;
    rotation: number;
    cx: number;
    cy: number;
}
interface ITextCircle extends ICircle, ITextLocation {
    align: 'start' | 'end' | 'middle';
    verticalAlign: 'top' | 'bottom';
}
interface ITextEllipse extends IEllipse, ITextLocation {
    align: 'start' | 'end' | 'middle';
    verticalAlign: 'top' | 'bottom';
}
interface IArc {
    x2: number;
    y2: number;
    sweep: boolean;
    large: boolean;
    ref: number;
    mode: 'i' | 'o';
}
interface IArcSlice {
    sets: readonly number[];
    x1: number;
    y1: number;
    arcs: readonly IArc[];
    path?: string;
}
interface ITextArcSlice extends IArcSlice, ITextLocation {
}
interface IUniverseSet extends IArcSlice {
    width: number;
    height: number;
}
interface ITextUniverseSet extends IUniverseSet, ITextLocation {
}
interface IVennDiagramLayoutGenerator {
    readonly maxSets: number;
    compute<T>(sets: ISets<T>, combinations: ISetCombinations<T>, width: number, height: number): IVennDiagramLayout;
}
interface IVennDiagramLayout {
    sets: (ITextCircle | ITextEllipse)[];
    universe?: ITextUniverseSet;
    intersections: ITextArcSlice[];
}

interface UpSetAddonProps<S extends ISetLike<T>, T> {
    /**
     * the current set to visualize
     */
    set: S;
    /**
     * the addon width
     */
    width: number;
    /**
     * the addon height
     */
    height: number;
    /**
     * the theme of the UpSetJS plot
     */
    theme: 'dark' | 'light' | 'vega';
}
declare type UpSetSelection<T> = ISetLike<T> | null | readonly T[] | ((s: ISetLike<T>) => number);
interface UpSetSelectionAddonProps<S extends ISetLike<T>, T> extends UpSetAddonProps<S, T> {
    /**
     * the current selection of the plot
     */
    selection: UpSetSelection<T>;
    /**
     * the specified selection color
     */
    selectionColor: string;
    /**
     * the optional overlap of the selection with the current set
     */
    overlap: readonly T[] | null;
}
interface UpSetQueryAddonProps<S extends ISetLike<T>, T> extends UpSetAddonProps<S, T> {
    /**
     * the current query to show
     */
    query: UpSetQuery<T>;
    /**
     * query index
     */
    index: number;
    /**
     * the optional overlap of the query with the current set
     */
    overlap: readonly T[] | null;
    /**
     * whether to render the query in secondary mode
     */
    secondary: boolean;
}
interface UpSetAddonHandlerInfo {
    readonly id: string;
    readonly name: string;
    readonly value: {
        toString(): void;
    };
}
declare type UpSetAddonHandlerInfos = readonly (UpSetAddonHandlerInfo | null)[];
interface UpSetAddon<S extends ISetLike<T>, T, N> {
    /**
     * addon name
     */
    name: string;
    /**
     * addon position before or after the bar
     * @default after
     */
    position?: 'before' | 'after';
    /**
     * size of this addon in pixel
     */
    size: number;
    /**
     * react component to render the addon
     */
    render: (props: UpSetAddonProps<S, T>) => N;
    /**
     * optional react component to render the selection
     */
    renderSelection?: (props: UpSetSelectionAddonProps<S, T>) => N;
    /**
     * optional react component to render a query
     */
    renderQuery?: (props: UpSetQueryAddonProps<S, T>) => N;
    createOnHandlerData?: (s: S) => UpSetAddonHandlerInfo;
}
declare type UpSetAddons<S extends ISetLike<T>, T, N> = readonly UpSetAddon<S, T, N>[];
interface UpSetBaseFontSizes {
    /**
     * @default 16px
     */
    setLabel?: string;
    /**
     * @default 10px
     */
    legend?: string;
    /**
     * @default 24px
     */
    title?: string;
    /**
     * @default 16px
     */
    description?: string;
    /**
     * @default 10px
     */
    exportLabel?: string;
}
interface UpSetFontSizes extends UpSetBaseFontSizes {
    /**
     * @default 16px
     */
    chartLabel?: string;
    /**
     * @default 10px
     */
    axisTick?: string;
    /**
     * @default 10px
     */
    barLabel?: string;
}
interface VennDiagramFontSizes extends UpSetBaseFontSizes {
    /**
     * @default 12px
     */
    valueLabel?: string;
}
interface KarnaughMapFontSizes extends UpSetBaseFontSizes {
    /**
     * @default 10px
     */
    axisTick?: string;
    /**
     * @default 10px
     */
    barLabel?: string;
    /**
     * @default 16px
     */
    chartLabel?: string;
}
interface UpSetBaseMultiStyle<C> {
    setLabel?: C;
    legend?: C;
    title?: C;
    description?: C;
}
interface UpSetMultiStyle<C> extends UpSetBaseMultiStyle<C> {
    chartLabel?: C;
    axisTick?: C;
    barLabel?: C;
    bar?: C;
    dot?: C;
}
interface VennDiagramMultiStyle<C> extends UpSetBaseMultiStyle<C> {
    valueLabel?: C;
    set?: C;
}
interface KarnaughMapMultiStyle<C> extends UpSetBaseMultiStyle<C> {
    chartLabel?: C;
    axisTick?: C;
    barLabel?: C;
    bar?: C;
    set?: C;
}
interface UpSetBaseDataProps<T> {
    /**
     * the sets to visualize
     */
    sets: ISets<T>;
    /**
     * optional function to identify the same sets
     * @param set the set to generate a key for
     */
    toKey?: (set: ISetLike<T>) => string;
    /**
     * optional function to identify the same element
     * @param elem the element the key for
     */
    toElemKey?: (elem: T) => string;
}
interface UpSetDataProps<T, N> extends UpSetBaseDataProps<T> {
    /**
     * the set combinations to visualize or the generation options to generate the set combinations
     * by default all set intersections are computed
     */
    combinations?: ISetCombinations<T> | GenerateSetCombinationsOptions<T>;
    /**
     * list of addons that should be rendered along the horizontal sets
     */
    setAddons?: UpSetAddons<ISet<T>, T, N>;
    /**
     * list of addons that should be rendered along the vertical set combinations
     */
    combinationAddons?: UpSetAddons<ISetCombination<T>, T, N>;
    /**
     * padding between combination addons
     * @default 1
     */
    setAddonPadding?: number;
    /**
     * padding between combination addons
     * @default 1
     */
    combinationAddonPadding?: number;
    /**
     * numeric scale to use, either constants 'linear' or 'log' or a custom factory function
     * @default linear
     */
    numericScale?: NumericScaleFactory | 'linear' | 'log';
    /**
     * band scale to use, either constant 'band' or a custom factory function
     * @default band
     */
    bandScale?: BandScaleFactory | 'band';
}
interface VennDiagramDataProps<T> extends UpSetBaseDataProps<T> {
    /**
     * the set combinations to visualize or the generation options to generate the distinct set combinations
     * by default all set distinct intersections are computed
     */
    combinations?: ISetCombinations<T> | {
        /**
         * optional color merger
         **/
        mergeColors?: (colors: readonly (string | undefined)[]) => string | undefined;
    };
    valueFormat?: (cardinality: number) => string;
}
interface KarnaughMapDataProps<T> extends UpSetBaseDataProps<T> {
    /**
     * the set combinations to visualize or the generation options to generate the distinct set combinations
     * by default all set distinct intersections are computed
     */
    combinations?: ISetCombinations<T> | GenerateSetCombinationsOptions<T>;
    /**
     * numeric scale to use, either constants 'linear' or 'log' or a custom factory function
     * @default linear
     */
    numericScale?: NumericScaleFactory | 'linear' | 'log';
}
interface UpSetBaseLayoutProps {
    /**
     * width of the chart
     */
    width: number;
    /**
     * height of the chart
     */
    height: number;
    /**
     * padding within the svg
     * @default 5
     */
    padding?: number;
}
interface UpSetLayoutProps extends UpSetBaseLayoutProps {
    /**
     * padding argument for scaleBand
     * @default 0.1
     */
    barPadding?: number;
    /**
     * padding factor the for dots
     * @default 0.7
     */
    dotPadding?: number;
    /**
     * width ratios for different plots
     * [set chart, set labels, intersection chart]
     * @default [0.21, 0.19, 0.7]
     */
    widthRatios?: [number, number, number];
    /**
     * height ratios for different plots
     * [intersection chart, set chart]
     * @default [0.6, 0.4]
     */
    heightRatios?: [number, number];
}
interface VennDiagramLayoutProps extends UpSetBaseLayoutProps {
    /**
     * function used to perform the venn diagram layout
     */
    layout?: IVennDiagramLayoutGenerator;
}
interface KarnaughMapLayoutProps extends UpSetBaseLayoutProps {
    /**
     * padding argument for scaleBand
     * @default 0.1
     */
    barPadding?: number;
}
interface UpSetSelectionProps<T = any> {
    /**
     * the selection of the plot. Can be a set like (set or set combination), an array of elements, or a function to compute the overlap to a given set
     */
    selection?: UpSetSelection<T>;
    /**
     * mouse hover listener, triggered when the user is over a set (combination)
     * a combination of mouseEnter and mouseLeave
     */
    onHover?: (selection: ISetLike<T> | null, evt: MouseEvent, addonInfos: UpSetAddonHandlerInfos) => void;
    /**
     * mouse move over set listener, triggered when the user is over a set (combination)
     */
    onMouseMove?: (selection: ISetLike<T>, evt: MouseEvent, addonInfos: UpSetAddonHandlerInfos) => void;
    /**
     * mouse click listener, triggered when the user is clicking on a set (combination)
     */
    onClick?: (selection: ISetLike<T> | null, evt: MouseEvent, addonInfos: UpSetAddonHandlerInfos) => void;
    /**
     * mouse context menu listener, triggered when the user right clicks on a set (combination)
     */
    onContextMenu?: (selection: ISetLike<T> | null, evt: MouseEvent, addonInfos: UpSetAddonHandlerInfos) => void;
    /**
     * list of queries as an alternative to provide a single selection
     */
    queries?: UpSetQueries<T>;
}
interface UpSetBaseThemeProps {
    /**
     * color used to highlight the selection
     * @default orange
     */
    selectionColor?: string;
    /**
     * main color to render bars and dark dots
     * @default black
     */
    color?: string;
    /**
     * main opacity
     * @default undefined
     */
    opacity?: number;
    /**
     * main color used when a selection is present
     * @default undefined
     */
    hasSelectionColor?: string;
    /**
     * main opacity used when a selection is present
     * @default undefined
     */
    hasSelectionOpacity?: number;
    /**
     * main color to render text
     * @default black
     */
    textColor?: string;
}
interface UpSetThemeProps extends UpSetBaseThemeProps {
    /**
     * color used to highlight alternating background in the sets for easier comparison
     * set to false to disable alternating pattern
     */
    alternatingBackgroundColor?: string | false;
    /**
     * color for the hover hint rects for set combinations
     */
    hoverHintColor?: string;
    /**
     * color for dots that indicate it is not a member
     */
    notMemberColor?: string;
}
interface VennDiagramThemeProps extends UpSetBaseThemeProps {
    /**
     * main color to render text
     * @default black
     */
    valueTextColor?: string;
    /**
     * stroke color to render around sets or cells
     * @default black
     */
    strokeColor?: string;
    /**
     * whether to fill the circles
     * @default false
     */
    filled?: boolean;
}
interface KarnaughMapThemeProps extends UpSetBaseThemeProps {
    /**
     * stroke color to render around sets or cells
     * @default black
     */
    strokeColor?: string;
}
declare type UpSetStyleClassNames = UpSetMultiStyle<string>;
interface UpSetBaseElementProps<C> {
    /**
     * optional unique id of the set element. Note: if set, it is will also be used as a CSS class suffix
     */
    id?: string;
    /**
     * optional class name for the SVG element
     */
    className?: string;
    /**
     * style object applied to the SVG element
     */
    style?: C;
}
interface UpSetElementProps<T, C, N> extends UpSetBaseElementProps<C> {
    /**
     * object of classnames for certain sub elements
     */
    classNames?: UpSetStyleClassNames;
    /**
     * object for applying styles to certain sub elements
     */
    styles?: UpSetMultiStyle<C>;
    /**
     * factory to create extra react nodes for each set
     */
    setChildrenFactory?: (set: ISet<T>) => N;
    /**
     * factory to create extra react nodes for each set combination
     */
    combinationChildrenFactory?: (combination: ISetCombination<T>) => N;
}
interface VennDiagramElementProps<C> extends UpSetBaseElementProps<C> {
    /**
     * object of classnames for certain sub elements
     */
    classNames?: VennDiagramMultiStyle<string>;
    /**
     * object for applying styles to certain sub elements
     */
    styles?: VennDiagramMultiStyle<C>;
}
interface KarnaughMapElementProps<C> extends UpSetBaseElementProps<C> {
    /**
     * object of classnames for certain sub elements
     */
    classNames?: KarnaughMapMultiStyle<string>;
    /**
     * object for applying styles to certain sub elements
     */
    styles?: KarnaughMapMultiStyle<C>;
}
interface UpSetExportOptions {
    png?: boolean;
    svg?: boolean;
    vega?: boolean;
    dump?: boolean;
    share?: boolean;
}
declare type UpSetThemes = 'light' | 'dark' | 'vega';
interface UpSetBaseStyleProps<L> {
    /**
     * basic theme of the plot either 'light' or 'dark'
     * @default light
     */
    theme?: UpSetThemes;
    /**
     * show a legend of queries
     * enabled by default when queries are set
     */
    queryLegend?: boolean;
    /**
     * show export buttons
     * @default true
     */
    exportButtons?: boolean | UpSetExportOptions;
    /**
     * specify the overall font family, set to false to use the default font family
     * @default sans-serif
     */
    fontFamily?: string | false;
    /**
     * optional title text for the plot
     */
    title?: L;
    /**
     * optional description text for the plot
     */
    description?: L;
    /**
     * whether to render tooltips aka title attributes
     * @default true
     */
    tooltips?: boolean;
}
interface UpSetStyleProps<L> extends UpSetBaseStyleProps<L> {
    /**
     * offset of the label on top or left of a bar
     * @default 2
     */
    barLabelOffset?: number;
    /**
     * set axis label
     * @default Set Size
     */
    setName?: L;
    /**
     * offset of the set name from the set x axis. 'auto' means that it will be guessed according to the current values
     * @default auto
     */
    setNameAxisOffset?: number | 'auto';
    /**
     * combination axis label
     * @default Intersection Size
     */
    combinationName?: L;
    /**
     * offset of the combination name from the combination y axis. 'auto' means that it will be guessed according to the current values
     * @default auto
     */
    combinationNameAxisOffset?: number | 'auto';
    /**
     * specify font sizes for different sub elements
     */
    fontSizes?: UpSetFontSizes;
    /**
     * render empty selection for better performance
     * @default true
     */
    emptySelection?: boolean;
}
interface VennDiagramStyleProps<L> extends UpSetBaseStyleProps<L> {
    /**
     * specify font sizes for different sub elements
     */
    fontSizes?: VennDiagramFontSizes;
}
interface KarnaughMapStyleProps<L> extends UpSetBaseStyleProps<L> {
    /**
     * specify font sizes for different sub elements
     */
    fontSizes?: KarnaughMapFontSizes;
    /**
     * render empty selection for better performance
     * @default true
     */
    emptySelection?: boolean;
    /**
     * offset of the label on top or left of a bar
     * @default 2
     */
    barLabelOffset?: number;
    /**
     * combination axis label
     * @default Intersection Size
     */
    combinationName?: L;
    /**
     * offset of the combination name from the combination y axis. 'auto' means that it will be guessed according to the current values
     * @default auto
     */
    combinationNameAxisOffset?: number | 'auto';
}
/**
 * the UpSetJS component properties, separated in multiple semantic sub interfaces
 */
interface UpSetPropsG<T, C, N, L> extends UpSetDataProps<T, N>, UpSetLayoutProps, UpSetStyleProps<L>, UpSetThemeProps, UpSetElementProps<T, C, N>, UpSetSelectionProps<T> {
    children?: N;
}
interface UpSetFullPropsG<T, C, N, L> extends Required<Omit<UpSetDataProps<T, N>, 'toElemKey'>>, Required<UpSetLayoutProps>, Required<UpSetStyleProps<L>>, Required<UpSetThemeProps>, Required<UpSetElementProps<T, C, N>>, UpSetSelectionProps<T> {
    children?: N;
    toElemKey?: (elem: T) => string;
}
interface VennDiagramPropsG<T, C, N, L> extends VennDiagramDataProps<T>, VennDiagramLayoutProps, VennDiagramStyleProps<L>, VennDiagramThemeProps, VennDiagramElementProps<C>, UpSetSelectionProps<T> {
    children?: N;
}
interface VennDiagramFullPropsG<T, C, N, L> extends Required<Omit<VennDiagramDataProps<T>, 'toElemKey'>>, Required<VennDiagramLayoutProps>, Required<VennDiagramStyleProps<L>>, Required<VennDiagramThemeProps>, Required<VennDiagramElementProps<C>>, UpSetSelectionProps<T> {
    toElemKey?: (elem: T) => string;
    children?: N;
}
interface KarnaughMapPropsG<T, C, N, L> extends KarnaughMapDataProps<T>, KarnaughMapLayoutProps, KarnaughMapStyleProps<L>, KarnaughMapThemeProps, KarnaughMapElementProps<C>, UpSetSelectionProps<T> {
    children?: N;
}
interface KarnaughMapFullPropsG<T, C, N, L> extends Required<Omit<KarnaughMapDataProps<T>, 'toElemKey'>>, Required<KarnaughMapLayoutProps>, Required<KarnaughMapStyleProps<L>>, Required<KarnaughMapThemeProps>, Required<KarnaughMapElementProps<C>>, UpSetSelectionProps<T> {
    toElemKey?: (elem: T) => string;
    children?: N;
}

declare type UpSetExtraTheme = {
    backgroundColor: string;
};
declare function getDefaultTheme(theme?: UpSetThemes): Readonly<Required<UpSetThemeProps & VennDiagramThemeProps & UpSetExtraTheme>>;

interface UpSetJSDumpProps extends Partial<UpSetLayoutProps & KarnaughMapLayoutProps>, UpSetThemeProps, VennDiagramThemeProps, KarnaughMapThemeProps, Omit<UpSetStyleProps<string>, 'title' | 'description'> {
    numericScale?: 'linear' | 'log';
    bandScale?: 'band';
}
interface IUpSetJSDump extends IUpSetDump {
    $schema: string;
    name: string;
    description: string;
    author?: string;
    mode?: 'upset' | 'venn' | 'kmap';
    elements: readonly (number | string | any)[];
    attrs: readonly string[];
    props: UpSetJSDumpProps;
}
interface IUpSetJSStaticDump extends IUpSetStaticDump {
    $schema: string;
    name: string;
    description: string;
    author?: string;
    props: UpSetJSDumpProps;
    mode?: 'upset' | 'venn' | 'kmap';
}

interface IVennJSSetOverlap {
    sets: readonly string[];
    size: number;
    weight?: number;
}
interface IVennJSArc {
    circle: {
        x: number;
        y: number;
        radius: number;
    };
    width: number;
    p1: {
        x: number;
        y: number;
    };
    p2: {
        x: number;
        y: number;
    };
}
interface IVennJSVennLayout {
    data: IVennJSSetOverlap;
    text: {
        x: number;
        y: number;
    };
    circles: readonly {
        x: number;
        y: number;
        radius: number;
        set: string;
    }[];
    arcs: readonly IVennJSArc[];
    path?: string;
    distinctPath?: string;
}
interface IVennJSLayoutFunction<O extends {
    width?: number;
    height?: number;
    distinct?: boolean;
}> {
    (data: readonly IVennJSSetOverlap[], options: O): readonly IVennJSVennLayout[];
}
declare function createVennJSAdapter<O extends {
    width?: number;
    height?: number;
}>(layout: IVennJSLayoutFunction<O>, options?: O): IVennDiagramLayoutGenerator;

declare function widthRatios(value?: [number, number, number]): boolean;
declare function heightRatios(value?: [number, number]): boolean;
declare function sets(value: ISets<any>): boolean;
declare function combinations(value?: ISetCombinations<any> | GenerateSetCombinationsOptions<any>): boolean;
declare function selection(value?: ISetLike<any> | readonly any[]): boolean;
declare function onHover(value?: (selection: ISetLike<any> | null) => void): boolean;
declare function onClick(value?: (selection: ISetLike<any> | null) => void): boolean;
declare function queries(value?: UpSetQuery<any>[]): boolean;
declare function stringOrFalse(value?: string | false): boolean;
declare function theme(value?: UpSetThemes): boolean;
declare function classNames(value?: UpSetStyleClassNames | VennDiagramMultiStyle<string>): boolean;
declare function fontSizes(value?: UpSetFontSizes | VennDiagramFontSizes): boolean;
declare function numericScale(value?: 'linear' | 'log' | NumericScaleFactory): boolean;
declare function bandScale$1(value?: 'band' | BandScaleFactory): boolean;
declare function axisOffset(value?: 'auto' | number): boolean;
declare function style(value?: any): boolean;
declare function styles(value?: UpSetMultiStyle<any> | VennDiagramMultiStyle<any>): boolean;
declare function exportButtons(value?: boolean | UpSetExportOptions): boolean;

declare const validators_widthRatios: typeof widthRatios;
declare const validators_heightRatios: typeof heightRatios;
declare const validators_sets: typeof sets;
declare const validators_combinations: typeof combinations;
declare const validators_selection: typeof selection;
declare const validators_onHover: typeof onHover;
declare const validators_onClick: typeof onClick;
declare const validators_queries: typeof queries;
declare const validators_stringOrFalse: typeof stringOrFalse;
declare const validators_theme: typeof theme;
declare const validators_classNames: typeof classNames;
declare const validators_fontSizes: typeof fontSizes;
declare const validators_numericScale: typeof numericScale;
declare const validators_bandScale: typeof bandScale$1;
declare const validators_axisOffset: typeof axisOffset;
declare const validators_style: typeof style;
declare const validators_styles: typeof styles;
declare const validators_exportButtons: typeof exportButtons;
declare namespace validators {
  export {
    validators_widthRatios as widthRatios,
    validators_heightRatios as heightRatios,
    validators_sets as sets,
    validators_combinations as combinations,
    validators_selection as selection,
    validators_onHover as onHover,
    validators_onClick as onClick,
    validators_queries as queries,
    validators_stringOrFalse as stringOrFalse,
    validators_theme as theme,
    validators_classNames as classNames,
    validators_fontSizes as fontSizes,
    validators_numericScale as numericScale,
    validators_bandScale as bandScale,
    validators_axisOffset as axisOffset,
    validators_style as style,
    validators_styles as styles,
    validators_exportButtons as exportButtons,
  };
}

declare type UpSetReactElement = any;
declare type UpSetAddon$1<T> = UpSetAddon<ISetLike<T>, T, UpSetReactElement>;
declare type UpSetAddons$1<T> = readonly UpSetAddon$1<T>[];

/**
 * @upsetjs/math
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2020 Samuel Gratzl <sam@sgratzl.com>
 */
interface IBoxPlot {
    readonly min: number;
    readonly max: number;
    readonly median: number;
    readonly q1: number;
    readonly q3: number;
    readonly outlier: number[];
    readonly whiskerLow: number;
    readonly whiskerHigh: number;
    readonly mean: number;
    readonly missing: number;
    readonly count: number;
}
declare type QuantilesMethod = 'hinges' | 'fivenum' | 'type7' | 'quantiles' | 'linear' | 'lower' | 'higher' | 'nearest' | 'midpoint';
declare type CustomQuantileMethod = (arr: ArrayLike<number>, length: number) => {
    q1: number;
    median: number;
    q3: number;
};
declare type BoxplotStatsOptions = {
    /**
     * @default 1.5
     */
    coef?: number;
    /**
     * @default type7
     */
    quantiles?: QuantilesMethod | CustomQuantileMethod;
};
declare function boxplot(data: readonly number[], options?: BoxplotStatsOptions): IBoxPlot;

declare interface ICategory {
    value: string;
    color?: string;
    label?: string;
}
declare type ICategories = readonly ICategory[];
interface ICategoryBin extends Required<ICategory> {
    count: number;
    /**
     * accumulated count
     */
    acc: number;
    percentage: number;
}
declare type ICategoryBins = readonly ICategoryBin[];
declare function categoricalHistogram(values: readonly string[], categories: readonly (string | ICategory)[], base?: readonly string[], dark?: boolean): readonly ICategoryBin[];

interface IBoxplotStylePlainProps extends BoxplotStatsOptions {
    theme?: UpSetThemes;
    /**
     * the render mode and level of detail to render
     * @default normal
     */
    mode?: 'normal' | 'box' | 'indicator';
    /**
     * orientation of the box plot
     * @default horizontal
     */
    orient?: 'horizontal' | 'vertical';
    /**
     * margin applied
     * @default 0
     */
    margin?: number;
    /**
     * padding of the box from its corners
     * @default 0.1
     */
    boxPadding?: number;
    /**
     * radius of the outlier circles
     * @default 3
     */
    outlierRadius?: number;
    /**
     * number format used for the tooltip
     * @default .toFixed(2)
     */
    numberFormat?(v: number): string;
    /**
     * whether to render tooltips
     * @default true
     */
    tooltips?: boolean;
}

interface ICategoricalStyleProps {
    theme?: UpSetThemes;
    /**
     * orientation of the box plot
     * @default horizontal
     */
    orient?: 'horizontal' | 'vertical';
}

interface IBoxplotStyleProps extends IBoxplotStylePlainProps {
    /**
     * custom styles applied to the box element
     */
    boxStyle?: CSSStyleDeclaration;
    /**
     * custom styles applied to the whisker element
     */
    lineStyle?: CSSStyleDeclaration;
    /**
     * custom styles applied to the outlier elements
     */
    outlierStyle?: CSSStyleDeclaration;
}
/**
 * generates a boxplot addon to render box plots as UpSet.js addon for aggregated set data
 * @param prop accessor or name of the property within the element
 * @param elems list of elements or their minimum / maximum value for specifying the data domain
 * @param options additional options
 */
declare function boxplotAddon<T>(prop: keyof T | ((v: T) => number), elems: readonly T[] | {
    min: number;
    max: number;
}, options?: Partial<Pick<UpSetAddon$1<T>, 'size' | 'position' | 'name'>> & IBoxplotStyleProps): UpSetAddon$1<T>;
/**
 * generates a boxplot addon to render box plots as UpSet.js addon for aggregated set data
 * @param acc accessor
 * @param elems list of elements or their minimum / maximum value for specifying the data domain
 * @param options additional options
 */
declare function boxplotAggregatedAddon<T>(acc: (v: readonly T[]) => IBoxPlot, domain: {
    min: number;
    max: number;
}, options?: Partial<Pick<UpSetAddon$1<T>, 'size' | 'position' | 'name'>> & IBoxplotStyleProps): UpSetAddon$1<T>;

/**
 * generates a categorical addon to render categorical distribution as UpSet.js addon for aggregated set data
 * @param prop accessor or name of the property within the element
 * @param elems list of elements or their minimum / maximum value for specifying the data domain
 * @param options additional options
 */
declare function categoricalAddon<T>(prop: keyof T | ((v: T) => string), elems: readonly T[] | {
    categories: readonly (string | ICategory)[];
}, options?: Partial<Pick<UpSetAddon$1<T>, 'size' | 'position' | 'name'>> & ICategoricalStyleProps): UpSetAddon$1<T>;
/**
 * generates a categorical addon to render categorical distribution as UpSet.js addon for aggregated set data
 * @param prop accessor or name of the property within the element
 * @param elems list of elements or their minimum / maximum value for specifying the data domain
 * @param options additional options
 */
declare function categoricalAggregatedAddon<T>(acc: (v: readonly T[]) => ICategoryBins, options?: Partial<Pick<UpSetAddon$1<T>, 'size' | 'position' | 'name'>> & ICategoricalStyleProps): UpSetAddon$1<T>;

declare type UpSetJSSkeletonProps = {
    background?: string;
    color?: string;
    secondaryColor?: string;
    [key: string]: any;
};
declare type UpSetProps<T = any> = UpSetPropsG<T, CSSStyleDeclaration, UpSetReactElement, string>;
declare type UpSetFullProps<T = any> = UpSetFullPropsG<T, CSSStyleDeclaration, UpSetReactElement, string>;
declare type VennDiagramProps<T = any> = VennDiagramPropsG<T, CSSStyleDeclaration, UpSetReactElement, string>;
declare type VennDiagramFullProps<T = any> = VennDiagramFullPropsG<T, CSSStyleDeclaration, UpSetReactElement, string>;
declare type KarnaughMapProps<T = any> = KarnaughMapPropsG<T, CSSStyleDeclaration, UpSetReactElement, string>;
declare type KarnaughMapFullProps<T = any> = KarnaughMapFullPropsG<T, CSSStyleDeclaration, UpSetReactElement, string>;
/**
 * helper methods to fill up partial UpSet.js properties with their default values
 */
declare function fillDefaults<T = any>(props: UpSetProps<T>): UpSetFullProps<T>;
/**
 * helper methods to fill up partial UpSet.js properties with their default values
 */
declare function fillVennDiagramDefaults<T = any>(props: VennDiagramProps<T>): VennDiagramFullProps<T>;
/**
 * helper methods to fill up partial UpSet.js properties with their default values
 */
declare function fillKarnaughMapDefaults<T = any>(props: KarnaughMapProps<T>): KarnaughMapFullProps<T>;
/**
 * renders the UpSetJS component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function render<T = any>(node: HTMLElement, props: UpSetProps<T>): void;
/**
 * renders the VennDiagram component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function renderVennDiagram<T = any>(node: HTMLElement, props: VennDiagramProps<T>): void;
/**
 * renders the KarnaughMap component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function renderKarnaughMap<T = any>(node: HTMLElement, props: KarnaughMapProps<T>): void;
/**
 * renders the UpSetJS skeleton component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function renderSkeleton(node: HTMLElement, props: UpSetJSSkeletonProps): void;
/**
 * renders the VennDiagram skeleton component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function renderVennDiagramSkeleton(node: HTMLElement, props: UpSetJSSkeletonProps): void;
/**
 * renders the KarnaughMap skeleton component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function renderKarnaughMapSkeleton(node: HTMLElement, props: UpSetJSSkeletonProps): void;
/**
 * renders the UpSetJS component
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare const renderUpSet: typeof render;
/**
 * hydrates the UpSetJS component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function hydrate<T = any>(node: HTMLElement, props: UpSetProps<T>): void;
/**
 * hydrates the VennDiagram component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function hydrateVennDiagram<T = any>(node: HTMLElement, props: VennDiagramProps<T>): void;
/**
 * hydrates the KarnaughMap component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function hydrateKarnaughMap<T = any>(node: HTMLElement, props: KarnaughMapProps<T>): void;
/**
 * hydrates the UpSetJS Skeleton component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function hydrateSkeleton(node: HTMLElement, props: UpSetJSSkeletonProps): void;
/**
 * hydrates the VennDiagram Skeleton component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function hydrateVennDiagramSkeleton(node: HTMLElement, props: UpSetJSSkeletonProps): void;
/**
 * hydrates the KarnaughMap Skeleton component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare function hydrateKarnaughMapSkeleton(node: HTMLElement, props: UpSetJSSkeletonProps): void;
/**
 * hydrates the UpSetJS component when applied on a server rendered version
 * @param node the DOM node to render the component into
 * @param props the properties of the component
 */
declare const hydrateUpSet: typeof hydrate;
/**
 * helper method to export an download an SVG image
 * @param node the SVG element to download
 * @param options additional options
 */
declare function exportSVG(node: SVGSVGElement, options: {
    type?: 'png' | 'svg';
    title?: string;
    toRemove?: string;
}): Promise<void>;
/**
 * helper method to download a given url in the browser
 * @param url the url to download
 * @param title the desired file name
 * @param doc the root document
 */
declare function downloadUrl(url: string, title: string, doc: Document): void;
declare function toUpSetJSDump(dump: IUpSetDump, elements: readonly (number | string | any)[], props: Partial<UpSetProps<any>>, author?: string, mode?: 'upset' | 'venn' | 'kmap'): IUpSetJSDump;
declare function toUpSetJSStaticDump(dump: IUpSetStaticDump, props: Partial<UpSetProps<any>>, author?: string, mode?: 'upset' | 'venn' | 'kmap'): IUpSetJSStaticDump;

export { BandScaleFactory, BandScaleLike, BoxplotStatsOptions, ExtractFromExpressionOptions, GenerateSetCombinationsOptions, IBaseSet, IBoxPlot, IBoxplotStyleProps, ICategoricalStyleProps, ICategories, ICategory, ICategoryBin, ICategoryBins, IDistinctSetIntersection, ISet, ISetCombination, ISetCombinations, ISetComposite, ISetIntersection, ISetLike, ISetLikes, ISetUnion, ISets, IUpSetDump, IUpSetDumpData, IUpSetDumpRef, IUpSetFromDumpConfig, IUpSetFromStaticDumpConfig, IUpSetJSDump, IUpSetJSStaticDump, IUpSetStaticDump, IUpSetStaticDumpData, IUpSetToDumpConfig, IUpSetToStaticDumpConfig, KarnaughMapFontSizes, KarnaughMapFullProps, KarnaughMapLayoutProps, KarnaughMapProps, KarnaughMapThemeProps, NumericScaleFactory, NumericScaleLike, NumericScaleTick, PostprocessCombinationsOptions, PostprocessSetOptions, QuantilesMethod, SetCombinationType, SetElemOverlap, SetOverlap, TickOptions, UpSetAddon$1 as UpSetAddon, UpSetAddonHandlerInfo, UpSetAddonHandlerInfos, UpSetAddons$1 as UpSetAddons, UpSetCalcQuery, UpSetCompressedIndices, UpSetElemQuery, UpSetExportOptions, UpSetFontSizes, UpSetFullProps, UpSetJSDumpProps, UpSetJSSkeletonProps, UpSetLayoutProps, UpSetProps, UpSetQueries, UpSetQuery, UpSetReactElement, UpSetSelectionProps, UpSetSetQuery, UpSetStyleClassNames, UpSetStyleProps, UpSetThemeProps, UpSetThemes, VennDiagramFontSizes, VennDiagramFullProps, VennDiagramLayoutProps, VennDiagramProps, VennDiagramThemeProps, asCombination, asCombinations, asSet, asSets, bandScale, boxplot, boxplotAddon, boxplotAggregatedAddon, categoricalAddon, categoricalAggregatedAddon, categoricalHistogram, createVennJSAdapter, downloadUrl, exportSVG, extractFromExpression, extractSets, fillDefaults, fillKarnaughMapDefaults, fillVennDiagramDefaults, fromDump, fromIndicesArray, fromSetName, fromStaticDump, generateCombinations, getDefaultTheme, hydrate, hydrateKarnaughMap, hydrateKarnaughMapSkeleton, hydrateSkeleton, hydrateUpSet, hydrateVennDiagram, hydrateVennDiagramSkeleton, isCalcQuery, isElemQuery, isGenerateSetCombinationOptions, isSet, isSetCombination, isSetLike, isSetQuery, isUpSetQuery, linearScale, logScale, mergeColors, parseColor, validators as propValidators, queryElemOverlap, queryOverlap, render, renderKarnaughMap, renderKarnaughMapSkeleton, renderSkeleton, renderUpSet, renderVennDiagram, renderVennDiagramSkeleton, setElemIntersectionFactory, setElemOverlap, setElemOverlapFactory, setOverlap, setOverlapFactory, toDump, toIndicesArray, toKey, toStaticDump, toUpSetJSDump, toUpSetJSStaticDump };
